/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _vue = __webpack_require__(1);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _vueRouter = __webpack_require__(2);\n\nvar _vueRouter2 = _interopRequireDefault(_vueRouter);\n\nvar _app = __webpack_require__(3);\n\nvar _app2 = _interopRequireDefault(_app);\n\nvar _task = __webpack_require__(47);\n\nvar _task2 = _interopRequireDefault(_task);\n\nvar _taskList = __webpack_require__(63);\n\nvar _taskList2 = _interopRequireDefault(_taskList);\n\nvar _login = __webpack_require__(77);\n\nvar _login2 = _interopRequireDefault(_login);\n\nvar _signup = __webpack_require__(81);\n\nvar _signup2 = _interopRequireDefault(_signup);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n__webpack_require__(84);\n// import { sync } from 'vuex-router-sync';\n// import VueResource from 'vue-resource';\n\n// import store from './vuex/store';\n\n_vue2.default.use(_vueRouter2.default);\n// Vue.use(VueResource);\n_vue2.default.config.devtools = true;\n_vue2.default.config.debug = true;\n\n// Vue.http.options.root = 'http://zhanglun.daoapp.io/api';\n// Vue.http.options.root = 'http://localhost:1234/api';\n\n// Vue.http.interceptors.push({\n//   request: function(request) {\n//     Vue.http.headers.common['x-access-token'] = window.localStorage.token;\n//     return request;\n//   },\n//   response: function(response) {\n//     return response;\n//   },\n// });\n\n// routing\nvar router = new _vueRouter2.default({\n  linkActiveClass: 'side-menu__item--active'\n});\n\nrouter.map({\n  '/': {\n    component: _app2.default\n  },\n  '/lists': {\n    component: _task2.default,\n    subRoutes: {\n      '/:id': {\n        name: 'list',\n        component: _taskList2.default\n      }\n    },\n    auth: true\n  },\n  '/login': {\n    component: _login2.default\n  },\n  '/signup': {\n    component: _signup2.default\n  }\n});\n\nrouter.redirect({\n  '*': '/'\n});\n\nrouter.start(_app2.default, '#app');\n\n// sync(store, router);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2luZGV4LmpzPzA1YTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7OztBQUNBOzs7O0FBTUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBYkEsb0JBQVEsRUFBUjtBQUlBO0FBQ0E7O0FBRUE7O0FBUUEsY0FBSSxHQUFKO0FBQ0E7QUFDQSxjQUFJLE1BQUosQ0FBVyxRQUFYLEdBQXNCLElBQXRCO0FBQ0EsY0FBSSxNQUFKLENBQVcsS0FBWCxHQUFtQixJQUFuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksU0FBUyx3QkFBVztBQUN0QixtQkFBaUI7QUFESyxDQUFYLENBQWI7O0FBSUEsT0FBTyxHQUFQLENBQVc7QUFDVCxPQUFLO0FBQ0g7QUFERyxHQURJO0FBSVQsWUFBVTtBQUNSLDZCQURRO0FBRVIsZUFBVztBQUNULGNBQVE7QUFDTixjQUFNLE1BREE7QUFFTjtBQUZNO0FBREMsS0FGSDtBQVFSLFVBQU07QUFSRSxHQUpEO0FBY1QsWUFBVTtBQUNSO0FBRFEsR0FkRDtBQWlCVCxhQUFXO0FBQ1Q7QUFEUztBQWpCRixDQUFYOztBQXNCQSxPQUFPLFFBQVAsQ0FBZ0I7QUFDZCxPQUFLO0FBRFMsQ0FBaEI7O0FBSUEsT0FBTyxLQUFQLGdCQUFrQixNQUFsQjs7QUFFQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9wdWJsaWMvc3R5bGVzaGVldHMvc3R5bGUubGVzcycpO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgUm91dGVyIGZyb20gJ3Z1ZS1yb3V0ZXInO1xuLy8gaW1wb3J0IHsgc3luYyB9IGZyb20gJ3Z1ZXgtcm91dGVyLXN5bmMnO1xuLy8gaW1wb3J0IFZ1ZVJlc291cmNlIGZyb20gJ3Z1ZS1yZXNvdXJjZSc7XG5cbi8vIGltcG9ydCBzdG9yZSBmcm9tICcuL3Z1ZXgvc3RvcmUnO1xuXG5pbXBvcnQgQXBwIGZyb20gJy4vY29tcG9uZW50cy9hcHAudnVlJztcbmltcG9ydCBUYXNrVmlldyBmcm9tICcuL2NvbXBvbmVudHMvdGFzay90YXNrLnZ1ZSc7XG5pbXBvcnQgVGFza0xpc3RWaWV3IGZyb20gJy4vY29tcG9uZW50cy90YXNrL3Rhc2tMaXN0LnZ1ZSc7XG5pbXBvcnQgVXNlckxvZ2luIGZyb20gJy4vY29tcG9uZW50cy91c2VyL2xvZ2luLnZ1ZSc7XG5pbXBvcnQgVXNlclNpZ25VcCBmcm9tICcuL2NvbXBvbmVudHMvdXNlci9zaWdudXAudnVlJztcblxuVnVlLnVzZShSb3V0ZXIpO1xuLy8gVnVlLnVzZShWdWVSZXNvdXJjZSk7XG5WdWUuY29uZmlnLmRldnRvb2xzID0gdHJ1ZTtcblZ1ZS5jb25maWcuZGVidWcgPSB0cnVlO1xuXG4vLyBWdWUuaHR0cC5vcHRpb25zLnJvb3QgPSAnaHR0cDovL3poYW5nbHVuLmRhb2FwcC5pby9hcGknO1xuLy8gVnVlLmh0dHAub3B0aW9ucy5yb290ID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6MTIzNC9hcGknO1xuXG4vLyBWdWUuaHR0cC5pbnRlcmNlcHRvcnMucHVzaCh7XG4vLyAgIHJlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbi8vICAgICBWdWUuaHR0cC5oZWFkZXJzLmNvbW1vblsneC1hY2Nlc3MtdG9rZW4nXSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UudG9rZW47XG4vLyAgICAgcmV0dXJuIHJlcXVlc3Q7XG4vLyAgIH0sXG4vLyAgIHJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuLy8gICAgIHJldHVybiByZXNwb25zZTtcbi8vICAgfSxcbi8vIH0pO1xuXG4vLyByb3V0aW5nXG52YXIgcm91dGVyID0gbmV3IFJvdXRlcih7XG4gIGxpbmtBY3RpdmVDbGFzczogJ3NpZGUtbWVudV9faXRlbS0tYWN0aXZlJyxcbn0pO1xuXG5yb3V0ZXIubWFwKHtcbiAgJy8nOiB7XG4gICAgY29tcG9uZW50OiBBcHAsXG4gIH0sXG4gICcvbGlzdHMnOiB7XG4gICAgY29tcG9uZW50OiBUYXNrVmlldyxcbiAgICBzdWJSb3V0ZXM6IHtcbiAgICAgICcvOmlkJzoge1xuICAgICAgICBuYW1lOiAnbGlzdCcsXG4gICAgICAgIGNvbXBvbmVudDogVGFza0xpc3RWaWV3LFxuICAgICAgfSxcbiAgICB9LFxuICAgIGF1dGg6IHRydWUsXG4gIH0sXG4gICcvbG9naW4nOiB7XG4gICAgY29tcG9uZW50OiBVc2VyTG9naW4sXG4gIH0sXG4gICcvc2lnbnVwJzoge1xuICAgIGNvbXBvbmVudDogVXNlclNpZ25VcCxcbiAgfSxcbn0pO1xuXG5yb3V0ZXIucmVkaXJlY3Qoe1xuICAnKic6ICcvJyxcbn0pO1xuXG5yb3V0ZXIuc3RhcnQoQXBwLCAnI2FwcCcpO1xuXG4vLyBzeW5jKHN0b3JlLCByb3V0ZXIpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc3JjL2luZGV4LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Vue.js v1.0.26\n * (c) 2016 Evan You\n * Released under the MIT License.\n */\n'use strict';\n\nfunction set(obj, key, val) {\n  if (hasOwn(obj, key)) {\n    obj[key] = val;\n    return;\n  }\n  if (obj._isVue) {\n    set(obj._data, key, val);\n    return;\n  }\n  var ob = obj.__ob__;\n  if (!ob) {\n    obj[key] = val;\n    return;\n  }\n  ob.convert(key, val);\n  ob.dep.notify();\n  if (ob.vms) {\n    var i = ob.vms.length;\n    while (i--) {\n      var vm = ob.vms[i];\n      vm._proxy(key);\n      vm._digest();\n    }\n  }\n  return val;\n}\n\n/**\n * Delete a property and trigger change if necessary.\n *\n * @param {Object} obj\n * @param {String} key\n */\n\nfunction del(obj, key) {\n  if (!hasOwn(obj, key)) {\n    return;\n  }\n  delete obj[key];\n  var ob = obj.__ob__;\n  if (!ob) {\n    if (obj._isVue) {\n      delete obj._data[key];\n      obj._digest();\n    }\n    return;\n  }\n  ob.dep.notify();\n  if (ob.vms) {\n    var i = ob.vms.length;\n    while (i--) {\n      var vm = ob.vms[i];\n      vm._unproxy(key);\n      vm._digest();\n    }\n  }\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Check whether the object has the property.\n *\n * @param {Object} obj\n * @param {String} key\n * @return {Boolean}\n */\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\n/**\n * Check if an expression is a literal value.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nvar literalValueRE = /^\\s?(true|false|-?[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\nfunction isLiteral(exp) {\n  return literalValueRE.test(exp);\n}\n\n/**\n * Check if a string starts with $ or _\n *\n * @param {String} str\n * @return {Boolean}\n */\n\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n\n/**\n * Guard text output, make sure undefined outputs\n * empty string\n *\n * @param {*} value\n * @return {String}\n */\n\nfunction _toString(value) {\n  return value == null ? '' : value.toString();\n}\n\n/**\n * Check and convert possible numeric strings to numbers\n * before setting back to data\n *\n * @param {*} value\n * @return {*|Number}\n */\n\nfunction toNumber(value) {\n  if (typeof value !== 'string') {\n    return value;\n  } else {\n    var parsed = Number(value);\n    return isNaN(parsed) ? value : parsed;\n  }\n}\n\n/**\n * Convert string boolean literals into real booleans.\n *\n * @param {*} value\n * @return {*|Boolean}\n */\n\nfunction toBoolean(value) {\n  return value === 'true' ? true : value === 'false' ? false : value;\n}\n\n/**\n * Strip quotes from a string\n *\n * @param {String} str\n * @return {String | false}\n */\n\nfunction stripQuotes(str) {\n  var a = str.charCodeAt(0);\n  var b = str.charCodeAt(str.length - 1);\n  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n}\n\n/**\n * Camelize a hyphen-delmited string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar camelizeRE = /-(\\w)/g;\n\nfunction camelize(str) {\n  return str.replace(camelizeRE, toUpper);\n}\n\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : '';\n}\n\n/**\n * Hyphenate a camelCase string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar hyphenateRE = /([a-z\\d])([A-Z])/g;\n\nfunction hyphenate(str) {\n  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n}\n\n/**\n * Converts hyphen/underscore/slash delimitered names into\n * camelized classNames.\n *\n * e.g. my-component => MyComponent\n *      some_else    => SomeElse\n *      some/comp    => SomeComp\n *\n * @param {String} str\n * @return {String}\n */\n\nvar classifyRE = /(?:^|[-_\\/])(\\w)/g;\n\nfunction classify(str) {\n  return str.replace(classifyRE, toUpper);\n}\n\n/**\n * Simple bind, faster than native\n *\n * @param {Function} fn\n * @param {Object} ctx\n * @return {Function}\n */\n\nfunction bind(fn, ctx) {\n  return function (a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  };\n}\n\n/**\n * Convert an Array-like object to a real Array.\n *\n * @param {Array-like} list\n * @param {Number} [start] - start index\n * @return {Array}\n */\n\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret;\n}\n\n/**\n * Mix properties into target object.\n *\n * @param {Object} to\n * @param {Object} from\n */\n\nfunction extend(to, from) {\n  var keys = Object.keys(from);\n  var i = keys.length;\n  while (i--) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\n\nfunction isPlainObject(obj) {\n  return toString.call(obj) === OBJECT_STRING;\n}\n\n/**\n * Array type check.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar isArray = Array.isArray;\n\n/**\n * Define a property.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @param {Boolean} [enumerable]\n */\n\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Debounce a function so it only gets called after the\n * input stops arriving after the given wait period.\n *\n * @param {Function} func\n * @param {Number} wait\n * @return {Function} - the debounced function\n */\n\nfunction _debounce(func, wait) {\n  var timeout, args, context, timestamp, result;\n  var later = function later() {\n    var last = Date.now() - timestamp;\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    }\n  };\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n    }\n    return result;\n  };\n}\n\n/**\n * Manual indexOf because it's slightly faster than\n * native.\n *\n * @param {Array} arr\n * @param {*} obj\n */\n\nfunction indexOf(arr, obj) {\n  var i = arr.length;\n  while (i--) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n}\n\n/**\n * Make a cancellable version of an async callback.\n *\n * @param {Function} fn\n * @return {Function}\n */\n\nfunction cancellable(fn) {\n  var cb = function cb() {\n    if (!cb.cancelled) {\n      return fn.apply(this, arguments);\n    }\n  };\n  cb.cancel = function () {\n    cb.cancelled = true;\n  };\n  return cb;\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n *\n * @param {*} a\n * @param {*} b\n * @return {Boolean}\n */\n\nfunction looseEqual(a, b) {\n  /* eslint-disable eqeqeq */\n  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);\n  /* eslint-enable eqeqeq */\n}\n\nvar hasProto = ('__proto__' in {});\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n// UA sniffing for working around browser-specific quirks\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && UA.indexOf('trident') > 0;\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);\nvar iosVersionMatch = isIos && UA.match(/os ([\\d_]+)/);\nvar iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');\n\n// detecting iOS UIWebView by indexedDB\nvar hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;\n\nvar transitionProp = undefined;\nvar transitionEndEvent = undefined;\nvar animationProp = undefined;\nvar animationEndEvent = undefined;\n\n// Transition property/event sniffing\nif (inBrowser && !isIE9) {\n  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;\n  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;\n  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';\n  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';\n  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';\n  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';\n}\n\n/**\n * Defer a task to execute it asynchronously. Ideally this\n * should be executed as a microtask, so we leverage\n * MutationObserver if it's available, and fallback to\n * setTimeout(0).\n *\n * @param {Function} cb\n * @param {Object} ctx\n */\n\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n  function nextTickHandler() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks = [];\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  /* istanbul ignore if */\n  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(counter);\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = counter;\n    };\n  } else {\n    // webpack attempts to inject a shim for setImmediate\n    // if it is used as a global, so we have to work around that to\n    // avoid bundling unnecessary code.\n    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\n    timerFunc = context.setImmediate || setTimeout;\n  }\n  return function (cb, ctx) {\n    var func = ctx ? function () {\n      cb.call(ctx);\n    } : cb;\n    callbacks.push(func);\n    if (pending) return;\n    pending = true;\n    timerFunc(nextTickHandler, 0);\n  };\n})();\n\nvar _Set = undefined;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = function () {\n    this.set = Object.create(null);\n  };\n  _Set.prototype.has = function (key) {\n    return this.set[key] !== undefined;\n  };\n  _Set.prototype.add = function (key) {\n    this.set[key] = 1;\n  };\n  _Set.prototype.clear = function () {\n    this.set = Object.create(null);\n  };\n}\n\nfunction Cache(limit) {\n  this.size = 0;\n  this.limit = limit;\n  this.head = this.tail = undefined;\n  this._keymap = Object.create(null);\n}\n\nvar p = Cache.prototype;\n\n/**\n * Put <value> into the cache associated with <key>.\n * Returns the entry which was removed to make room for\n * the new entry. Otherwise undefined is returned.\n * (i.e. if there was enough room already).\n *\n * @param {String} key\n * @param {*} value\n * @return {Entry|undefined}\n */\n\np.put = function (key, value) {\n  var removed;\n\n  var entry = this.get(key, true);\n  if (!entry) {\n    if (this.size === this.limit) {\n      removed = this.shift();\n    }\n    entry = {\n      key: key\n    };\n    this._keymap[key] = entry;\n    if (this.tail) {\n      this.tail.newer = entry;\n      entry.older = this.tail;\n    } else {\n      this.head = entry;\n    }\n    this.tail = entry;\n    this.size++;\n  }\n  entry.value = value;\n\n  return removed;\n};\n\n/**\n * Purge the least recently used (oldest) entry from the\n * cache. Returns the removed entry or undefined if the\n * cache was empty.\n */\n\np.shift = function () {\n  var entry = this.head;\n  if (entry) {\n    this.head = this.head.newer;\n    this.head.older = undefined;\n    entry.newer = entry.older = undefined;\n    this._keymap[entry.key] = undefined;\n    this.size--;\n  }\n  return entry;\n};\n\n/**\n * Get and register recent use of <key>. Returns the value\n * associated with <key> or undefined if not in cache.\n *\n * @param {String} key\n * @param {Boolean} returnEntry\n * @return {Entry|*}\n */\n\np.get = function (key, returnEntry) {\n  var entry = this._keymap[key];\n  if (entry === undefined) return;\n  if (entry === this.tail) {\n    return returnEntry ? entry : entry.value;\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry.newer) {\n    if (entry === this.head) {\n      this.head = entry.newer;\n    }\n    entry.newer.older = entry.older; // C <-- E.\n  }\n  if (entry.older) {\n    entry.older.newer = entry.newer; // C. --> E\n  }\n  entry.newer = undefined; // D --x\n  entry.older = this.tail; // D. --> E\n  if (this.tail) {\n    this.tail.newer = entry; // E. <-- D\n  }\n  this.tail = entry;\n  return returnEntry ? entry : entry.value;\n};\n\nvar cache$1 = new Cache(1000);\nvar filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g;\nvar reservedArgRE = /^in$|^-?\\d+/;\n\n/**\n * Parser state\n */\n\nvar str;\nvar dir;\nvar c;\nvar prev;\nvar i;\nvar l;\nvar lastFilterIndex;\nvar inSingle;\nvar inDouble;\nvar curly;\nvar square;\nvar paren;\n/**\n * Push a filter to the current directive object\n */\n\nfunction pushFilter() {\n  var exp = str.slice(lastFilterIndex, i).trim();\n  var filter;\n  if (exp) {\n    filter = {};\n    var tokens = exp.match(filterTokenRE);\n    filter.name = tokens[0];\n    if (tokens.length > 1) {\n      filter.args = tokens.slice(1).map(processFilterArg);\n    }\n  }\n  if (filter) {\n    (dir.filters = dir.filters || []).push(filter);\n  }\n  lastFilterIndex = i + 1;\n}\n\n/**\n * Check if an argument is dynamic and strip quotes.\n *\n * @param {String} arg\n * @return {Object}\n */\n\nfunction processFilterArg(arg) {\n  if (reservedArgRE.test(arg)) {\n    return {\n      value: toNumber(arg),\n      dynamic: false\n    };\n  } else {\n    var stripped = stripQuotes(arg);\n    var dynamic = stripped === arg;\n    return {\n      value: dynamic ? arg : stripped,\n      dynamic: dynamic\n    };\n  }\n}\n\n/**\n * Parse a directive value and extract the expression\n * and its filters into a descriptor.\n *\n * Example:\n *\n * \"a + 1 | uppercase\" will yield:\n * {\n *   expression: 'a + 1',\n *   filters: [\n *     { name: 'uppercase', args: null }\n *   ]\n * }\n *\n * @param {String} s\n * @return {Object}\n */\n\nfunction parseDirective(s) {\n  var hit = cache$1.get(s);\n  if (hit) {\n    return hit;\n  }\n\n  // reset parser state\n  str = s;\n  inSingle = inDouble = false;\n  curly = square = paren = 0;\n  lastFilterIndex = 0;\n  dir = {};\n\n  for (i = 0, l = str.length; i < l; i++) {\n    prev = c;\n    c = str.charCodeAt(i);\n    if (inSingle) {\n      // check single quote\n      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\n    } else if (inDouble) {\n      // check double quote\n      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\n    } else if (c === 0x7C && // pipe\n    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {\n      if (dir.expression == null) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        dir.expression = str.slice(0, i).trim();\n      } else {\n        // already has filter\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true;break; // \"\n        case 0x27:\n          inSingle = true;break; // '\n        case 0x28:\n          paren++;break; // (\n        case 0x29:\n          paren--;break; // )\n        case 0x5B:\n          square++;break; // [\n        case 0x5D:\n          square--;break; // ]\n        case 0x7B:\n          curly++;break; // {\n        case 0x7D:\n          curly--;break; // }\n      }\n    }\n  }\n\n  if (dir.expression == null) {\n    dir.expression = str.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  cache$1.put(s, dir);\n  return dir;\n}\n\nvar directive = Object.freeze({\n  parseDirective: parseDirective\n});\n\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\nvar cache = undefined;\nvar tagRE = undefined;\nvar htmlRE = undefined;\n/**\n * Escape a string so it can be used in a RegExp\n * constructor.\n *\n * @param {String} str\n */\n\nfunction escapeRegex(str) {\n  return str.replace(regexEscapeRE, '\\\\$&');\n}\n\nfunction compileRegex() {\n  var open = escapeRegex(config.delimiters[0]);\n  var close = escapeRegex(config.delimiters[1]);\n  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);\n  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);\n  tagRE = new RegExp(unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\\\n)+?)' + close, 'g');\n  htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '$');\n  // reset cache\n  cache = new Cache(1000);\n}\n\n/**\n * Parse a template text string into an array of tokens.\n *\n * @param {String} text\n * @return {Array<Object> | null}\n *               - {String} type\n *               - {String} value\n *               - {Boolean} [html]\n *               - {Boolean} [oneTime]\n */\n\nfunction parseText(text) {\n  if (!cache) {\n    compileRegex();\n  }\n  var hit = cache.get(text);\n  if (hit) {\n    return hit;\n  }\n  if (!tagRE.test(text)) {\n    return null;\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, html, value, first, oneTime;\n  /* eslint-disable no-cond-assign */\n  while (match = tagRE.exec(text)) {\n    /* eslint-enable no-cond-assign */\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push({\n        value: text.slice(lastIndex, index)\n      });\n    }\n    // tag token\n    html = htmlRE.test(match[0]);\n    value = html ? match[1] : match[2];\n    first = value.charCodeAt(0);\n    oneTime = first === 42; // *\n    value = oneTime ? value.slice(1) : value;\n    tokens.push({\n      tag: true,\n      value: value.trim(),\n      html: html,\n      oneTime: oneTime\n    });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push({\n      value: text.slice(lastIndex)\n    });\n  }\n  cache.put(text, tokens);\n  return tokens;\n}\n\n/**\n * Format a list of tokens into an expression.\n * e.g. tokens parsed from 'a {{b}} c' can be serialized\n * into one single expression as '\"a \" + b + \" c\"'.\n *\n * @param {Array} tokens\n * @param {Vue} [vm]\n * @return {String}\n */\n\nfunction tokensToExp(tokens, vm) {\n  if (tokens.length > 1) {\n    return tokens.map(function (token) {\n      return formatToken(token, vm);\n    }).join('+');\n  } else {\n    return formatToken(tokens[0], vm, true);\n  }\n}\n\n/**\n * Format a single token.\n *\n * @param {Object} token\n * @param {Vue} [vm]\n * @param {Boolean} [single]\n * @return {String}\n */\n\nfunction formatToken(token, vm, single) {\n  return token.tag ? token.oneTime && vm ? '\"' + vm.$eval(token.value) + '\"' : inlineFilters(token.value, single) : '\"' + token.value + '\"';\n}\n\n/**\n * For an attribute with multiple interpolation tags,\n * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n * the whole thing into a single watchable expression, we\n * have to inline those filters. This function does exactly\n * that. This is a bit hacky but it avoids heavy changes\n * to directive parser and watcher mechanism.\n *\n * @param {String} exp\n * @param {Boolean} single\n * @return {String}\n */\n\nvar filterRE = /[^|]\\|[^|]/;\nfunction inlineFilters(exp, single) {\n  if (!filterRE.test(exp)) {\n    return single ? exp : '(' + exp + ')';\n  } else {\n    var dir = parseDirective(exp);\n    if (!dir.filters) {\n      return '(' + exp + ')';\n    } else {\n      return 'this._applyFilters(' + dir.expression + // value\n      ',null,' + // oldValue (null for read)\n      JSON.stringify(dir.filters) + // filter descriptors\n      ',false)'; // write?\n    }\n  }\n}\n\nvar text = Object.freeze({\n  compileRegex: compileRegex,\n  parseText: parseText,\n  tokensToExp: tokensToExp\n});\n\nvar delimiters = ['{{', '}}'];\nvar unsafeDelimiters = ['{{{', '}}}'];\n\nvar config = Object.defineProperties({\n\n  /**\n   * Whether to print debug messages.\n   * Also enables stack trace for warnings.\n   *\n   * @type {Boolean}\n   */\n\n  debug: false,\n\n  /**\n   * Whether to suppress warnings.\n   *\n   * @type {Boolean}\n   */\n\n  silent: false,\n\n  /**\n   * Whether to use async rendering.\n   */\n\n  async: true,\n\n  /**\n   * Whether to warn against errors caught when evaluating\n   * expressions.\n   */\n\n  warnExpressionErrors: true,\n\n  /**\n   * Whether to allow devtools inspection.\n   * Disabled by default in production builds.\n   */\n\n  devtools: (\"development\") !== 'production',\n\n  /**\n   * Internal flag to indicate the delimiters have been\n   * changed.\n   *\n   * @type {Boolean}\n   */\n\n  _delimitersChanged: true,\n\n  /**\n   * List of asset types that a component can own.\n   *\n   * @type {Array}\n   */\n\n  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],\n\n  /**\n   * prop binding modes\n   */\n\n  _propBindingModes: {\n    ONE_WAY: 0,\n    TWO_WAY: 1,\n    ONE_TIME: 2\n  },\n\n  /**\n   * Max circular updates allowed in a batcher flush cycle.\n   */\n\n  _maxUpdateCount: 100\n\n}, {\n  delimiters: { /**\n                 * Interpolation delimiters. Changing these would trigger\n                 * the text parser to re-compile the regular expressions.\n                 *\n                 * @type {Array<String>}\n                 */\n\n    get: function get() {\n      return delimiters;\n    },\n    set: function set(val) {\n      delimiters = val;\n      compileRegex();\n    },\n    configurable: true,\n    enumerable: true\n  },\n  unsafeDelimiters: {\n    get: function get() {\n      return unsafeDelimiters;\n    },\n    set: function set(val) {\n      unsafeDelimiters = val;\n      compileRegex();\n    },\n    configurable: true,\n    enumerable: true\n  }\n});\n\nvar warn = undefined;\nvar formatComponentName = undefined;\n\nif (true) {\n  (function () {\n    var hasConsole = typeof console !== 'undefined';\n\n    warn = function (msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));\n      }\n    };\n\n    formatComponentName = function (vm) {\n      var name = vm._isVue ? vm.$options.name : vm.name;\n      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';\n    };\n  })();\n}\n\n/**\n * Append with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction appendWithTransition(el, target, vm, cb) {\n  applyTransition(el, 1, function () {\n    target.appendChild(el);\n  }, vm, cb);\n}\n\n/**\n * InsertBefore with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction beforeWithTransition(el, target, vm, cb) {\n  applyTransition(el, 1, function () {\n    before(el, target);\n  }, vm, cb);\n}\n\n/**\n * Remove with transition.\n *\n * @param {Element} el\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction removeWithTransition(el, vm, cb) {\n  applyTransition(el, -1, function () {\n    remove(el);\n  }, vm, cb);\n}\n\n/**\n * Apply transitions with an operation callback.\n *\n * @param {Element} el\n * @param {Number} direction\n *                  1: enter\n *                 -1: leave\n * @param {Function} op - the actual DOM operation\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction applyTransition(el, direction, op, vm, cb) {\n  var transition = el.__v_trans;\n  if (!transition ||\n  // skip if there are no js hooks and CSS transition is\n  // not supported\n  !transition.hooks && !transitionEndEvent ||\n  // skip transitions for initial compile\n  !vm._isCompiled ||\n  // if the vm is being manipulated by a parent directive\n  // during the parent's compilation phase, skip the\n  // animation.\n  vm.$parent && !vm.$parent._isCompiled) {\n    op();\n    if (cb) cb();\n    return;\n  }\n  var action = direction > 0 ? 'enter' : 'leave';\n  transition[action](op, cb);\n}\n\nvar transition = Object.freeze({\n  appendWithTransition: appendWithTransition,\n  beforeWithTransition: beforeWithTransition,\n  removeWithTransition: removeWithTransition,\n  applyTransition: applyTransition\n});\n\n/**\n * Query an element selector if it's not an element already.\n *\n * @param {String|Element} el\n * @return {Element}\n */\n\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selector = el;\n    el = document.querySelector(el);\n    if (!el) {\n      (\"development\") !== 'production' && warn('Cannot find element: ' + selector);\n    }\n  }\n  return el;\n}\n\n/**\n * Check if a node is in the document.\n * Note: document.documentElement.contains should work here\n * but always returns false for comment nodes in phantomjs,\n * making unit tests difficult. This is fixed by doing the\n * contains() check on the node's parentNode instead of\n * the node itself.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction inDoc(node) {\n  if (!node) return false;\n  var doc = node.ownerDocument.documentElement;\n  var parent = node.parentNode;\n  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n}\n\n/**\n * Get and remove an attribute from a node.\n *\n * @param {Node} node\n * @param {String} _attr\n */\n\nfunction getAttr(node, _attr) {\n  var val = node.getAttribute(_attr);\n  if (val !== null) {\n    node.removeAttribute(_attr);\n  }\n  return val;\n}\n\n/**\n * Get an attribute with colon or v-bind: prefix.\n *\n * @param {Node} node\n * @param {String} name\n * @return {String|null}\n */\n\nfunction getBindAttr(node, name) {\n  var val = getAttr(node, ':' + name);\n  if (val === null) {\n    val = getAttr(node, 'v-bind:' + name);\n  }\n  return val;\n}\n\n/**\n * Check the presence of a bind attribute.\n *\n * @param {Node} node\n * @param {String} name\n * @return {Boolean}\n */\n\nfunction hasBindAttr(node, name) {\n  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);\n}\n\n/**\n * Insert el before target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nfunction before(el, target) {\n  target.parentNode.insertBefore(el, target);\n}\n\n/**\n * Insert el after target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nfunction after(el, target) {\n  if (target.nextSibling) {\n    before(el, target.nextSibling);\n  } else {\n    target.parentNode.appendChild(el);\n  }\n}\n\n/**\n * Remove el from DOM\n *\n * @param {Element} el\n */\n\nfunction remove(el) {\n  el.parentNode.removeChild(el);\n}\n\n/**\n * Prepend el to target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nfunction prepend(el, target) {\n  if (target.firstChild) {\n    before(el, target.firstChild);\n  } else {\n    target.appendChild(el);\n  }\n}\n\n/**\n * Replace target with el\n *\n * @param {Element} target\n * @param {Element} el\n */\n\nfunction replace(target, el) {\n  var parent = target.parentNode;\n  if (parent) {\n    parent.replaceChild(el, target);\n  }\n}\n\n/**\n * Add event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n * @param {Boolean} [useCapture]\n */\n\nfunction on(el, event, cb, useCapture) {\n  el.addEventListener(event, cb, useCapture);\n}\n\n/**\n * Remove event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n */\n\nfunction off(el, event, cb) {\n  el.removeEventListener(event, cb);\n}\n\n/**\n * For IE9 compat: when both class and :class are present\n * getAttribute('class') returns wrong value...\n *\n * @param {Element} el\n * @return {String}\n */\n\nfunction getClass(el) {\n  var classname = el.className;\n  if (typeof classname === 'object') {\n    classname = classname.baseVal || '';\n  }\n  return classname;\n}\n\n/**\n * In IE9, setAttribute('class') will result in empty class\n * if the element also has the :class attribute; However in\n * PhantomJS, setting `className` does not work on SVG elements...\n * So we have to do a conditional check here.\n *\n * @param {Element} el\n * @param {String} cls\n */\n\nfunction setClass(el, cls) {\n  /* istanbul ignore if */\n  if (isIE9 && !/svg$/.test(el.namespaceURI)) {\n    el.className = cls;\n  } else {\n    el.setAttribute('class', cls);\n  }\n}\n\n/**\n * Add class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {String} cls\n */\n\nfunction addClass(el, cls) {\n  if (el.classList) {\n    el.classList.add(cls);\n  } else {\n    var cur = ' ' + getClass(el) + ' ';\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      setClass(el, (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {String} cls\n */\n\nfunction removeClass(el, cls) {\n  if (el.classList) {\n    el.classList.remove(cls);\n  } else {\n    var cur = ' ' + getClass(el) + ' ';\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    setClass(el, cur.trim());\n  }\n  if (!el.className) {\n    el.removeAttribute('class');\n  }\n}\n\n/**\n * Extract raw content inside an element into a temporary\n * container div\n *\n * @param {Element} el\n * @param {Boolean} asFragment\n * @return {Element|DocumentFragment}\n */\n\nfunction extractContent(el, asFragment) {\n  var child;\n  var rawContent;\n  /* istanbul ignore if */\n  if (isTemplate(el) && isFragment(el.content)) {\n    el = el.content;\n  }\n  if (el.hasChildNodes()) {\n    trimNode(el);\n    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');\n    /* eslint-disable no-cond-assign */\n    while (child = el.firstChild) {\n      /* eslint-enable no-cond-assign */\n      rawContent.appendChild(child);\n    }\n  }\n  return rawContent;\n}\n\n/**\n * Trim possible empty head/tail text and comment\n * nodes inside a parent.\n *\n * @param {Node} node\n */\n\nfunction trimNode(node) {\n  var child;\n  /* eslint-disable no-sequences */\n  while ((child = node.firstChild, isTrimmable(child))) {\n    node.removeChild(child);\n  }\n  while ((child = node.lastChild, isTrimmable(child))) {\n    node.removeChild(child);\n  }\n  /* eslint-enable no-sequences */\n}\n\nfunction isTrimmable(node) {\n  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);\n}\n\n/**\n * Check if an element is a template tag.\n * Note if the template appears inside an SVG its tagName\n * will be in lowercase.\n *\n * @param {Element} el\n */\n\nfunction isTemplate(el) {\n  return el.tagName && el.tagName.toLowerCase() === 'template';\n}\n\n/**\n * Create an \"anchor\" for performing dom insertion/removals.\n * This is used in a number of scenarios:\n * - fragment instance\n * - v-html\n * - v-if\n * - v-for\n * - component\n *\n * @param {String} content\n * @param {Boolean} persist - IE trashes empty textNodes on\n *                            cloneNode(true), so in certain\n *                            cases the anchor needs to be\n *                            non-empty to be persisted in\n *                            templates.\n * @return {Comment|Text}\n */\n\nfunction createAnchor(content, persist) {\n  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');\n  anchor.__v_anchor = true;\n  return anchor;\n}\n\n/**\n * Find a component ref attribute that starts with $.\n *\n * @param {Element} node\n * @return {String|undefined}\n */\n\nvar refRE = /^v-ref:/;\n\nfunction findRef(node) {\n  if (node.hasAttributes()) {\n    var attrs = node.attributes;\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      var name = attrs[i].name;\n      if (refRE.test(name)) {\n        return camelize(name.replace(refRE, ''));\n      }\n    }\n  }\n}\n\n/**\n * Map a function to a range of nodes .\n *\n * @param {Node} node\n * @param {Node} end\n * @param {Function} op\n */\n\nfunction mapNodeRange(node, end, op) {\n  var next;\n  while (node !== end) {\n    next = node.nextSibling;\n    op(node);\n    node = next;\n  }\n  op(end);\n}\n\n/**\n * Remove a range of nodes with transition, store\n * the nodes in a fragment with correct ordering,\n * and call callback when done.\n *\n * @param {Node} start\n * @param {Node} end\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Function} cb\n */\n\nfunction removeNodeRange(start, end, vm, frag, cb) {\n  var done = false;\n  var removed = 0;\n  var nodes = [];\n  mapNodeRange(start, end, function (node) {\n    if (node === end) done = true;\n    nodes.push(node);\n    removeWithTransition(node, vm, onRemoved);\n  });\n  function onRemoved() {\n    removed++;\n    if (done && removed >= nodes.length) {\n      for (var i = 0; i < nodes.length; i++) {\n        frag.appendChild(nodes[i]);\n      }\n      cb && cb();\n    }\n  }\n}\n\n/**\n * Check if a node is a DocumentFragment.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction isFragment(node) {\n  return node && node.nodeType === 11;\n}\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n *\n * @param {Element} el\n * @return {String}\n */\n\nfunction getOuterHTML(el) {\n  if (el.outerHTML) {\n    return el.outerHTML;\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML;\n  }\n}\n\nvar commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;\nvar reservedTagRE = /^(slot|partial|component)$/i;\n\nvar isUnknownElement = undefined;\nif (true) {\n  isUnknownElement = function (el, tag) {\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return (/HTMLUnknownElement/.test(el.toString()) &&\n        // Chrome returns unknown for several HTML5 elements.\n        // https://code.google.com/p/chromium/issues/detail?id=540526\n        // Firefox returns unknown for some \"Interactive elements.\"\n        !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)\n      );\n    }\n  };\n}\n\n/**\n * Check if an element is a component, if yes return its\n * component id.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Object|undefined}\n */\n\nfunction checkComponentAttr(el, options) {\n  var tag = el.tagName.toLowerCase();\n  var hasAttrs = el.hasAttributes();\n  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {\n    if (resolveAsset(options, 'components', tag)) {\n      return { id: tag };\n    } else {\n      var is = hasAttrs && getIsBinding(el, options);\n      if (is) {\n        return is;\n      } else if (true) {\n        var expectedTag = options._componentNameMap && options._componentNameMap[tag];\n        if (expectedTag) {\n          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');\n        } else if (isUnknownElement(el, tag)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.');\n        }\n      }\n    }\n  } else if (hasAttrs) {\n    return getIsBinding(el, options);\n  }\n}\n\n/**\n * Get \"is\" binding from an element.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Object|undefined}\n */\n\nfunction getIsBinding(el, options) {\n  // dynamic syntax\n  var exp = el.getAttribute('is');\n  if (exp != null) {\n    if (resolveAsset(options, 'components', exp)) {\n      el.removeAttribute('is');\n      return { id: exp };\n    }\n  } else {\n    exp = getBindAttr(el, 'is');\n    if (exp != null) {\n      return { id: exp, dynamic: true };\n    }\n  }\n}\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n *\n * All strategy functions follow the same signature:\n *\n * @param {*} parentVal\n * @param {*} childVal\n * @param {Vue} [vm]\n */\n\nvar strats = config.optionMergeStrategies = Object.create(null);\n\n/**\n * Helper that recursively merges two data objects together.\n */\n\nfunction mergeData(to, from) {\n  var key, toVal, fromVal;\n  for (key in from) {\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isObject(toVal) && isObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to;\n}\n\n/**\n * Data\n */\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n    if (typeof childVal !== 'function') {\n      (\"development\") !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n      return parentVal;\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn() {\n      return mergeData(childVal.call(this), parentVal.call(this));\n    };\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n};\n\n/**\n * El\n */\n\nstrats.el = function (parentVal, childVal, vm) {\n  if (!vm && childVal && typeof childVal !== 'function') {\n    (\"development\") !== 'production' && warn('The \"el\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n    return;\n  }\n  var ret = childVal || parentVal;\n  // invoke the element factory if this is instance merge\n  return vm && typeof ret === 'function' ? ret.call(vm) : ret;\n};\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\n\nstrats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {\n  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\n};\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\n\nfunction mergeAssets(parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal ? extend(res, guardArrayAssets(childVal)) : res;\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Events & Watchers.\n *\n * Events & watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\n\nstrats.watch = strats.events = function (parentVal, childVal) {\n  if (!childVal) return parentVal;\n  if (!parentVal) return childVal;\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent ? parent.concat(child) : [child];\n  }\n  return ret;\n};\n\n/**\n * Other object hashes.\n */\n\nstrats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n  if (!childVal) return parentVal;\n  if (!parentVal) return childVal;\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret;\n};\n\n/**\n * Default strategy.\n */\n\nvar defaultStrat = function defaultStrat(parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n\n/**\n * Make sure component options get converted to actual\n * constructors.\n *\n * @param {Object} options\n */\n\nfunction guardComponents(options) {\n  if (options.components) {\n    var components = options.components = guardArrayAssets(options.components);\n    var ids = Object.keys(components);\n    var def;\n    if (true) {\n      var map = options._componentNameMap = {};\n    }\n    for (var i = 0, l = ids.length; i < l; i++) {\n      var key = ids[i];\n      if (commonTagRE.test(key) || reservedTagRE.test(key)) {\n        (\"development\") !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n        continue;\n      }\n      // record a all lowercase <-> kebab-case mapping for\n      // possible custom element case error warning\n      if (true) {\n        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);\n      }\n      def = components[key];\n      if (isPlainObject(def)) {\n        components[key] = Vue.extend(def);\n      }\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n *\n * @param {Object} options\n */\n\nfunction guardProps(options) {\n  var props = options.props;\n  var i, val;\n  if (isArray(props)) {\n    options.props = {};\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        options.props[val] = null;\n      } else if (val.name) {\n        options.props[val.name] = val;\n      }\n    }\n  } else if (isPlainObject(props)) {\n    var keys = Object.keys(props);\n    i = keys.length;\n    while (i--) {\n      val = props[keys[i]];\n      if (typeof val === 'function') {\n        props[keys[i]] = { type: val };\n      }\n    }\n  }\n}\n\n/**\n * Guard an Array-format assets option and converted it\n * into the key-value Object format.\n *\n * @param {Object|Array} assets\n * @return {Object}\n */\n\nfunction guardArrayAssets(assets) {\n  if (isArray(assets)) {\n    var res = {};\n    var i = assets.length;\n    var asset;\n    while (i--) {\n      asset = assets[i];\n      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;\n      if (!id) {\n        (\"development\") !== 'production' && warn('Array-syntax assets must provide a \"name\" or \"id\" field.');\n      } else {\n        res[id] = asset;\n      }\n    }\n    return res;\n  }\n  return assets;\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n *\n * @param {Object} parent\n * @param {Object} child\n * @param {Vue} [vm] - if vm is present, indicates this is\n *                     an instantiation merge.\n */\n\nfunction mergeOptions(parent, child, vm) {\n  guardComponents(child);\n  guardProps(child);\n  if (true) {\n    if (child.propsData && !vm) {\n      warn('propsData can only be used as an instantiation option.');\n    }\n  }\n  var options = {};\n  var key;\n  if (child['extends']) {\n    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;\n      parent = mergeOptions(parent, mixinOptions, vm);\n    }\n  }\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options;\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n *\n * @param {Object} options\n * @param {String} type\n * @param {String} id\n * @param {Boolean} warnMissing\n * @return {Object|Function}\n */\n\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n  var assets = options[type];\n  var camelizedId;\n  var res = assets[id] ||\n  // camelCase ID\n  assets[camelizedId = camelize(id)] ||\n  // Pascal Case ID\n  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];\n  if ((\"development\") !== 'production' && warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n  }\n  return res;\n}\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * @constructor\n */\nfunction Dep() {\n  this.id = uid$1++;\n  this.subs = [];\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.addSub = function (sub) {\n  this.subs.push(sub);\n};\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.removeSub = function (sub) {\n  this.subs.$remove(sub);\n};\n\n/**\n * Add self as a dependency to the target watcher.\n */\n\nDep.prototype.depend = function () {\n  Dep.target.addDep(this);\n};\n\n/**\n * Notify all subscribers of a new value.\n */\n\nDep.prototype.notify = function () {\n  // stablize the subscriber list first\n  var subs = toArray(this.subs);\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto)\n\n/**\n * Intercept mutating methods and emit events\n */\n\n;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break;\n      case 'unshift':\n        inserted = args;\n        break;\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n    if (inserted) ob.observeArray(inserted);\n    // notify change\n    ob.dep.notify();\n    return result;\n  });\n});\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} val\n * @return {*} - replaced element\n */\n\ndef(arrayProto, '$set', function $set(index, val) {\n  if (index >= this.length) {\n    this.length = Number(index) + 1;\n  }\n  return this.splice(index, 1, val)[0];\n});\n\n/**\n * Convenience method to remove the element at given index or target element reference.\n *\n * @param {*} item\n */\n\ndef(arrayProto, '$remove', function $remove(item) {\n  /* istanbul ignore if */\n  if (!this.length) return;\n  var index = indexOf(this, item);\n  if (index > -1) {\n    return this.splice(index, 1);\n  }\n});\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However in certain cases, e.g.\n * v-for scope alias and props, we don't want to force conversion\n * because the value may be a nested value under a frozen data structure.\n *\n * So whenever we want to set a reactive property without forcing\n * conversion on the new value, we wrap that call inside this function.\n */\n\nvar shouldConvert = true;\n\nfunction withoutConversion(fn) {\n  shouldConvert = false;\n  fn();\n  shouldConvert = true;\n}\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nfunction Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  def(value, '__ob__', this);\n  if (isArray(value)) {\n    var augment = hasProto ? protoAugment : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n}\n\n// Instance methods\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    this.convert(keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val);\n};\n\n/**\n * Add an owner vm, so that when $set/$delete mutations\n * happen we can notify owner vms to proxy the keys and\n * digest the watchers. This is only called when the object\n * is observed as an instance's root $data.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.addVm = function (vm) {\n  (this.vms || (this.vms = [])).push(vm);\n};\n\n/**\n * Remove an owner vm. This is called when the object is\n * swapped out as an instance's $data object.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.removeVm = function (vm) {\n  this.vms.$remove(vm);\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n *\n * @param {Object|Array} target\n * @param {Object} src\n */\n\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @param {Vue} [vm]\n * @return {Observer|undefined}\n * @static\n */\n\nfunction observe(value, vm) {\n  if (!value || typeof value !== 'object') {\n    return;\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n  if (ob && vm) {\n    ob.addVm(vm);\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nfunction defineReactive(obj, key, val) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (isArray(value)) {\n          for (var e, i = 0, l = value.length; i < l; i++) {\n            e = value[i];\n            e && e.__ob__ && e.__ob__.dep.depend();\n          }\n        }\n      }\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      if (newVal === value) {\n        return;\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n\n\nvar util = Object.freeze({\n\tdefineReactive: defineReactive,\n\tset: set,\n\tdel: del,\n\thasOwn: hasOwn,\n\tisLiteral: isLiteral,\n\tisReserved: isReserved,\n\t_toString: _toString,\n\ttoNumber: toNumber,\n\ttoBoolean: toBoolean,\n\tstripQuotes: stripQuotes,\n\tcamelize: camelize,\n\thyphenate: hyphenate,\n\tclassify: classify,\n\tbind: bind,\n\ttoArray: toArray,\n\textend: extend,\n\tisObject: isObject,\n\tisPlainObject: isPlainObject,\n\tdef: def,\n\tdebounce: _debounce,\n\tindexOf: indexOf,\n\tcancellable: cancellable,\n\tlooseEqual: looseEqual,\n\tisArray: isArray,\n\thasProto: hasProto,\n\tinBrowser: inBrowser,\n\tdevtools: devtools,\n\tisIE: isIE,\n\tisIE9: isIE9,\n\tisAndroid: isAndroid,\n\tisIos: isIos,\n\tiosVersionMatch: iosVersionMatch,\n\tiosVersion: iosVersion,\n\thasMutationObserverBug: hasMutationObserverBug,\n\tget transitionProp () { return transitionProp; },\n\tget transitionEndEvent () { return transitionEndEvent; },\n\tget animationProp () { return animationProp; },\n\tget animationEndEvent () { return animationEndEvent; },\n\tnextTick: nextTick,\n\tget _Set () { return _Set; },\n\tquery: query,\n\tinDoc: inDoc,\n\tgetAttr: getAttr,\n\tgetBindAttr: getBindAttr,\n\thasBindAttr: hasBindAttr,\n\tbefore: before,\n\tafter: after,\n\tremove: remove,\n\tprepend: prepend,\n\treplace: replace,\n\ton: on,\n\toff: off,\n\tsetClass: setClass,\n\taddClass: addClass,\n\tremoveClass: removeClass,\n\textractContent: extractContent,\n\ttrimNode: trimNode,\n\tisTemplate: isTemplate,\n\tcreateAnchor: createAnchor,\n\tfindRef: findRef,\n\tmapNodeRange: mapNodeRange,\n\tremoveNodeRange: removeNodeRange,\n\tisFragment: isFragment,\n\tgetOuterHTML: getOuterHTML,\n\tmergeOptions: mergeOptions,\n\tresolveAsset: resolveAsset,\n\tcheckComponentAttr: checkComponentAttr,\n\tcommonTagRE: commonTagRE,\n\treservedTagRE: reservedTagRE,\n\tget warn () { return warn; }\n});\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  /**\n   * The main init sequence. This is called for every\n   * instance, including ones that are created from extended\n   * constructors.\n   *\n   * @param {Object} options - this options object should be\n   *                           the result of merging class\n   *                           options and the options passed\n   *                           in to the constructor.\n   */\n\n  Vue.prototype._init = function (options) {\n    options = options || {};\n\n    this.$el = null;\n    this.$parent = options.parent;\n    this.$root = this.$parent ? this.$parent.$root : this;\n    this.$children = [];\n    this.$refs = {}; // child vm references\n    this.$els = {}; // element references\n    this._watchers = []; // all watchers as an array\n    this._directives = []; // all directives\n\n    // a uid\n    this._uid = uid++;\n\n    // a flag to avoid this being observed\n    this._isVue = true;\n\n    // events bookkeeping\n    this._events = {}; // registered callbacks\n    this._eventsCount = {}; // for $broadcast optimization\n\n    // fragment instance properties\n    this._isFragment = false;\n    this._fragment = // @type {DocumentFragment}\n    this._fragmentStart = // @type {Text|Comment}\n    this._fragmentEnd = null; // @type {Text|Comment}\n\n    // lifecycle state\n    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;\n    this._unlinkFn = null;\n\n    // context:\n    // if this is a transcluded component, context\n    // will be the common parent vm of this instance\n    // and its host.\n    this._context = options._context || this.$parent;\n\n    // scope:\n    // if this is inside an inline v-for, the scope\n    // will be the intermediate scope created for this\n    // repeat fragment. this is used for linking props\n    // and container directives.\n    this._scope = options._scope;\n\n    // fragment:\n    // if this instance is compiled inside a Fragment, it\n    // needs to reigster itself as a child of that fragment\n    // for attach/detach to work properly.\n    this._frag = options._frag;\n    if (this._frag) {\n      this._frag.children.push(this);\n    }\n\n    // push self into parent / transclusion host\n    if (this.$parent) {\n      this.$parent.$children.push(this);\n    }\n\n    // merge options.\n    options = this.$options = mergeOptions(this.constructor.options, options, this);\n\n    // set ref\n    this._updateRef();\n\n    // initialize data as empty object.\n    // it will be filled up in _initData().\n    this._data = {};\n\n    // call init hook\n    this._callHook('init');\n\n    // initialize data observation and scope inheritance.\n    this._initState();\n\n    // setup event system and option events.\n    this._initEvents();\n\n    // call created hook\n    this._callHook('created');\n\n    // if `el` option is passed, start compilation.\n    if (options.el) {\n      this.$mount(options.el);\n    }\n  };\n}\n\nvar pathCache = new Cache(1000);\n\n// actions\nvar APPEND = 0;\nvar PUSH = 1;\nvar INC_SUB_PATH_DEPTH = 2;\nvar PUSH_SUB_PATH = 3;\n\n// states\nvar BEFORE_PATH = 0;\nvar IN_PATH = 1;\nvar BEFORE_IDENT = 2;\nvar IN_IDENT = 3;\nvar IN_SUB_PATH = 4;\nvar IN_SINGLE_QUOTE = 5;\nvar IN_DOUBLE_QUOTE = 6;\nvar AFTER_PATH = 7;\nvar ERROR = 8;\n\nvar pathStateMachine = [];\n\npathStateMachine[BEFORE_PATH] = {\n  'ws': [BEFORE_PATH],\n  'ident': [IN_IDENT, APPEND],\n  '[': [IN_SUB_PATH],\n  'eof': [AFTER_PATH]\n};\n\npathStateMachine[IN_PATH] = {\n  'ws': [IN_PATH],\n  '.': [BEFORE_IDENT],\n  '[': [IN_SUB_PATH],\n  'eof': [AFTER_PATH]\n};\n\npathStateMachine[BEFORE_IDENT] = {\n  'ws': [BEFORE_IDENT],\n  'ident': [IN_IDENT, APPEND]\n};\n\npathStateMachine[IN_IDENT] = {\n  'ident': [IN_IDENT, APPEND],\n  '0': [IN_IDENT, APPEND],\n  'number': [IN_IDENT, APPEND],\n  'ws': [IN_PATH, PUSH],\n  '.': [BEFORE_IDENT, PUSH],\n  '[': [IN_SUB_PATH, PUSH],\n  'eof': [AFTER_PATH, PUSH]\n};\n\npathStateMachine[IN_SUB_PATH] = {\n  \"'\": [IN_SINGLE_QUOTE, APPEND],\n  '\"': [IN_DOUBLE_QUOTE, APPEND],\n  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\n  ']': [IN_PATH, PUSH_SUB_PATH],\n  'eof': ERROR,\n  'else': [IN_SUB_PATH, APPEND]\n};\n\npathStateMachine[IN_SINGLE_QUOTE] = {\n  \"'\": [IN_SUB_PATH, APPEND],\n  'eof': ERROR,\n  'else': [IN_SINGLE_QUOTE, APPEND]\n};\n\npathStateMachine[IN_DOUBLE_QUOTE] = {\n  '\"': [IN_SUB_PATH, APPEND],\n  'eof': ERROR,\n  'else': [IN_DOUBLE_QUOTE, APPEND]\n};\n\n/**\n * Determine the type of a character in a keypath.\n *\n * @param {Char} ch\n * @return {String} type\n */\n\nfunction getPathCharType(ch) {\n  if (ch === undefined) {\n    return 'eof';\n  }\n\n  var code = ch.charCodeAt(0);\n\n  switch (code) {\n    case 0x5B: // [\n    case 0x5D: // ]\n    case 0x2E: // .\n    case 0x22: // \"\n    case 0x27: // '\n    case 0x30:\n      // 0\n      return ch;\n\n    case 0x5F: // _\n    case 0x24:\n      // $\n      return 'ident';\n\n    case 0x20: // Space\n    case 0x09: // Tab\n    case 0x0A: // Newline\n    case 0x0D: // Return\n    case 0xA0: // No-break space\n    case 0xFEFF: // Byte Order Mark\n    case 0x2028: // Line Separator\n    case 0x2029:\n      // Paragraph Separator\n      return 'ws';\n  }\n\n  // a-z, A-Z\n  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {\n    return 'ident';\n  }\n\n  // 1-9\n  if (code >= 0x31 && code <= 0x39) {\n    return 'number';\n  }\n\n  return 'else';\n}\n\n/**\n * Format a subPath, return its plain form if it is\n * a literal string or number. Otherwise prepend the\n * dynamic indicator (*).\n *\n * @param {String} path\n * @return {String}\n */\n\nfunction formatSubPath(path) {\n  var trimmed = path.trim();\n  // invalid leading 0\n  if (path.charAt(0) === '0' && isNaN(path)) {\n    return false;\n  }\n  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;\n}\n\n/**\n * Parse a string path into an array of segments\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nfunction parse(path) {\n  var keys = [];\n  var index = -1;\n  var mode = BEFORE_PATH;\n  var subPathDepth = 0;\n  var c, newChar, key, type, transition, action, typeMap;\n\n  var actions = [];\n\n  actions[PUSH] = function () {\n    if (key !== undefined) {\n      keys.push(key);\n      key = undefined;\n    }\n  };\n\n  actions[APPEND] = function () {\n    if (key === undefined) {\n      key = newChar;\n    } else {\n      key += newChar;\n    }\n  };\n\n  actions[INC_SUB_PATH_DEPTH] = function () {\n    actions[APPEND]();\n    subPathDepth++;\n  };\n\n  actions[PUSH_SUB_PATH] = function () {\n    if (subPathDepth > 0) {\n      subPathDepth--;\n      mode = IN_SUB_PATH;\n      actions[APPEND]();\n    } else {\n      subPathDepth = 0;\n      key = formatSubPath(key);\n      if (key === false) {\n        return false;\n      } else {\n        actions[PUSH]();\n      }\n    }\n  };\n\n  function maybeUnescapeQuote() {\n    var nextChar = path[index + 1];\n    if (mode === IN_SINGLE_QUOTE && nextChar === \"'\" || mode === IN_DOUBLE_QUOTE && nextChar === '\"') {\n      index++;\n      newChar = '\\\\' + nextChar;\n      actions[APPEND]();\n      return true;\n    }\n  }\n\n  while (mode != null) {\n    index++;\n    c = path[index];\n\n    if (c === '\\\\' && maybeUnescapeQuote()) {\n      continue;\n    }\n\n    type = getPathCharType(c);\n    typeMap = pathStateMachine[mode];\n    transition = typeMap[type] || typeMap['else'] || ERROR;\n\n    if (transition === ERROR) {\n      return; // parse error\n    }\n\n    mode = transition[0];\n    action = actions[transition[1]];\n    if (action) {\n      newChar = transition[2];\n      newChar = newChar === undefined ? c : newChar;\n      if (action() === false) {\n        return;\n      }\n    }\n\n    if (mode === AFTER_PATH) {\n      keys.raw = path;\n      return keys;\n    }\n  }\n}\n\n/**\n * External parse that check for a cache hit first\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nfunction parsePath(path) {\n  var hit = pathCache.get(path);\n  if (!hit) {\n    hit = parse(path);\n    if (hit) {\n      pathCache.put(path, hit);\n    }\n  }\n  return hit;\n}\n\n/**\n * Get from an object from a path string\n *\n * @param {Object} obj\n * @param {String} path\n */\n\nfunction getPath(obj, path) {\n  return parseExpression(path).get(obj);\n}\n\n/**\n * Warn against setting non-existent root path on a vm.\n */\n\nvar warnNonExistent;\nif (true) {\n  warnNonExistent = function (path, vm) {\n    warn('You are setting a non-existent path \"' + path.raw + '\" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the \"data\" option for more reliable reactivity ' + 'and better performance.', vm);\n  };\n}\n\n/**\n * Set on an object from a path\n *\n * @param {Object} obj\n * @param {String | Array} path\n * @param {*} val\n */\n\nfunction setPath(obj, path, val) {\n  var original = obj;\n  if (typeof path === 'string') {\n    path = parse(path);\n  }\n  if (!path || !isObject(obj)) {\n    return false;\n  }\n  var last, key;\n  for (var i = 0, l = path.length; i < l; i++) {\n    last = obj;\n    key = path[i];\n    if (key.charAt(0) === '*') {\n      key = parseExpression(key.slice(1)).get.call(original, original);\n    }\n    if (i < l - 1) {\n      obj = obj[key];\n      if (!isObject(obj)) {\n        obj = {};\n        if ((\"development\") !== 'production' && last._isVue) {\n          warnNonExistent(path, last);\n        }\n        set(last, key, obj);\n      }\n    } else {\n      if (isArray(obj)) {\n        obj.$set(key, val);\n      } else if (key in obj) {\n        obj[key] = val;\n      } else {\n        if ((\"development\") !== 'production' && obj._isVue) {\n          warnNonExistent(path, obj);\n        }\n        set(obj, key, val);\n      }\n    }\n  }\n  return true;\n}\n\nvar path = Object.freeze({\n  parsePath: parsePath,\n  getPath: getPath,\n  setPath: setPath\n});\n\nvar expressionCache = new Cache(1000);\n\nvar allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';\nvar allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\n// keywords that don't make sense inside expressions\nvar improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';\nvar improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\nvar wsRE = /\\s/g;\nvar newlineRE = /\\n/g;\nvar saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`)|new |typeof |void /g;\nvar restoreRE = /\"(\\d+)\"/g;\nvar pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\nvar identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\nvar literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;\n\nfunction noop() {}\n\n/**\n * Save / Rewrite / Restore\n *\n * When rewriting paths found in an expression, it is\n * possible for the same letter sequences to be found in\n * strings and Object literal property keys. Therefore we\n * remove and store these parts in a temporary array, and\n * restore them after the path rewrite.\n */\n\nvar saved = [];\n\n/**\n * Save replacer\n *\n * The save regex can match two possible cases:\n * 1. An opening object literal\n * 2. A string\n * If matched as a plain string, we need to escape its\n * newlines, since the string needs to be preserved when\n * generating the function body.\n *\n * @param {String} str\n * @param {String} isString - str if matched as a string\n * @return {String} - placeholder with index\n */\n\nfunction save(str, isString) {\n  var i = saved.length;\n  saved[i] = isString ? str.replace(newlineRE, '\\\\n') : str;\n  return '\"' + i + '\"';\n}\n\n/**\n * Path rewrite replacer\n *\n * @param {String} raw\n * @return {String}\n */\n\nfunction rewrite(raw) {\n  var c = raw.charAt(0);\n  var path = raw.slice(1);\n  if (allowedKeywordsRE.test(path)) {\n    return raw;\n  } else {\n    path = path.indexOf('\"') > -1 ? path.replace(restoreRE, restore) : path;\n    return c + 'scope.' + path;\n  }\n}\n\n/**\n * Restore replacer\n *\n * @param {String} str\n * @param {String} i - matched save index\n * @return {String}\n */\n\nfunction restore(str, i) {\n  return saved[i];\n}\n\n/**\n * Rewrite an expression, prefixing all path accessors with\n * `scope.` and generate getter/setter functions.\n *\n * @param {String} exp\n * @return {Function}\n */\n\nfunction compileGetter(exp) {\n  if (improperKeywordsRE.test(exp)) {\n    (\"development\") !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);\n  }\n  // reset state\n  saved.length = 0;\n  // save strings and object literal keys\n  var body = exp.replace(saveRE, save).replace(wsRE, '');\n  // rewrite all paths\n  // pad 1 space here because the regex matches 1 extra char\n  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);\n  return makeGetterFn(body);\n}\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetterFn(body) {\n  try {\n    /* eslint-disable no-new-func */\n    return new Function('scope', 'return ' + body + ';');\n    /* eslint-enable no-new-func */\n  } catch (e) {\n    if (true) {\n      /* istanbul ignore if */\n      if (e.toString().match(/unsafe-eval|CSP/)) {\n        warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');\n      } else {\n        warn('Invalid expression. ' + 'Generated function body: ' + body);\n      }\n    }\n    return noop;\n  }\n}\n\n/**\n * Compile a setter function for the expression.\n *\n * @param {String} exp\n * @return {Function|undefined}\n */\n\nfunction compileSetter(exp) {\n  var path = parsePath(exp);\n  if (path) {\n    return function (scope, val) {\n      setPath(scope, path, val);\n    };\n  } else {\n    (\"development\") !== 'production' && warn('Invalid setter expression: ' + exp);\n  }\n}\n\n/**\n * Parse an expression into re-written getter/setters.\n *\n * @param {String} exp\n * @param {Boolean} needSet\n * @return {Function}\n */\n\nfunction parseExpression(exp, needSet) {\n  exp = exp.trim();\n  // try cache\n  var hit = expressionCache.get(exp);\n  if (hit) {\n    if (needSet && !hit.set) {\n      hit.set = compileSetter(hit.exp);\n    }\n    return hit;\n  }\n  var res = { exp: exp };\n  res.get = isSimplePath(exp) && exp.indexOf('[') < 0\n  // optimized super simple getter\n  ? makeGetterFn('scope.' + exp)\n  // dynamic getter\n  : compileGetter(exp);\n  if (needSet) {\n    res.set = compileSetter(exp);\n  }\n  expressionCache.put(exp, res);\n  return res;\n}\n\n/**\n * Check if an expression is a simple path.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nfunction isSimplePath(exp) {\n  return pathTestRE.test(exp) &&\n  // don't treat literal values as paths\n  !literalValueRE$1.test(exp) &&\n  // Math constants e.g. Math.PI, Math.E etc.\n  exp.slice(0, 5) !== 'Math.';\n}\n\nvar expression = Object.freeze({\n  parseExpression: parseExpression,\n  isSimplePath: isSimplePath\n});\n\n// we have two separate queues: one for directive updates\n// and one for user watcher registered via $watch().\n// we want to guarantee directive updates to be called\n// before user watchers so that when user watchers are\n// triggered, the DOM would have already been in updated\n// state.\n\nvar queue = [];\nvar userQueue = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState() {\n  queue.length = 0;\n  userQueue.length = 0;\n  has = {};\n  circular = {};\n  waiting = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\n\nfunction flushBatcherQueue() {\n  var _again = true;\n\n  _function: while (_again) {\n    _again = false;\n\n    runBatcherQueue(queue);\n    runBatcherQueue(userQueue);\n    // user watchers triggered more watchers,\n    // keep flushing until it depletes\n    if (queue.length) {\n      _again = true;\n      continue _function;\n    }\n    // dev tool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n    resetBatcherState();\n  }\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue(queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (var i = 0; i < queue.length; i++) {\n    var watcher = queue[i];\n    var id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if ((\"development\") !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn('You may have an infinite update loop for watcher ' + 'with expression \"' + watcher.expression + '\"', watcher.vm);\n        break;\n      }\n    }\n  }\n  queue.length = 0;\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nfunction pushWatcher(watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    // push watcher into appropriate queue\n    var q = watcher.user ? userQueue : queue;\n    has[id] = q.length;\n    q.push(watcher);\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushBatcherQueue);\n    }\n  }\n}\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n *\n * @param {Vue} vm\n * @param {String|Function} expOrFn\n * @param {Function} cb\n * @param {Object} options\n *                 - {Array} filters\n *                 - {Boolean} twoWay\n *                 - {Boolean} deep\n *                 - {Boolean} user\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n *                 - {Function} [preProcess]\n *                 - {Function} [postProcess]\n * @constructor\n */\nfunction Watcher(vm, expOrFn, cb, options) {\n  // mix in options\n  if (options) {\n    extend(this, options);\n  }\n  var isFn = typeof expOrFn === 'function';\n  this.vm = vm;\n  vm._watchers.push(this);\n  this.expression = expOrFn;\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.prevError = null; // for async error stacks\n  // parse expression for getter/setter\n  if (isFn) {\n    this.getter = expOrFn;\n    this.setter = undefined;\n  } else {\n    var res = parseExpression(expOrFn, this.twoWay);\n    this.getter = res.get;\n    this.setter = res.set;\n  }\n  this.value = this.lazy ? undefined : this.get();\n  // state for avoiding false triggers for deep and Array\n  // watchers during vm._digest()\n  this.queued = this.shallow = false;\n}\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\nWatcher.prototype.get = function () {\n  this.beforeGet();\n  var scope = this.scope || this.vm;\n  var value;\n  try {\n    value = this.getter.call(scope, scope);\n  } catch (e) {\n    if ((\"development\") !== 'production' && config.warnExpressionErrors) {\n      warn('Error when evaluating expression ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n    }\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  if (this.preProcess) {\n    value = this.preProcess(value);\n  }\n  if (this.filters) {\n    value = scope._applyFilters(value, null, this.filters, false);\n  }\n  if (this.postProcess) {\n    value = this.postProcess(value);\n  }\n  this.afterGet();\n  return value;\n};\n\n/**\n * Set the corresponding value with the setter.\n *\n * @param {*} value\n */\n\nWatcher.prototype.set = function (value) {\n  var scope = this.scope || this.vm;\n  if (this.filters) {\n    value = scope._applyFilters(value, this.value, this.filters, true);\n  }\n  try {\n    this.setter.call(scope, scope, value);\n  } catch (e) {\n    if ((\"development\") !== 'production' && config.warnExpressionErrors) {\n      warn('Error when evaluating setter ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n    }\n  }\n  // two-way sync for v-for alias\n  var forContext = scope.$forContext;\n  if (forContext && forContext.alias === this.expression) {\n    if (forContext.filters) {\n      (\"development\") !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);\n      return;\n    }\n    forContext._withLock(function () {\n      if (scope.$key) {\n        // original is an object\n        forContext.rawValue[scope.$key] = value;\n      } else {\n        forContext.rawValue.$set(scope.$index, value);\n      }\n    });\n  }\n};\n\n/**\n * Prepare for dependency collection.\n */\n\nWatcher.prototype.beforeGet = function () {\n  Dep.target = this;\n};\n\n/**\n * Add a dependency to this directive.\n *\n * @param {Dep} dep\n */\n\nWatcher.prototype.addDep = function (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\n\nWatcher.prototype.afterGet = function () {\n  Dep.target = null;\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n *\n * @param {Boolean} shallow\n */\n\nWatcher.prototype.update = function (shallow) {\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync || !config.async) {\n    this.run();\n  } else {\n    // if queued, only overwrite shallow with non-shallow,\n    // but not the other way around.\n    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;\n    this.queued = true;\n    // record before-push error stack in debug mode\n    /* istanbul ignore if */\n    if ((\"development\") !== 'production' && config.debug) {\n      this.prevError = new Error('[vue] async stack trace');\n    }\n    pushWatcher(this);\n  }\n};\n\n/**\n * Batcher job interface.\n * Will be called by the batcher.\n */\n\nWatcher.prototype.run = function () {\n  if (this.active) {\n    var value = this.get();\n    if (value !== this.value ||\n    // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated; but only do so if this is a\n    // non-shallow update (caused by a vm digest).\n    (isObject(value) || this.deep) && !this.shallow) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      // in debug + async mode, when a watcher callbacks\n      // throws, we also throw the saved before-push error\n      // so the full cross-tick stack trace is available.\n      var prevError = this.prevError;\n      /* istanbul ignore if */\n      if ((\"development\") !== 'production' && config.debug && prevError) {\n        this.prevError = null;\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          nextTick(function () {\n            throw prevError;\n          }, 0);\n          throw e;\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n    this.queued = this.shallow = false;\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\nWatcher.prototype.evaluate = function () {\n  // avoid overwriting another watcher that is being\n  // collected.\n  var current = Dep.target;\n  this.value = this.get();\n  this.dirty = false;\n  Dep.target = current;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\n\nWatcher.prototype.depend = function () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subcriber list.\n */\n\nWatcher.prototype.teardown = function () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed or is performing a v-for\n    // re-render (the watcher list is then filtered by v-for).\n    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n      this.vm._watchers.$remove(this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n    this.vm = this.cb = this.value = null;\n  }\n};\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {*} val\n */\n\nvar seenObjects = new _Set();\nfunction traverse(val, seen) {\n  var i = undefined,\n      keys = undefined;\n  if (!seen) {\n    seen = seenObjects;\n    seen.clear();\n  }\n  var isA = isArray(val);\n  var isO = isObject(val);\n  if ((isA || isO) && Object.isExtensible(val)) {\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return;\n      } else {\n        seen.add(depId);\n      }\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) traverse(val[i], seen);\n    } else if (isO) {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) traverse(val[keys[i]], seen);\n    }\n  }\n}\n\nvar text$1 = {\n\n  bind: function bind() {\n    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\n  },\n\n  update: function update(value) {\n    this.el[this.attr] = _toString(value);\n  }\n};\n\nvar templateCache = new Cache(1000);\nvar idSelectorCache = new Cache(1000);\n\nvar map = {\n  efault: [0, '', ''],\n  legend: [1, '<fieldset>', '</fieldset>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']\n};\n\nmap.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\nmap.option = map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\nmap.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];\n\nmap.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' + 'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' + 'version=\"1.1\">', '</svg>'];\n\n/**\n * Check if a node is a supported template node with a\n * DocumentFragment content.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction isRealTemplate(node) {\n  return isTemplate(node) && isFragment(node.content);\n}\n\nvar tagRE$1 = /<([\\w:-]+)/;\nvar entityRE = /&#?\\w+?;/;\nvar commentRE = /<!--/;\n\n/**\n * Convert a string template to a DocumentFragment.\n * Determines correct wrapping by tag types. Wrapping\n * strategy found in jQuery & component/domify.\n *\n * @param {String} templateString\n * @param {Boolean} raw\n * @return {DocumentFragment}\n */\n\nfunction stringToFragment(templateString, raw) {\n  // try a cache hit first\n  var cacheKey = raw ? templateString : templateString.trim();\n  var hit = templateCache.get(cacheKey);\n  if (hit) {\n    return hit;\n  }\n\n  var frag = document.createDocumentFragment();\n  var tagMatch = templateString.match(tagRE$1);\n  var entityMatch = entityRE.test(templateString);\n  var commentMatch = commentRE.test(templateString);\n\n  if (!tagMatch && !entityMatch && !commentMatch) {\n    // text only, return a single text node.\n    frag.appendChild(document.createTextNode(templateString));\n  } else {\n    var tag = tagMatch && tagMatch[1];\n    var wrap = map[tag] || map.efault;\n    var depth = wrap[0];\n    var prefix = wrap[1];\n    var suffix = wrap[2];\n    var node = document.createElement('div');\n\n    node.innerHTML = prefix + templateString + suffix;\n    while (depth--) {\n      node = node.lastChild;\n    }\n\n    var child;\n    /* eslint-disable no-cond-assign */\n    while (child = node.firstChild) {\n      /* eslint-enable no-cond-assign */\n      frag.appendChild(child);\n    }\n  }\n  if (!raw) {\n    trimNode(frag);\n  }\n  templateCache.put(cacheKey, frag);\n  return frag;\n}\n\n/**\n * Convert a template node to a DocumentFragment.\n *\n * @param {Node} node\n * @return {DocumentFragment}\n */\n\nfunction nodeToFragment(node) {\n  // if its a template tag and the browser supports it,\n  // its content is already a document fragment. However, iOS Safari has\n  // bug when using directly cloned template content with touch\n  // events and can cause crashes when the nodes are removed from DOM, so we\n  // have to treat template elements as string templates. (#2805)\n  /* istanbul ignore if */\n  if (isRealTemplate(node)) {\n    return stringToFragment(node.innerHTML);\n  }\n  // script template\n  if (node.tagName === 'SCRIPT') {\n    return stringToFragment(node.textContent);\n  }\n  // normal node, clone it to avoid mutating the original\n  var clonedNode = cloneNode(node);\n  var frag = document.createDocumentFragment();\n  var child;\n  /* eslint-disable no-cond-assign */\n  while (child = clonedNode.firstChild) {\n    /* eslint-enable no-cond-assign */\n    frag.appendChild(child);\n  }\n  trimNode(frag);\n  return frag;\n}\n\n// Test for the presence of the Safari template cloning bug\n// https://bugs.webkit.org/showug.cgi?id=137755\nvar hasBrokenTemplate = (function () {\n  /* istanbul ignore else */\n  if (inBrowser) {\n    var a = document.createElement('div');\n    a.innerHTML = '<template>1</template>';\n    return !a.cloneNode(true).firstChild.innerHTML;\n  } else {\n    return false;\n  }\n})();\n\n// Test for IE10/11 textarea placeholder clone bug\nvar hasTextareaCloneBug = (function () {\n  /* istanbul ignore else */\n  if (inBrowser) {\n    var t = document.createElement('textarea');\n    t.placeholder = 't';\n    return t.cloneNode(true).value === 't';\n  } else {\n    return false;\n  }\n})();\n\n/**\n * 1. Deal with Safari cloning nested <template> bug by\n *    manually cloning all template instances.\n * 2. Deal with IE10/11 textarea placeholder bug by setting\n *    the correct value after cloning.\n *\n * @param {Element|DocumentFragment} node\n * @return {Element|DocumentFragment}\n */\n\nfunction cloneNode(node) {\n  /* istanbul ignore if */\n  if (!node.querySelectorAll) {\n    return node.cloneNode();\n  }\n  var res = node.cloneNode(true);\n  var i, original, cloned;\n  /* istanbul ignore if */\n  if (hasBrokenTemplate) {\n    var tempClone = res;\n    if (isRealTemplate(node)) {\n      node = node.content;\n      tempClone = res.content;\n    }\n    original = node.querySelectorAll('template');\n    if (original.length) {\n      cloned = tempClone.querySelectorAll('template');\n      i = cloned.length;\n      while (i--) {\n        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);\n      }\n    }\n  }\n  /* istanbul ignore if */\n  if (hasTextareaCloneBug) {\n    if (node.tagName === 'TEXTAREA') {\n      res.value = node.value;\n    } else {\n      original = node.querySelectorAll('textarea');\n      if (original.length) {\n        cloned = res.querySelectorAll('textarea');\n        i = cloned.length;\n        while (i--) {\n          cloned[i].value = original[i].value;\n        }\n      }\n    }\n  }\n  return res;\n}\n\n/**\n * Process the template option and normalizes it into a\n * a DocumentFragment that can be used as a partial or a\n * instance template.\n *\n * @param {*} template\n *        Possible values include:\n *        - DocumentFragment object\n *        - Node object of type Template\n *        - id selector: '#some-template-id'\n *        - template string: '<div><span>{{msg}}</span></div>'\n * @param {Boolean} shouldClone\n * @param {Boolean} raw\n *        inline HTML interpolation. Do not check for id\n *        selector and keep whitespace in the string.\n * @return {DocumentFragment|undefined}\n */\n\nfunction parseTemplate(template, shouldClone, raw) {\n  var node, frag;\n\n  // if the template is already a document fragment,\n  // do nothing\n  if (isFragment(template)) {\n    trimNode(template);\n    return shouldClone ? cloneNode(template) : template;\n  }\n\n  if (typeof template === 'string') {\n    // id selector\n    if (!raw && template.charAt(0) === '#') {\n      // id selector can be cached too\n      frag = idSelectorCache.get(template);\n      if (!frag) {\n        node = document.getElementById(template.slice(1));\n        if (node) {\n          frag = nodeToFragment(node);\n          // save selector to cache\n          idSelectorCache.put(template, frag);\n        }\n      }\n    } else {\n      // normal string template\n      frag = stringToFragment(template, raw);\n    }\n  } else if (template.nodeType) {\n    // a direct node\n    frag = nodeToFragment(template);\n  }\n\n  return frag && shouldClone ? cloneNode(frag) : frag;\n}\n\nvar template = Object.freeze({\n  cloneNode: cloneNode,\n  parseTemplate: parseTemplate\n});\n\nvar html = {\n\n  bind: function bind() {\n    // a comment node means this is a binding for\n    // {{{ inline unescaped html }}}\n    if (this.el.nodeType === 8) {\n      // hold nodes\n      this.nodes = [];\n      // replace the placeholder with proper anchor\n      this.anchor = createAnchor('v-html');\n      replace(this.el, this.anchor);\n    }\n  },\n\n  update: function update(value) {\n    value = _toString(value);\n    if (this.nodes) {\n      this.swap(value);\n    } else {\n      this.el.innerHTML = value;\n    }\n  },\n\n  swap: function swap(value) {\n    // remove old nodes\n    var i = this.nodes.length;\n    while (i--) {\n      remove(this.nodes[i]);\n    }\n    // convert new value to a fragment\n    // do not attempt to retrieve from id selector\n    var frag = parseTemplate(value, true, true);\n    // save a reference to these nodes so we can remove later\n    this.nodes = toArray(frag.childNodes);\n    before(frag, this.anchor);\n  }\n};\n\n/**\n * Abstraction for a partially-compiled fragment.\n * Can optionally compile content with a child scope.\n *\n * @param {Function} linker\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Vue} [host]\n * @param {Object} [scope]\n * @param {Fragment} [parentFrag]\n */\nfunction Fragment(linker, vm, frag, host, scope, parentFrag) {\n  this.children = [];\n  this.childFrags = [];\n  this.vm = vm;\n  this.scope = scope;\n  this.inserted = false;\n  this.parentFrag = parentFrag;\n  if (parentFrag) {\n    parentFrag.childFrags.push(this);\n  }\n  this.unlink = linker(vm, frag, host, scope, this);\n  var single = this.single = frag.childNodes.length === 1 &&\n  // do not go single mode if the only node is an anchor\n  !frag.childNodes[0].__v_anchor;\n  if (single) {\n    this.node = frag.childNodes[0];\n    this.before = singleBefore;\n    this.remove = singleRemove;\n  } else {\n    this.node = createAnchor('fragment-start');\n    this.end = createAnchor('fragment-end');\n    this.frag = frag;\n    prepend(this.node, frag);\n    frag.appendChild(this.end);\n    this.before = multiBefore;\n    this.remove = multiRemove;\n  }\n  this.node.__v_frag = this;\n}\n\n/**\n * Call attach/detach for all components contained within\n * this fragment. Also do so recursively for all child\n * fragments.\n *\n * @param {Function} hook\n */\n\nFragment.prototype.callHook = function (hook) {\n  var i, l;\n  for (i = 0, l = this.childFrags.length; i < l; i++) {\n    this.childFrags[i].callHook(hook);\n  }\n  for (i = 0, l = this.children.length; i < l; i++) {\n    hook(this.children[i]);\n  }\n};\n\n/**\n * Insert fragment before target, single node version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction singleBefore(target, withTransition) {\n  this.inserted = true;\n  var method = withTransition !== false ? beforeWithTransition : before;\n  method(this.node, target, this.vm);\n  if (inDoc(this.node)) {\n    this.callHook(attach);\n  }\n}\n\n/**\n * Remove fragment, single node version\n */\n\nfunction singleRemove() {\n  this.inserted = false;\n  var shouldCallRemove = inDoc(this.node);\n  var self = this;\n  this.beforeRemove();\n  removeWithTransition(this.node, this.vm, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach);\n    }\n    self.destroy();\n  });\n}\n\n/**\n * Insert fragment before target, multi-nodes version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction multiBefore(target, withTransition) {\n  this.inserted = true;\n  var vm = this.vm;\n  var method = withTransition !== false ? beforeWithTransition : before;\n  mapNodeRange(this.node, this.end, function (node) {\n    method(node, target, vm);\n  });\n  if (inDoc(this.node)) {\n    this.callHook(attach);\n  }\n}\n\n/**\n * Remove fragment, multi-nodes version\n */\n\nfunction multiRemove() {\n  this.inserted = false;\n  var self = this;\n  var shouldCallRemove = inDoc(this.node);\n  this.beforeRemove();\n  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach);\n    }\n    self.destroy();\n  });\n}\n\n/**\n * Prepare the fragment for removal.\n */\n\nFragment.prototype.beforeRemove = function () {\n  var i, l;\n  for (i = 0, l = this.childFrags.length; i < l; i++) {\n    // call the same method recursively on child\n    // fragments, depth-first\n    this.childFrags[i].beforeRemove(false);\n  }\n  for (i = 0, l = this.children.length; i < l; i++) {\n    // Call destroy for all contained instances,\n    // with remove:false and defer:true.\n    // Defer is necessary because we need to\n    // keep the children to call detach hooks\n    // on them.\n    this.children[i].$destroy(false, true);\n  }\n  var dirs = this.unlink.dirs;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    // disable the watchers on all the directives\n    // so that the rendered content stays the same\n    // during removal.\n    dirs[i]._watcher && dirs[i]._watcher.teardown();\n  }\n};\n\n/**\n * Destroy the fragment.\n */\n\nFragment.prototype.destroy = function () {\n  if (this.parentFrag) {\n    this.parentFrag.childFrags.$remove(this);\n  }\n  this.node.__v_frag = null;\n  this.unlink();\n};\n\n/**\n * Call attach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction attach(child) {\n  if (!child._isAttached && inDoc(child.$el)) {\n    child._callHook('attached');\n  }\n}\n\n/**\n * Call detach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction detach(child) {\n  if (child._isAttached && !inDoc(child.$el)) {\n    child._callHook('detached');\n  }\n}\n\nvar linkerCache = new Cache(5000);\n\n/**\n * A factory that can be used to create instances of a\n * fragment. Caches the compiled linker if possible.\n *\n * @param {Vue} vm\n * @param {Element|String} el\n */\nfunction FragmentFactory(vm, el) {\n  this.vm = vm;\n  var template;\n  var isString = typeof el === 'string';\n  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {\n    template = parseTemplate(el, true);\n  } else {\n    template = document.createDocumentFragment();\n    template.appendChild(el);\n  }\n  this.template = template;\n  // linker can be cached, but only for components\n  var linker;\n  var cid = vm.constructor.cid;\n  if (cid > 0) {\n    var cacheId = cid + (isString ? el : getOuterHTML(el));\n    linker = linkerCache.get(cacheId);\n    if (!linker) {\n      linker = compile(template, vm.$options, true);\n      linkerCache.put(cacheId, linker);\n    }\n  } else {\n    linker = compile(template, vm.$options, true);\n  }\n  this.linker = linker;\n}\n\n/**\n * Create a fragment instance with given host and scope.\n *\n * @param {Vue} host\n * @param {Object} scope\n * @param {Fragment} parentFrag\n */\n\nFragmentFactory.prototype.create = function (host, scope, parentFrag) {\n  var frag = cloneNode(this.template);\n  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);\n};\n\nvar ON = 700;\nvar MODEL = 800;\nvar BIND = 850;\nvar TRANSITION = 1100;\nvar EL = 1500;\nvar COMPONENT = 1500;\nvar PARTIAL = 1750;\nvar IF = 2100;\nvar FOR = 2200;\nvar SLOT = 2300;\n\nvar uid$3 = 0;\n\nvar vFor = {\n\n  priority: FOR,\n  terminal: true,\n\n  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],\n\n  bind: function bind() {\n    // support \"item in/of items\" syntax\n    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);\n    if (inMatch) {\n      var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\n      if (itMatch) {\n        this.iterator = itMatch[1].trim();\n        this.alias = itMatch[2].trim();\n      } else {\n        this.alias = inMatch[1].trim();\n      }\n      this.expression = inMatch[2];\n    }\n\n    if (!this.alias) {\n      (\"development\") !== 'production' && warn('Invalid v-for expression \"' + this.descriptor.raw + '\": ' + 'alias is required.', this.vm);\n      return;\n    }\n\n    // uid as a cache identifier\n    this.id = '__v-for__' + ++uid$3;\n\n    // check if this is an option list,\n    // so that we know if we need to update the <select>'s\n    // v-model when the option list has changed.\n    // because v-model has a lower priority than v-for,\n    // the v-model is not bound here yet, so we have to\n    // retrive it in the actual updateModel() function.\n    var tag = this.el.tagName;\n    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';\n\n    // setup anchor nodes\n    this.start = createAnchor('v-for-start');\n    this.end = createAnchor('v-for-end');\n    replace(this.el, this.end);\n    before(this.start, this.end);\n\n    // cache\n    this.cache = Object.create(null);\n\n    // fragment factory\n    this.factory = new FragmentFactory(this.vm, this.el);\n  },\n\n  update: function update(data) {\n    this.diff(data);\n    this.updateRef();\n    this.updateModel();\n  },\n\n  /**\n   * Diff, based on new data and old data, determine the\n   * minimum amount of DOM manipulations needed to make the\n   * DOM reflect the new data Array.\n   *\n   * The algorithm diffs the new data Array by storing a\n   * hidden reference to an owner vm instance on previously\n   * seen data. This allows us to achieve O(n) which is\n   * better than a levenshtein distance based algorithm,\n   * which is O(m * n).\n   *\n   * @param {Array} data\n   */\n\n  diff: function diff(data) {\n    // check if the Array was converted from an Object\n    var item = data[0];\n    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');\n\n    var trackByKey = this.params.trackBy;\n    var oldFrags = this.frags;\n    var frags = this.frags = new Array(data.length);\n    var alias = this.alias;\n    var iterator = this.iterator;\n    var start = this.start;\n    var end = this.end;\n    var inDocument = inDoc(start);\n    var init = !oldFrags;\n    var i, l, frag, key, value, primitive;\n\n    // First pass, go through the new Array and fill up\n    // the new frags array. If a piece of data has a cached\n    // instance for it, we reuse it. Otherwise build a new\n    // instance.\n    for (i = 0, l = data.length; i < l; i++) {\n      item = data[i];\n      key = convertedFromObject ? item.$key : null;\n      value = convertedFromObject ? item.$value : item;\n      primitive = !isObject(value);\n      frag = !init && this.getCachedFrag(value, i, key);\n      if (frag) {\n        // reusable fragment\n        frag.reused = true;\n        // update $index\n        frag.scope.$index = i;\n        // update $key\n        if (key) {\n          frag.scope.$key = key;\n        }\n        // update iterator\n        if (iterator) {\n          frag.scope[iterator] = key !== null ? key : i;\n        }\n        // update data for track-by, object repeat &\n        // primitive values.\n        if (trackByKey || convertedFromObject || primitive) {\n          withoutConversion(function () {\n            frag.scope[alias] = value;\n          });\n        }\n      } else {\n        // new isntance\n        frag = this.create(value, alias, i, key);\n        frag.fresh = !init;\n      }\n      frags[i] = frag;\n      if (init) {\n        frag.before(end);\n      }\n    }\n\n    // we're done for the initial render.\n    if (init) {\n      return;\n    }\n\n    // Second pass, go through the old fragments and\n    // destroy those who are not reused (and remove them\n    // from cache)\n    var removalIndex = 0;\n    var totalRemoved = oldFrags.length - frags.length;\n    // when removing a large number of fragments, watcher removal\n    // turns out to be a perf bottleneck, so we batch the watcher\n    // removals into a single filter call!\n    this.vm._vForRemoving = true;\n    for (i = 0, l = oldFrags.length; i < l; i++) {\n      frag = oldFrags[i];\n      if (!frag.reused) {\n        this.deleteCachedFrag(frag);\n        this.remove(frag, removalIndex++, totalRemoved, inDocument);\n      }\n    }\n    this.vm._vForRemoving = false;\n    if (removalIndex) {\n      this.vm._watchers = this.vm._watchers.filter(function (w) {\n        return w.active;\n      });\n    }\n\n    // Final pass, move/insert new fragments into the\n    // right place.\n    var targetPrev, prevEl, currentPrev;\n    var insertionIndex = 0;\n    for (i = 0, l = frags.length; i < l; i++) {\n      frag = frags[i];\n      // this is the frag that we should be after\n      targetPrev = frags[i - 1];\n      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\n      if (frag.reused && !frag.staggerCb) {\n        currentPrev = findPrevFrag(frag, start, this.id);\n        if (currentPrev !== targetPrev && (!currentPrev ||\n        // optimization for moving a single item.\n        // thanks to suggestions by @livoras in #1807\n        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\n          this.move(frag, prevEl);\n        }\n      } else {\n        // new instance, or still in stagger.\n        // insert with updated stagger index.\n        this.insert(frag, insertionIndex++, prevEl, inDocument);\n      }\n      frag.reused = frag.fresh = false;\n    }\n  },\n\n  /**\n   * Create a new fragment instance.\n   *\n   * @param {*} value\n   * @param {String} alias\n   * @param {Number} index\n   * @param {String} [key]\n   * @return {Fragment}\n   */\n\n  create: function create(value, alias, index, key) {\n    var host = this._host;\n    // create iteration scope\n    var parentScope = this._scope || this.vm;\n    var scope = Object.create(parentScope);\n    // ref holder for the scope\n    scope.$refs = Object.create(parentScope.$refs);\n    scope.$els = Object.create(parentScope.$els);\n    // make sure point $parent to parent scope\n    scope.$parent = parentScope;\n    // for two-way binding on alias\n    scope.$forContext = this;\n    // define scope properties\n    // important: define the scope alias without forced conversion\n    // so that frozen data structures remain non-reactive.\n    withoutConversion(function () {\n      defineReactive(scope, alias, value);\n    });\n    defineReactive(scope, '$index', index);\n    if (key) {\n      defineReactive(scope, '$key', key);\n    } else if (scope.$key) {\n      // avoid accidental fallback\n      def(scope, '$key', null);\n    }\n    if (this.iterator) {\n      defineReactive(scope, this.iterator, key !== null ? key : index);\n    }\n    var frag = this.factory.create(host, scope, this._frag);\n    frag.forId = this.id;\n    this.cacheFrag(value, frag, index, key);\n    return frag;\n  },\n\n  /**\n   * Update the v-ref on owner vm.\n   */\n\n  updateRef: function updateRef() {\n    var ref = this.descriptor.ref;\n    if (!ref) return;\n    var hash = (this._scope || this.vm).$refs;\n    var refs;\n    if (!this.fromObject) {\n      refs = this.frags.map(findVmFromFrag);\n    } else {\n      refs = {};\n      this.frags.forEach(function (frag) {\n        refs[frag.scope.$key] = findVmFromFrag(frag);\n      });\n    }\n    hash[ref] = refs;\n  },\n\n  /**\n   * For option lists, update the containing v-model on\n   * parent <select>.\n   */\n\n  updateModel: function updateModel() {\n    if (this.isOption) {\n      var parent = this.start.parentNode;\n      var model = parent && parent.__v_model;\n      if (model) {\n        model.forceUpdate();\n      }\n    }\n  },\n\n  /**\n   * Insert a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Node} prevEl\n   * @param {Boolean} inDocument\n   */\n\n  insert: function insert(frag, index, prevEl, inDocument) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel();\n      frag.staggerCb = null;\n    }\n    var staggerAmount = this.getStagger(frag, index, null, 'enter');\n    if (inDocument && staggerAmount) {\n      // create an anchor and insert it synchronously,\n      // so that we can resolve the correct order without\n      // worrying about some elements not inserted yet\n      var anchor = frag.staggerAnchor;\n      if (!anchor) {\n        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');\n        anchor.__v_frag = frag;\n      }\n      after(anchor, prevEl);\n      var op = frag.staggerCb = cancellable(function () {\n        frag.staggerCb = null;\n        frag.before(anchor);\n        remove(anchor);\n      });\n      setTimeout(op, staggerAmount);\n    } else {\n      var target = prevEl.nextSibling;\n      /* istanbul ignore if */\n      if (!target) {\n        // reset end anchor position in case the position was messed up\n        // by an external drag-n-drop library.\n        after(this.end, prevEl);\n        target = this.end;\n      }\n      frag.before(target);\n    }\n  },\n\n  /**\n   * Remove a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {Boolean} inDocument\n   */\n\n  remove: function remove(frag, index, total, inDocument) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel();\n      frag.staggerCb = null;\n      // it's not possible for the same frag to be removed\n      // twice, so if we have a pending stagger callback,\n      // it means this frag is queued for enter but removed\n      // before its transition started. Since it is already\n      // destroyed, we can just leave it in detached state.\n      return;\n    }\n    var staggerAmount = this.getStagger(frag, index, total, 'leave');\n    if (inDocument && staggerAmount) {\n      var op = frag.staggerCb = cancellable(function () {\n        frag.staggerCb = null;\n        frag.remove();\n      });\n      setTimeout(op, staggerAmount);\n    } else {\n      frag.remove();\n    }\n  },\n\n  /**\n   * Move a fragment to a new position.\n   * Force no transition.\n   *\n   * @param {Fragment} frag\n   * @param {Node} prevEl\n   */\n\n  move: function move(frag, prevEl) {\n    // fix a common issue with Sortable:\n    // if prevEl doesn't have nextSibling, this means it's\n    // been dragged after the end anchor. Just re-position\n    // the end anchor to the end of the container.\n    /* istanbul ignore if */\n    if (!prevEl.nextSibling) {\n      this.end.parentNode.appendChild(this.end);\n    }\n    frag.before(prevEl.nextSibling, false);\n  },\n\n  /**\n   * Cache a fragment using track-by or the object key.\n   *\n   * @param {*} value\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {String} [key]\n   */\n\n  cacheFrag: function cacheFrag(value, frag, index, key) {\n    var trackByKey = this.params.trackBy;\n    var cache = this.cache;\n    var primitive = !isObject(value);\n    var id;\n    if (key || trackByKey || primitive) {\n      id = getTrackByKey(index, key, value, trackByKey);\n      if (!cache[id]) {\n        cache[id] = frag;\n      } else if (trackByKey !== '$index') {\n        (\"development\") !== 'production' && this.warnDuplicate(value);\n      }\n    } else {\n      id = this.id;\n      if (hasOwn(value, id)) {\n        if (value[id] === null) {\n          value[id] = frag;\n        } else {\n          (\"development\") !== 'production' && this.warnDuplicate(value);\n        }\n      } else if (Object.isExtensible(value)) {\n        def(value, id, frag);\n      } else if (true) {\n        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');\n      }\n    }\n    frag.raw = value;\n  },\n\n  /**\n   * Get a cached fragment from the value/index/key\n   *\n   * @param {*} value\n   * @param {Number} index\n   * @param {String} key\n   * @return {Fragment}\n   */\n\n  getCachedFrag: function getCachedFrag(value, index, key) {\n    var trackByKey = this.params.trackBy;\n    var primitive = !isObject(value);\n    var frag;\n    if (key || trackByKey || primitive) {\n      var id = getTrackByKey(index, key, value, trackByKey);\n      frag = this.cache[id];\n    } else {\n      frag = value[this.id];\n    }\n    if (frag && (frag.reused || frag.fresh)) {\n      (\"development\") !== 'production' && this.warnDuplicate(value);\n    }\n    return frag;\n  },\n\n  /**\n   * Delete a fragment from cache.\n   *\n   * @param {Fragment} frag\n   */\n\n  deleteCachedFrag: function deleteCachedFrag(frag) {\n    var value = frag.raw;\n    var trackByKey = this.params.trackBy;\n    var scope = frag.scope;\n    var index = scope.$index;\n    // fix #948: avoid accidentally fall through to\n    // a parent repeater which happens to have $key.\n    var key = hasOwn(scope, '$key') && scope.$key;\n    var primitive = !isObject(value);\n    if (trackByKey || key || primitive) {\n      var id = getTrackByKey(index, key, value, trackByKey);\n      this.cache[id] = null;\n    } else {\n      value[this.id] = null;\n      frag.raw = null;\n    }\n  },\n\n  /**\n   * Get the stagger amount for an insertion/removal.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {String} type\n   */\n\n  getStagger: function getStagger(frag, index, total, type) {\n    type = type + 'Stagger';\n    var trans = frag.node.__v_trans;\n    var hooks = trans && trans.hooks;\n    var hook = hooks && (hooks[type] || hooks.stagger);\n    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);\n  },\n\n  /**\n   * Pre-process the value before piping it through the\n   * filters. This is passed to and called by the watcher.\n   */\n\n  _preProcess: function _preProcess(value) {\n    // regardless of type, store the un-filtered raw value.\n    this.rawValue = value;\n    return value;\n  },\n\n  /**\n   * Post-process the value after it has been piped through\n   * the filters. This is passed to and called by the watcher.\n   *\n   * It is necessary for this to be called during the\n   * watcher's dependency collection phase because we want\n   * the v-for to update when the source Object is mutated.\n   */\n\n  _postProcess: function _postProcess(value) {\n    if (isArray(value)) {\n      return value;\n    } else if (isPlainObject(value)) {\n      // convert plain object to array.\n      var keys = Object.keys(value);\n      var i = keys.length;\n      var res = new Array(i);\n      var key;\n      while (i--) {\n        key = keys[i];\n        res[i] = {\n          $key: key,\n          $value: value[key]\n        };\n      }\n      return res;\n    } else {\n      if (typeof value === 'number' && !isNaN(value)) {\n        value = range(value);\n      }\n      return value || [];\n    }\n  },\n\n  unbind: function unbind() {\n    if (this.descriptor.ref) {\n      (this._scope || this.vm).$refs[this.descriptor.ref] = null;\n    }\n    if (this.frags) {\n      var i = this.frags.length;\n      var frag;\n      while (i--) {\n        frag = this.frags[i];\n        this.deleteCachedFrag(frag);\n        frag.destroy();\n      }\n    }\n  }\n};\n\n/**\n * Helper to find the previous element that is a fragment\n * anchor. This is necessary because a destroyed frag's\n * element could still be lingering in the DOM before its\n * leaving transition finishes, but its inserted flag\n * should have been set to false so we can skip them.\n *\n * If this is a block repeat, we want to make sure we only\n * return frag that is bound to this v-for. (see #929)\n *\n * @param {Fragment} frag\n * @param {Comment|Text} anchor\n * @param {String} id\n * @return {Fragment}\n */\n\nfunction findPrevFrag(frag, anchor, id) {\n  var el = frag.node.previousSibling;\n  /* istanbul ignore if */\n  if (!el) return;\n  frag = el.__v_frag;\n  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {\n    el = el.previousSibling;\n    /* istanbul ignore if */\n    if (!el) return;\n    frag = el.__v_frag;\n  }\n  return frag;\n}\n\n/**\n * Find a vm from a fragment.\n *\n * @param {Fragment} frag\n * @return {Vue|undefined}\n */\n\nfunction findVmFromFrag(frag) {\n  var node = frag.node;\n  // handle multi-node frag\n  if (frag.end) {\n    while (!node.__vue__ && node !== frag.end && node.nextSibling) {\n      node = node.nextSibling;\n    }\n  }\n  return node.__vue__;\n}\n\n/**\n * Create a range array from given number.\n *\n * @param {Number} n\n * @return {Array}\n */\n\nfunction range(n) {\n  var i = -1;\n  var ret = new Array(Math.floor(n));\n  while (++i < n) {\n    ret[i] = i;\n  }\n  return ret;\n}\n\n/**\n * Get the track by key for an item.\n *\n * @param {Number} index\n * @param {String} key\n * @param {*} value\n * @param {String} [trackByKey]\n */\n\nfunction getTrackByKey(index, key, value, trackByKey) {\n  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;\n}\n\nif (true) {\n  vFor.warnDuplicate = function (value) {\n    warn('Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' + JSON.stringify(value) + '. Use track-by=\"$index\" if ' + 'you are expecting duplicate values.', this.vm);\n  };\n}\n\nvar vIf = {\n\n  priority: IF,\n  terminal: true,\n\n  bind: function bind() {\n    var el = this.el;\n    if (!el.__vue__) {\n      // check else block\n      var next = el.nextElementSibling;\n      if (next && getAttr(next, 'v-else') !== null) {\n        remove(next);\n        this.elseEl = next;\n      }\n      // check main block\n      this.anchor = createAnchor('v-if');\n      replace(el, this.anchor);\n    } else {\n      (\"development\") !== 'production' && warn('v-if=\"' + this.expression + '\" cannot be ' + 'used on an instance root element.', this.vm);\n      this.invalid = true;\n    }\n  },\n\n  update: function update(value) {\n    if (this.invalid) return;\n    if (value) {\n      if (!this.frag) {\n        this.insert();\n      }\n    } else {\n      this.remove();\n    }\n  },\n\n  insert: function insert() {\n    if (this.elseFrag) {\n      this.elseFrag.remove();\n      this.elseFrag = null;\n    }\n    // lazy init factory\n    if (!this.factory) {\n      this.factory = new FragmentFactory(this.vm, this.el);\n    }\n    this.frag = this.factory.create(this._host, this._scope, this._frag);\n    this.frag.before(this.anchor);\n  },\n\n  remove: function remove() {\n    if (this.frag) {\n      this.frag.remove();\n      this.frag = null;\n    }\n    if (this.elseEl && !this.elseFrag) {\n      if (!this.elseFactory) {\n        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);\n      }\n      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);\n      this.elseFrag.before(this.anchor);\n    }\n  },\n\n  unbind: function unbind() {\n    if (this.frag) {\n      this.frag.destroy();\n    }\n    if (this.elseFrag) {\n      this.elseFrag.destroy();\n    }\n  }\n};\n\nvar show = {\n\n  bind: function bind() {\n    // check else block\n    var next = this.el.nextElementSibling;\n    if (next && getAttr(next, 'v-else') !== null) {\n      this.elseEl = next;\n    }\n  },\n\n  update: function update(value) {\n    this.apply(this.el, value);\n    if (this.elseEl) {\n      this.apply(this.elseEl, !value);\n    }\n  },\n\n  apply: function apply(el, value) {\n    if (inDoc(el)) {\n      applyTransition(el, value ? 1 : -1, toggle, this.vm);\n    } else {\n      toggle();\n    }\n    function toggle() {\n      el.style.display = value ? '' : 'none';\n    }\n  }\n};\n\nvar text$2 = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n    var isRange = el.type === 'range';\n    var lazy = this.params.lazy;\n    var number = this.params.number;\n    var debounce = this.params.debounce;\n\n    // handle composition events.\n    //   http://blog.evanyou.me/2014/01/03/composition-event/\n    // skip this for Android because it handles composition\n    // events quite differently. Android doesn't trigger\n    // composition events for language input methods e.g.\n    // Chinese, but instead triggers them for spelling\n    // suggestions... (see Discussion/#162)\n    var composing = false;\n    if (!isAndroid && !isRange) {\n      this.on('compositionstart', function () {\n        composing = true;\n      });\n      this.on('compositionend', function () {\n        composing = false;\n        // in IE11 the \"compositionend\" event fires AFTER\n        // the \"input\" event, so the input handler is blocked\n        // at the end... have to call it here.\n        //\n        // #1327: in lazy mode this is unecessary.\n        if (!lazy) {\n          self.listener();\n        }\n      });\n    }\n\n    // prevent messing with the input when user is typing,\n    // and force update on blur.\n    this.focused = false;\n    if (!isRange && !lazy) {\n      this.on('focus', function () {\n        self.focused = true;\n      });\n      this.on('blur', function () {\n        self.focused = false;\n        // do not sync value after fragment removal (#2017)\n        if (!self._frag || self._frag.inserted) {\n          self.rawListener();\n        }\n      });\n    }\n\n    // Now attach the main listener\n    this.listener = this.rawListener = function () {\n      if (composing || !self._bound) {\n        return;\n      }\n      var val = number || isRange ? toNumber(el.value) : el.value;\n      self.set(val);\n      // force update on next tick to avoid lock & same value\n      // also only update when user is not typing\n      nextTick(function () {\n        if (self._bound && !self.focused) {\n          self.update(self._watcher.value);\n        }\n      });\n    };\n\n    // apply debounce\n    if (debounce) {\n      this.listener = _debounce(this.listener, debounce);\n    }\n\n    // Support jQuery events, since jQuery.trigger() doesn't\n    // trigger native events in some cases and some plugins\n    // rely on $.trigger()\n    //\n    // We want to make sure if a listener is attached using\n    // jQuery, it is also removed with jQuery, that's why\n    // we do the check for each directive instance and\n    // store that check result on itself. This also allows\n    // easier test coverage control by unsetting the global\n    // jQuery variable in tests.\n    this.hasjQuery = typeof jQuery === 'function';\n    if (this.hasjQuery) {\n      var method = jQuery.fn.on ? 'on' : 'bind';\n      jQuery(el)[method]('change', this.rawListener);\n      if (!lazy) {\n        jQuery(el)[method]('input', this.listener);\n      }\n    } else {\n      this.on('change', this.rawListener);\n      if (!lazy) {\n        this.on('input', this.listener);\n      }\n    }\n\n    // IE9 doesn't fire input event on backspace/del/cut\n    if (!lazy && isIE9) {\n      this.on('cut', function () {\n        nextTick(self.listener);\n      });\n      this.on('keyup', function (e) {\n        if (e.keyCode === 46 || e.keyCode === 8) {\n          self.listener();\n        }\n      });\n    }\n\n    // set initial value if present\n    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {\n      this.afterBind = this.listener;\n    }\n  },\n\n  update: function update(value) {\n    // #3029 only update when the value changes. This prevent\n    // browsers from overwriting values like selectionStart\n    value = _toString(value);\n    if (value !== this.el.value) this.el.value = value;\n  },\n\n  unbind: function unbind() {\n    var el = this.el;\n    if (this.hasjQuery) {\n      var method = jQuery.fn.off ? 'off' : 'unbind';\n      jQuery(el)[method]('change', this.listener);\n      jQuery(el)[method]('input', this.listener);\n    }\n  }\n};\n\nvar radio = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n\n    this.getValue = function () {\n      // value overwrite via v-bind:value\n      if (el.hasOwnProperty('_value')) {\n        return el._value;\n      }\n      var val = el.value;\n      if (self.params.number) {\n        val = toNumber(val);\n      }\n      return val;\n    };\n\n    this.listener = function () {\n      self.set(self.getValue());\n    };\n    this.on('change', this.listener);\n\n    if (el.hasAttribute('checked')) {\n      this.afterBind = this.listener;\n    }\n  },\n\n  update: function update(value) {\n    this.el.checked = looseEqual(value, this.getValue());\n  }\n};\n\nvar select = {\n\n  bind: function bind() {\n    var _this = this;\n\n    var self = this;\n    var el = this.el;\n\n    // method to force update DOM using latest value.\n    this.forceUpdate = function () {\n      if (self._watcher) {\n        self.update(self._watcher.get());\n      }\n    };\n\n    // check if this is a multiple select\n    var multiple = this.multiple = el.hasAttribute('multiple');\n\n    // attach listener\n    this.listener = function () {\n      var value = getValue(el, multiple);\n      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;\n      self.set(value);\n    };\n    this.on('change', this.listener);\n\n    // if has initial value, set afterBind\n    var initValue = getValue(el, multiple, true);\n    if (multiple && initValue.length || !multiple && initValue !== null) {\n      this.afterBind = this.listener;\n    }\n\n    // All major browsers except Firefox resets\n    // selectedIndex with value -1 to 0 when the element\n    // is appended to a new parent, therefore we have to\n    // force a DOM update whenever that happens...\n    this.vm.$on('hook:attached', function () {\n      nextTick(_this.forceUpdate);\n    });\n    if (!inDoc(el)) {\n      nextTick(this.forceUpdate);\n    }\n  },\n\n  update: function update(value) {\n    var el = this.el;\n    el.selectedIndex = -1;\n    var multi = this.multiple && isArray(value);\n    var options = el.options;\n    var i = options.length;\n    var op, val;\n    while (i--) {\n      op = options[i];\n      val = op.hasOwnProperty('_value') ? op._value : op.value;\n      /* eslint-disable eqeqeq */\n      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);\n      /* eslint-enable eqeqeq */\n    }\n  },\n\n  unbind: function unbind() {\n    /* istanbul ignore next */\n    this.vm.$off('hook:attached', this.forceUpdate);\n  }\n};\n\n/**\n * Get select value\n *\n * @param {SelectElement} el\n * @param {Boolean} multi\n * @param {Boolean} init\n * @return {Array|*}\n */\n\nfunction getValue(el, multi, init) {\n  var res = multi ? [] : null;\n  var op, val, selected;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    op = el.options[i];\n    selected = init ? op.hasAttribute('selected') : op.selected;\n    if (selected) {\n      val = op.hasOwnProperty('_value') ? op._value : op.value;\n      if (multi) {\n        res.push(val);\n      } else {\n        return val;\n      }\n    }\n  }\n  return res;\n}\n\n/**\n * Native Array.indexOf uses strict equal, but in this\n * case we need to match string/numbers with custom equal.\n *\n * @param {Array} arr\n * @param {*} val\n */\n\nfunction indexOf$1(arr, val) {\n  var i = arr.length;\n  while (i--) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nvar checkbox = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n\n    this.getValue = function () {\n      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;\n    };\n\n    function getBooleanValue() {\n      var val = el.checked;\n      if (val && el.hasOwnProperty('_trueValue')) {\n        return el._trueValue;\n      }\n      if (!val && el.hasOwnProperty('_falseValue')) {\n        return el._falseValue;\n      }\n      return val;\n    }\n\n    this.listener = function () {\n      var model = self._watcher.value;\n      if (isArray(model)) {\n        var val = self.getValue();\n        if (el.checked) {\n          if (indexOf(model, val) < 0) {\n            model.push(val);\n          }\n        } else {\n          model.$remove(val);\n        }\n      } else {\n        self.set(getBooleanValue());\n      }\n    };\n\n    this.on('change', this.listener);\n    if (el.hasAttribute('checked')) {\n      this.afterBind = this.listener;\n    }\n  },\n\n  update: function update(value) {\n    var el = this.el;\n    if (isArray(value)) {\n      el.checked = indexOf(value, this.getValue()) > -1;\n    } else {\n      if (el.hasOwnProperty('_trueValue')) {\n        el.checked = looseEqual(value, el._trueValue);\n      } else {\n        el.checked = !!value;\n      }\n    }\n  }\n};\n\nvar handlers = {\n  text: text$2,\n  radio: radio,\n  select: select,\n  checkbox: checkbox\n};\n\nvar model = {\n\n  priority: MODEL,\n  twoWay: true,\n  handlers: handlers,\n  params: ['lazy', 'number', 'debounce'],\n\n  /**\n   * Possible elements:\n   *   <select>\n   *   <textarea>\n   *   <input type=\"*\">\n   *     - text\n   *     - checkbox\n   *     - radio\n   *     - number\n   */\n\n  bind: function bind() {\n    // friendly warning...\n    this.checkFilters();\n    if (this.hasRead && !this.hasWrite) {\n      (\"development\") !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model=\"' + this.descriptor.raw + '\". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);\n    }\n    var el = this.el;\n    var tag = el.tagName;\n    var handler;\n    if (tag === 'INPUT') {\n      handler = handlers[el.type] || handlers.text;\n    } else if (tag === 'SELECT') {\n      handler = handlers.select;\n    } else if (tag === 'TEXTAREA') {\n      handler = handlers.text;\n    } else {\n      (\"development\") !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);\n      return;\n    }\n    el.__v_model = this;\n    handler.bind.call(this);\n    this.update = handler.update;\n    this._unbind = handler.unbind;\n  },\n\n  /**\n   * Check read/write filter stats.\n   */\n\n  checkFilters: function checkFilters() {\n    var filters = this.filters;\n    if (!filters) return;\n    var i = filters.length;\n    while (i--) {\n      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);\n      if (typeof filter === 'function' || filter.read) {\n        this.hasRead = true;\n      }\n      if (filter.write) {\n        this.hasWrite = true;\n      }\n    }\n  },\n\n  unbind: function unbind() {\n    this.el.__v_model = null;\n    this._unbind && this._unbind();\n  }\n};\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  'delete': [8, 46],\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40\n};\n\nfunction keyFilter(handler, keys) {\n  var codes = keys.map(function (key) {\n    var charCode = key.charCodeAt(0);\n    if (charCode > 47 && charCode < 58) {\n      return parseInt(key, 10);\n    }\n    if (key.length === 1) {\n      charCode = key.toUpperCase().charCodeAt(0);\n      if (charCode > 64 && charCode < 91) {\n        return charCode;\n      }\n    }\n    return keyCodes[key];\n  });\n  codes = [].concat.apply([], codes);\n  return function keyHandler(e) {\n    if (codes.indexOf(e.keyCode) > -1) {\n      return handler.call(this, e);\n    }\n  };\n}\n\nfunction stopFilter(handler) {\n  return function stopHandler(e) {\n    e.stopPropagation();\n    return handler.call(this, e);\n  };\n}\n\nfunction preventFilter(handler) {\n  return function preventHandler(e) {\n    e.preventDefault();\n    return handler.call(this, e);\n  };\n}\n\nfunction selfFilter(handler) {\n  return function selfHandler(e) {\n    if (e.target === e.currentTarget) {\n      return handler.call(this, e);\n    }\n  };\n}\n\nvar on$1 = {\n\n  priority: ON,\n  acceptStatement: true,\n  keyCodes: keyCodes,\n\n  bind: function bind() {\n    // deal with iframes\n    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {\n      var self = this;\n      this.iframeBind = function () {\n        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);\n      };\n      this.on('load', this.iframeBind);\n    }\n  },\n\n  update: function update(handler) {\n    // stub a noop for v-on with no value,\n    // e.g. @mousedown.prevent\n    if (!this.descriptor.raw) {\n      handler = function () {};\n    }\n\n    if (typeof handler !== 'function') {\n      (\"development\") !== 'production' && warn('v-on:' + this.arg + '=\"' + this.expression + '\" expects a function value, ' + 'got ' + handler, this.vm);\n      return;\n    }\n\n    // apply modifiers\n    if (this.modifiers.stop) {\n      handler = stopFilter(handler);\n    }\n    if (this.modifiers.prevent) {\n      handler = preventFilter(handler);\n    }\n    if (this.modifiers.self) {\n      handler = selfFilter(handler);\n    }\n    // key filter\n    var keys = Object.keys(this.modifiers).filter(function (key) {\n      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';\n    });\n    if (keys.length) {\n      handler = keyFilter(handler, keys);\n    }\n\n    this.reset();\n    this.handler = handler;\n\n    if (this.iframeBind) {\n      this.iframeBind();\n    } else {\n      on(this.el, this.arg, this.handler, this.modifiers.capture);\n    }\n  },\n\n  reset: function reset() {\n    var el = this.iframeBind ? this.el.contentWindow : this.el;\n    if (this.handler) {\n      off(el, this.arg, this.handler);\n    }\n  },\n\n  unbind: function unbind() {\n    this.reset();\n  }\n};\n\nvar prefixes = ['-webkit-', '-moz-', '-ms-'];\nvar camelPrefixes = ['Webkit', 'Moz', 'ms'];\nvar importantRE = /!important;?$/;\nvar propCache = Object.create(null);\n\nvar testEl = null;\n\nvar style = {\n\n  deep: true,\n\n  update: function update(value) {\n    if (typeof value === 'string') {\n      this.el.style.cssText = value;\n    } else if (isArray(value)) {\n      this.handleObject(value.reduce(extend, {}));\n    } else {\n      this.handleObject(value || {});\n    }\n  },\n\n  handleObject: function handleObject(value) {\n    // cache object styles so that only changed props\n    // are actually updated.\n    var cache = this.cache || (this.cache = {});\n    var name, val;\n    for (name in cache) {\n      if (!(name in value)) {\n        this.handleSingle(name, null);\n        delete cache[name];\n      }\n    }\n    for (name in value) {\n      val = value[name];\n      if (val !== cache[name]) {\n        cache[name] = val;\n        this.handleSingle(name, val);\n      }\n    }\n  },\n\n  handleSingle: function handleSingle(prop, value) {\n    prop = normalize(prop);\n    if (!prop) return; // unsupported prop\n    // cast possible numbers/booleans into strings\n    if (value != null) value += '';\n    if (value) {\n      var isImportant = importantRE.test(value) ? 'important' : '';\n      if (isImportant) {\n        /* istanbul ignore if */\n        if (true) {\n          warn('It\\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');\n        }\n        value = value.replace(importantRE, '').trim();\n        this.el.style.setProperty(prop.kebab, value, isImportant);\n      } else {\n        this.el.style[prop.camel] = value;\n      }\n    } else {\n      this.el.style[prop.camel] = '';\n    }\n  }\n\n};\n\n/**\n * Normalize a CSS property name.\n * - cache result\n * - auto prefix\n * - camelCase -> dash-case\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction normalize(prop) {\n  if (propCache[prop]) {\n    return propCache[prop];\n  }\n  var res = prefix(prop);\n  propCache[prop] = propCache[res] = res;\n  return res;\n}\n\n/**\n * Auto detect the appropriate prefix for a CSS property.\n * https://gist.github.com/paulirish/523692\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction prefix(prop) {\n  prop = hyphenate(prop);\n  var camel = camelize(prop);\n  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);\n  if (!testEl) {\n    testEl = document.createElement('div');\n  }\n  var i = prefixes.length;\n  var prefixed;\n  if (camel !== 'filter' && camel in testEl.style) {\n    return {\n      kebab: prop,\n      camel: camel\n    };\n  }\n  while (i--) {\n    prefixed = camelPrefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return {\n        kebab: prefixes[i] + prop,\n        camel: prefixed\n      };\n    }\n  }\n}\n\n// xlink\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xlinkRE = /^xlink:/;\n\n// check for attributes that prohibit interpolations\nvar disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;\n// these attributes should also set their corresponding properties\n// because they only affect the initial state of the element\nvar attrWithPropsRE = /^(?:value|checked|selected|muted)$/;\n// these attributes expect enumrated values of \"true\" or \"false\"\n// but are not boolean attributes\nvar enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;\n\n// these attributes should set a hidden property for\n// binding v-model to object values\nvar modelProps = {\n  value: '_value',\n  'true-value': '_trueValue',\n  'false-value': '_falseValue'\n};\n\nvar bind$1 = {\n\n  priority: BIND,\n\n  bind: function bind() {\n    var attr = this.arg;\n    var tag = this.el.tagName;\n    // should be deep watch on object mode\n    if (!attr) {\n      this.deep = true;\n    }\n    // handle interpolation bindings\n    var descriptor = this.descriptor;\n    var tokens = descriptor.interp;\n    if (tokens) {\n      // handle interpolations with one-time tokens\n      if (descriptor.hasOneTime) {\n        this.expression = tokensToExp(tokens, this._scope || this.vm);\n      }\n\n      // only allow binding on native attributes\n      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {\n        (\"development\") !== 'production' && warn(attr + '=\"' + descriptor.raw + '\": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);\n        this.el.removeAttribute(attr);\n        this.invalid = true;\n      }\n\n      /* istanbul ignore if */\n      if (true) {\n        var raw = attr + '=\"' + descriptor.raw + '\": ';\n        // warn src\n        if (attr === 'src') {\n          warn(raw + 'interpolation in \"src\" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);\n        }\n\n        // warn style\n        if (attr === 'style') {\n          warn(raw + 'interpolation in \"style\" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);\n        }\n      }\n    }\n  },\n\n  update: function update(value) {\n    if (this.invalid) {\n      return;\n    }\n    var attr = this.arg;\n    if (this.arg) {\n      this.handleSingle(attr, value);\n    } else {\n      this.handleObject(value || {});\n    }\n  },\n\n  // share object handler with v-bind:class\n  handleObject: style.handleObject,\n\n  handleSingle: function handleSingle(attr, value) {\n    var el = this.el;\n    var interp = this.descriptor.interp;\n    if (this.modifiers.camel) {\n      attr = camelize(attr);\n    }\n    if (!interp && attrWithPropsRE.test(attr) && attr in el) {\n      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to \"null\" for null...\n      ? '' : value : value;\n\n      if (el[attr] !== attrValue) {\n        el[attr] = attrValue;\n      }\n    }\n    // set model props\n    var modelProp = modelProps[attr];\n    if (!interp && modelProp) {\n      el[modelProp] = value;\n      // update v-model if present\n      var model = el.__v_model;\n      if (model) {\n        model.listener();\n      }\n    }\n    // do not set value attribute for textarea\n    if (attr === 'value' && el.tagName === 'TEXTAREA') {\n      el.removeAttribute(attr);\n      return;\n    }\n    // update attribute\n    if (enumeratedAttrRE.test(attr)) {\n      el.setAttribute(attr, value ? 'true' : 'false');\n    } else if (value != null && value !== false) {\n      if (attr === 'class') {\n        // handle edge case #1960:\n        // class interpolation should not overwrite Vue transition class\n        if (el.__v_trans) {\n          value += ' ' + el.__v_trans.id + '-transition';\n        }\n        setClass(el, value);\n      } else if (xlinkRE.test(attr)) {\n        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);\n      } else {\n        el.setAttribute(attr, value === true ? '' : value);\n      }\n    } else {\n      el.removeAttribute(attr);\n    }\n  }\n};\n\nvar el = {\n\n  priority: EL,\n\n  bind: function bind() {\n    /* istanbul ignore if */\n    if (!this.arg) {\n      return;\n    }\n    var id = this.id = camelize(this.arg);\n    var refs = (this._scope || this.vm).$els;\n    if (hasOwn(refs, id)) {\n      refs[id] = this.el;\n    } else {\n      defineReactive(refs, id, this.el);\n    }\n  },\n\n  unbind: function unbind() {\n    var refs = (this._scope || this.vm).$els;\n    if (refs[this.id] === this.el) {\n      refs[this.id] = null;\n    }\n  }\n};\n\nvar ref = {\n  bind: function bind() {\n    (\"development\") !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);\n  }\n};\n\nvar cloak = {\n  bind: function bind() {\n    var el = this.el;\n    this.vm.$once('pre-hook:compiled', function () {\n      el.removeAttribute('v-cloak');\n    });\n  }\n};\n\n// must export plain object\nvar directives = {\n  text: text$1,\n  html: html,\n  'for': vFor,\n  'if': vIf,\n  show: show,\n  model: model,\n  on: on$1,\n  bind: bind$1,\n  el: el,\n  ref: ref,\n  cloak: cloak\n};\n\nvar vClass = {\n\n  deep: true,\n\n  update: function update(value) {\n    if (!value) {\n      this.cleanup();\n    } else if (typeof value === 'string') {\n      this.setClass(value.trim().split(/\\s+/));\n    } else {\n      this.setClass(normalize$1(value));\n    }\n  },\n\n  setClass: function setClass(value) {\n    this.cleanup(value);\n    for (var i = 0, l = value.length; i < l; i++) {\n      var val = value[i];\n      if (val) {\n        apply(this.el, val, addClass);\n      }\n    }\n    this.prevKeys = value;\n  },\n\n  cleanup: function cleanup(value) {\n    var prevKeys = this.prevKeys;\n    if (!prevKeys) return;\n    var i = prevKeys.length;\n    while (i--) {\n      var key = prevKeys[i];\n      if (!value || value.indexOf(key) < 0) {\n        apply(this.el, key, removeClass);\n      }\n    }\n  }\n};\n\n/**\n * Normalize objects and arrays (potentially containing objects)\n * into array of strings.\n *\n * @param {Object|Array<String|Object>} value\n * @return {Array<String>}\n */\n\nfunction normalize$1(value) {\n  var res = [];\n  if (isArray(value)) {\n    for (var i = 0, l = value.length; i < l; i++) {\n      var _key = value[i];\n      if (_key) {\n        if (typeof _key === 'string') {\n          res.push(_key);\n        } else {\n          for (var k in _key) {\n            if (_key[k]) res.push(k);\n          }\n        }\n      }\n    }\n  } else if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) res.push(key);\n    }\n  }\n  return res;\n}\n\n/**\n * Add or remove a class/classes on an element\n *\n * @param {Element} el\n * @param {String} key The class name. This may or may not\n *                     contain a space character, in such a\n *                     case we'll deal with multiple class\n *                     names at once.\n * @param {Function} fn\n */\n\nfunction apply(el, key, fn) {\n  key = key.trim();\n  if (key.indexOf(' ') === -1) {\n    fn(el, key);\n    return;\n  }\n  // The key contains one or more space characters.\n  // Since a class name doesn't accept such characters, we\n  // treat it as multiple classes.\n  var keys = key.split(/\\s+/);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    fn(el, keys[i]);\n  }\n}\n\nvar component = {\n\n  priority: COMPONENT,\n\n  params: ['keep-alive', 'transition-mode', 'inline-template'],\n\n  /**\n   * Setup. Two possible usages:\n   *\n   * - static:\n   *   <comp> or <div v-component=\"comp\">\n   *\n   * - dynamic:\n   *   <component :is=\"view\">\n   */\n\n  bind: function bind() {\n    if (!this.el.__vue__) {\n      // keep-alive cache\n      this.keepAlive = this.params.keepAlive;\n      if (this.keepAlive) {\n        this.cache = {};\n      }\n      // check inline-template\n      if (this.params.inlineTemplate) {\n        // extract inline template as a DocumentFragment\n        this.inlineTemplate = extractContent(this.el, true);\n      }\n      // component resolution related state\n      this.pendingComponentCb = this.Component = null;\n      // transition related state\n      this.pendingRemovals = 0;\n      this.pendingRemovalCb = null;\n      // create a ref anchor\n      this.anchor = createAnchor('v-component');\n      replace(this.el, this.anchor);\n      // remove is attribute.\n      // this is removed during compilation, but because compilation is\n      // cached, when the component is used elsewhere this attribute\n      // will remain at link time.\n      this.el.removeAttribute('is');\n      this.el.removeAttribute(':is');\n      // remove ref, same as above\n      if (this.descriptor.ref) {\n        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));\n      }\n      // if static, build right now.\n      if (this.literal) {\n        this.setComponent(this.expression);\n      }\n    } else {\n      (\"development\") !== 'production' && warn('cannot mount component \"' + this.expression + '\" ' + 'on already mounted element: ' + this.el);\n    }\n  },\n\n  /**\n   * Public update, called by the watcher in the dynamic\n   * literal scenario, e.g. <component :is=\"view\">\n   */\n\n  update: function update(value) {\n    if (!this.literal) {\n      this.setComponent(value);\n    }\n  },\n\n  /**\n   * Switch dynamic components. May resolve the component\n   * asynchronously, and perform transition based on\n   * specified transition mode. Accepts a few additional\n   * arguments specifically for vue-router.\n   *\n   * The callback is called when the full transition is\n   * finished.\n   *\n   * @param {String} value\n   * @param {Function} [cb]\n   */\n\n  setComponent: function setComponent(value, cb) {\n    this.invalidatePending();\n    if (!value) {\n      // just remove current\n      this.unbuild(true);\n      this.remove(this.childVM, cb);\n      this.childVM = null;\n    } else {\n      var self = this;\n      this.resolveComponent(value, function () {\n        self.mountComponent(cb);\n      });\n    }\n  },\n\n  /**\n   * Resolve the component constructor to use when creating\n   * the child vm.\n   *\n   * @param {String|Function} value\n   * @param {Function} cb\n   */\n\n  resolveComponent: function resolveComponent(value, cb) {\n    var self = this;\n    this.pendingComponentCb = cancellable(function (Component) {\n      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);\n      self.Component = Component;\n      cb();\n    });\n    this.vm._resolveComponent(value, this.pendingComponentCb);\n  },\n\n  /**\n   * Create a new instance using the current constructor and\n   * replace the existing instance. This method doesn't care\n   * whether the new component and the old one are actually\n   * the same.\n   *\n   * @param {Function} [cb]\n   */\n\n  mountComponent: function mountComponent(cb) {\n    // actual mount\n    this.unbuild(true);\n    var self = this;\n    var activateHooks = this.Component.options.activate;\n    var cached = this.getCached();\n    var newComponent = this.build();\n    if (activateHooks && !cached) {\n      this.waitingFor = newComponent;\n      callActivateHooks(activateHooks, newComponent, function () {\n        if (self.waitingFor !== newComponent) {\n          return;\n        }\n        self.waitingFor = null;\n        self.transition(newComponent, cb);\n      });\n    } else {\n      // update ref for kept-alive component\n      if (cached) {\n        newComponent._updateRef();\n      }\n      this.transition(newComponent, cb);\n    }\n  },\n\n  /**\n   * When the component changes or unbinds before an async\n   * constructor is resolved, we need to invalidate its\n   * pending callback.\n   */\n\n  invalidatePending: function invalidatePending() {\n    if (this.pendingComponentCb) {\n      this.pendingComponentCb.cancel();\n      this.pendingComponentCb = null;\n    }\n  },\n\n  /**\n   * Instantiate/insert a new child vm.\n   * If keep alive and has cached instance, insert that\n   * instance; otherwise build a new one and cache it.\n   *\n   * @param {Object} [extraOptions]\n   * @return {Vue} - the created instance\n   */\n\n  build: function build(extraOptions) {\n    var cached = this.getCached();\n    if (cached) {\n      return cached;\n    }\n    if (this.Component) {\n      // default options\n      var options = {\n        name: this.ComponentName,\n        el: cloneNode(this.el),\n        template: this.inlineTemplate,\n        // make sure to add the child with correct parent\n        // if this is a transcluded component, its parent\n        // should be the transclusion host.\n        parent: this._host || this.vm,\n        // if no inline-template, then the compiled\n        // linker can be cached for better performance.\n        _linkerCachable: !this.inlineTemplate,\n        _ref: this.descriptor.ref,\n        _asComponent: true,\n        _isRouterView: this._isRouterView,\n        // if this is a transcluded component, context\n        // will be the common parent vm of this instance\n        // and its host.\n        _context: this.vm,\n        // if this is inside an inline v-for, the scope\n        // will be the intermediate scope created for this\n        // repeat fragment. this is used for linking props\n        // and container directives.\n        _scope: this._scope,\n        // pass in the owner fragment of this component.\n        // this is necessary so that the fragment can keep\n        // track of its contained components in order to\n        // call attach/detach hooks for them.\n        _frag: this._frag\n      };\n      // extra options\n      // in 1.0.0 this is used by vue-router only\n      /* istanbul ignore if */\n      if (extraOptions) {\n        extend(options, extraOptions);\n      }\n      var child = new this.Component(options);\n      if (this.keepAlive) {\n        this.cache[this.Component.cid] = child;\n      }\n      /* istanbul ignore if */\n      if ((\"development\") !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {\n        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);\n      }\n      return child;\n    }\n  },\n\n  /**\n   * Try to get a cached instance of the current component.\n   *\n   * @return {Vue|undefined}\n   */\n\n  getCached: function getCached() {\n    return this.keepAlive && this.cache[this.Component.cid];\n  },\n\n  /**\n   * Teardown the current child, but defers cleanup so\n   * that we can separate the destroy and removal steps.\n   *\n   * @param {Boolean} defer\n   */\n\n  unbuild: function unbuild(defer) {\n    if (this.waitingFor) {\n      if (!this.keepAlive) {\n        this.waitingFor.$destroy();\n      }\n      this.waitingFor = null;\n    }\n    var child = this.childVM;\n    if (!child || this.keepAlive) {\n      if (child) {\n        // remove ref\n        child._inactive = true;\n        child._updateRef(true);\n      }\n      return;\n    }\n    // the sole purpose of `deferCleanup` is so that we can\n    // \"deactivate\" the vm right now and perform DOM removal\n    // later.\n    child.$destroy(false, defer);\n  },\n\n  /**\n   * Remove current destroyed child and manually do\n   * the cleanup after removal.\n   *\n   * @param {Function} cb\n   */\n\n  remove: function remove(child, cb) {\n    var keepAlive = this.keepAlive;\n    if (child) {\n      // we may have a component switch when a previous\n      // component is still being transitioned out.\n      // we want to trigger only one lastest insertion cb\n      // when the existing transition finishes. (#1119)\n      this.pendingRemovals++;\n      this.pendingRemovalCb = cb;\n      var self = this;\n      child.$remove(function () {\n        self.pendingRemovals--;\n        if (!keepAlive) child._cleanup();\n        if (!self.pendingRemovals && self.pendingRemovalCb) {\n          self.pendingRemovalCb();\n          self.pendingRemovalCb = null;\n        }\n      });\n    } else if (cb) {\n      cb();\n    }\n  },\n\n  /**\n   * Actually swap the components, depending on the\n   * transition mode. Defaults to simultaneous.\n   *\n   * @param {Vue} target\n   * @param {Function} [cb]\n   */\n\n  transition: function transition(target, cb) {\n    var self = this;\n    var current = this.childVM;\n    // for devtool inspection\n    if (current) current._inactive = true;\n    target._inactive = false;\n    this.childVM = target;\n    switch (self.params.transitionMode) {\n      case 'in-out':\n        target.$before(self.anchor, function () {\n          self.remove(current, cb);\n        });\n        break;\n      case 'out-in':\n        self.remove(current, function () {\n          target.$before(self.anchor, cb);\n        });\n        break;\n      default:\n        self.remove(current);\n        target.$before(self.anchor, cb);\n    }\n  },\n\n  /**\n   * Unbind.\n   */\n\n  unbind: function unbind() {\n    this.invalidatePending();\n    // Do not defer cleanup when unbinding\n    this.unbuild();\n    // destroy all keep-alive cached instances\n    if (this.cache) {\n      for (var key in this.cache) {\n        this.cache[key].$destroy();\n      }\n      this.cache = null;\n    }\n  }\n};\n\n/**\n * Call activate hooks in order (asynchronous)\n *\n * @param {Array} hooks\n * @param {Vue} vm\n * @param {Function} cb\n */\n\nfunction callActivateHooks(hooks, vm, cb) {\n  var total = hooks.length;\n  var called = 0;\n  hooks[0].call(vm, next);\n  function next() {\n    if (++called >= total) {\n      cb();\n    } else {\n      hooks[called].call(vm, next);\n    }\n  }\n}\n\nvar propBindingModes = config._propBindingModes;\nvar empty = {};\n\n// regexes\nvar identRE$1 = /^[$_a-zA-Z]+[\\w$]*$/;\nvar settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/;\n\n/**\n * Compile props on a root element and return\n * a props link function.\n *\n * @param {Element|DocumentFragment} el\n * @param {Array} propOptions\n * @param {Vue} vm\n * @return {Function} propsLinkFn\n */\n\nfunction compileProps(el, propOptions, vm) {\n  var props = [];\n  var names = Object.keys(propOptions);\n  var i = names.length;\n  var options, name, attr, value, path, parsed, prop;\n  while (i--) {\n    name = names[i];\n    options = propOptions[name] || empty;\n\n    if ((\"development\") !== 'production' && name === '$data') {\n      warn('Do not use $data as prop.', vm);\n      continue;\n    }\n\n    // props could contain dashes, which will be\n    // interpreted as minus calculations by the parser\n    // so we need to camelize the path here\n    path = camelize(name);\n    if (!identRE$1.test(path)) {\n      (\"development\") !== 'production' && warn('Invalid prop key: \"' + name + '\". Prop keys ' + 'must be valid identifiers.', vm);\n      continue;\n    }\n\n    prop = {\n      name: name,\n      path: path,\n      options: options,\n      mode: propBindingModes.ONE_WAY,\n      raw: null\n    };\n\n    attr = hyphenate(name);\n    // first check dynamic version\n    if ((value = getBindAttr(el, attr)) === null) {\n      if ((value = getBindAttr(el, attr + '.sync')) !== null) {\n        prop.mode = propBindingModes.TWO_WAY;\n      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {\n        prop.mode = propBindingModes.ONE_TIME;\n      }\n    }\n    if (value !== null) {\n      // has dynamic binding!\n      prop.raw = value;\n      parsed = parseDirective(value);\n      value = parsed.expression;\n      prop.filters = parsed.filters;\n      // check binding type\n      if (isLiteral(value) && !parsed.filters) {\n        // for expressions containing literal numbers and\n        // booleans, there's no need to setup a prop binding,\n        // so we can optimize them as a one-time set.\n        prop.optimizedLiteral = true;\n      } else {\n        prop.dynamic = true;\n        // check non-settable path for two-way bindings\n        if ((\"development\") !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {\n          prop.mode = propBindingModes.ONE_WAY;\n          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);\n        }\n      }\n      prop.parentPath = value;\n\n      // warn required two-way\n      if ((\"development\") !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {\n        warn('Prop \"' + name + '\" expects a two-way binding type.', vm);\n      }\n    } else if ((value = getAttr(el, attr)) !== null) {\n      // has literal binding!\n      prop.raw = value;\n    } else if (true) {\n      // check possible camelCase prop usage\n      var lowerCaseName = path.toLowerCase();\n      value = /[A-Z\\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));\n      if (value) {\n        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);\n      } else if (options.required) {\n        // warn missing required\n        warn('Missing required prop: ' + name, vm);\n      }\n    }\n    // push prop\n    props.push(prop);\n  }\n  return makePropsLinkFn(props);\n}\n\n/**\n * Build a function that applies props to a vm.\n *\n * @param {Array} props\n * @return {Function} propsLinkFn\n */\n\nfunction makePropsLinkFn(props) {\n  return function propsLinkFn(vm, scope) {\n    // store resolved props info\n    vm._props = {};\n    var inlineProps = vm.$options.propsData;\n    var i = props.length;\n    var prop, path, options, value, raw;\n    while (i--) {\n      prop = props[i];\n      raw = prop.raw;\n      path = prop.path;\n      options = prop.options;\n      vm._props[path] = prop;\n      if (inlineProps && hasOwn(inlineProps, path)) {\n        initProp(vm, prop, inlineProps[path]);\n      }if (raw === null) {\n        // initialize absent prop\n        initProp(vm, prop, undefined);\n      } else if (prop.dynamic) {\n        // dynamic prop\n        if (prop.mode === propBindingModes.ONE_TIME) {\n          // one time binding\n          value = (scope || vm._context || vm).$get(prop.parentPath);\n          initProp(vm, prop, value);\n        } else {\n          if (vm._context) {\n            // dynamic binding\n            vm._bindDir({\n              name: 'prop',\n              def: propDef,\n              prop: prop\n            }, null, null, scope); // el, host, scope\n          } else {\n              // root instance\n              initProp(vm, prop, vm.$get(prop.parentPath));\n            }\n        }\n      } else if (prop.optimizedLiteral) {\n        // optimized literal, cast it and just set once\n        var stripped = stripQuotes(raw);\n        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;\n        initProp(vm, prop, value);\n      } else {\n        // string literal, but we need to cater for\n        // Boolean props with no value, or with same\n        // literal value (e.g. disabled=\"disabled\")\n        // see https://github.com/vuejs/vue-loader/issues/182\n        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;\n        initProp(vm, prop, value);\n      }\n    }\n  };\n}\n\n/**\n * Process a prop with a rawValue, applying necessary coersions,\n * default values & assertions and call the given callback with\n * processed value.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} rawValue\n * @param {Function} fn\n */\n\nfunction processPropValue(vm, prop, rawValue, fn) {\n  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);\n  var value = rawValue;\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop);\n  }\n  value = coerceProp(prop, value, vm);\n  var coerced = value !== rawValue;\n  if (!assertProp(prop, value, vm)) {\n    value = undefined;\n  }\n  if (isSimple && !coerced) {\n    withoutConversion(function () {\n      fn(value);\n    });\n  } else {\n    fn(value);\n  }\n}\n\n/**\n * Set a prop's initial value on a vm and its data object.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} value\n */\n\nfunction initProp(vm, prop, value) {\n  processPropValue(vm, prop, value, function (value) {\n    defineReactive(vm, prop.path, value);\n  });\n}\n\n/**\n * Update a prop's value on a vm.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} value\n */\n\nfunction updateProp(vm, prop, value) {\n  processPropValue(vm, prop, value, function (value) {\n    vm[prop.path] = value;\n  });\n}\n\n/**\n * Get the default value of a prop.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @return {*}\n */\n\nfunction getPropDefaultValue(vm, prop) {\n  // no default, return undefined\n  var options = prop.options;\n  if (!hasOwn(options, 'default')) {\n    // absent boolean value defaults to false\n    return options.type === Boolean ? false : undefined;\n  }\n  var def = options['default'];\n  // warn against non-factory defaults for Object & Array\n  if (isObject(def)) {\n    (\"development\") !== 'production' && warn('Invalid default value for prop \"' + prop.name + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;\n}\n\n/**\n * Assert whether a prop is valid.\n *\n * @param {Object} prop\n * @param {*} value\n * @param {Vue} vm\n */\n\nfunction assertProp(prop, value, vm) {\n  if (!prop.options.required && ( // non-required\n  prop.raw === null || // abscent\n  value == null) // null or undefined\n  ) {\n      return true;\n    }\n  var options = prop.options;\n  var type = options.type;\n  var valid = !type;\n  var expectedTypes = [];\n  if (type) {\n    if (!isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType);\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    if (true) {\n      warn('Invalid prop: type check failed for prop \"' + prop.name + '\".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);\n    }\n    return false;\n  }\n  var validator = options.validator;\n  if (validator) {\n    if (!validator(value)) {\n      (\"development\") !== 'production' && warn('Invalid prop: custom validator check failed for prop \"' + prop.name + '\".', vm);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Force parsing value with coerce option.\n *\n * @param {*} value\n * @param {Object} options\n * @return {*}\n */\n\nfunction coerceProp(prop, value, vm) {\n  var coerce = prop.options.coerce;\n  if (!coerce) {\n    return value;\n  }\n  if (typeof coerce === 'function') {\n    return coerce(value);\n  } else {\n    (\"development\") !== 'production' && warn('Invalid coerce for prop \"' + prop.name + '\": expected function, got ' + typeof coerce + '.', vm);\n    return value;\n  }\n}\n\n/**\n * Assert the type of a value\n *\n * @param {*} value\n * @param {Function} type\n * @return {Object}\n */\n\nfunction assertType(value, type) {\n  var valid;\n  var expectedType;\n  if (type === String) {\n    expectedType = 'string';\n    valid = typeof value === expectedType;\n  } else if (type === Number) {\n    expectedType = 'number';\n    valid = typeof value === expectedType;\n  } else if (type === Boolean) {\n    expectedType = 'boolean';\n    valid = typeof value === expectedType;\n  } else if (type === Function) {\n    expectedType = 'function';\n    valid = typeof value === expectedType;\n  } else if (type === Object) {\n    expectedType = 'object';\n    valid = isPlainObject(value);\n  } else if (type === Array) {\n    expectedType = 'array';\n    valid = isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n\n/**\n * Format type for output\n *\n * @param {String} type\n * @return {String}\n */\n\nfunction formatType(type) {\n  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';\n}\n\n/**\n * Format value\n *\n * @param {*} value\n * @return {String}\n */\n\nfunction formatValue(val) {\n  return Object.prototype.toString.call(val).slice(8, -1);\n}\n\nvar bindingModes = config._propBindingModes;\n\nvar propDef = {\n\n  bind: function bind() {\n    var child = this.vm;\n    var parent = child._context;\n    // passed in from compiler directly\n    var prop = this.descriptor.prop;\n    var childKey = prop.path;\n    var parentKey = prop.parentPath;\n    var twoWay = prop.mode === bindingModes.TWO_WAY;\n\n    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {\n      updateProp(child, prop, val);\n    }, {\n      twoWay: twoWay,\n      filters: prop.filters,\n      // important: props need to be observed on the\n      // v-for scope if present\n      scope: this._scope\n    });\n\n    // set the child initial value.\n    initProp(child, prop, parentWatcher.value);\n\n    // setup two-way binding\n    if (twoWay) {\n      // important: defer the child watcher creation until\n      // the created hook (after data observation)\n      var self = this;\n      child.$once('pre-hook:created', function () {\n        self.childWatcher = new Watcher(child, childKey, function (val) {\n          parentWatcher.set(val);\n        }, {\n          // ensure sync upward before parent sync down.\n          // this is necessary in cases e.g. the child\n          // mutates a prop array, then replaces it. (#1683)\n          sync: true\n        });\n      });\n    }\n  },\n\n  unbind: function unbind() {\n    this.parentWatcher.teardown();\n    if (this.childWatcher) {\n      this.childWatcher.teardown();\n    }\n  }\n};\n\nvar queue$1 = [];\nvar queued = false;\n\n/**\n * Push a job into the queue.\n *\n * @param {Function} job\n */\n\nfunction pushJob(job) {\n  queue$1.push(job);\n  if (!queued) {\n    queued = true;\n    nextTick(flush);\n  }\n}\n\n/**\n * Flush the queue, and do one forced reflow before\n * triggering transitions.\n */\n\nfunction flush() {\n  // Force layout\n  var f = document.documentElement.offsetHeight;\n  for (var i = 0; i < queue$1.length; i++) {\n    queue$1[i]();\n  }\n  queue$1 = [];\n  queued = false;\n  // dummy return, so js linters don't complain about\n  // unused variable f\n  return f;\n}\n\nvar TYPE_TRANSITION = 'transition';\nvar TYPE_ANIMATION = 'animation';\nvar transDurationProp = transitionProp + 'Duration';\nvar animDurationProp = animationProp + 'Duration';\n\n/**\n * If a just-entered element is applied the\n * leave class while its enter transition hasn't started yet,\n * and the transitioned property has the same value for both\n * enter/leave, then the leave transition will be skipped and\n * the transitionend event never fires. This function ensures\n * its callback to be called after a transition has started\n * by waiting for double raf.\n *\n * It falls back to setTimeout on devices that support CSS\n * transitions but not raf (e.g. Android 4.2 browser) - since\n * these environments are usually slow, we are giving it a\n * relatively large timeout.\n */\n\nvar raf = inBrowser && window.requestAnimationFrame;\nvar waitForTransitionStart = raf\n/* istanbul ignore next */\n? function (fn) {\n  raf(function () {\n    raf(fn);\n  });\n} : function (fn) {\n  setTimeout(fn, 50);\n};\n\n/**\n * A Transition object that encapsulates the state and logic\n * of the transition.\n *\n * @param {Element} el\n * @param {String} id\n * @param {Object} hooks\n * @param {Vue} vm\n */\nfunction Transition(el, id, hooks, vm) {\n  this.id = id;\n  this.el = el;\n  this.enterClass = hooks && hooks.enterClass || id + '-enter';\n  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';\n  this.hooks = hooks;\n  this.vm = vm;\n  // async state\n  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;\n  this.justEntered = false;\n  this.entered = this.left = false;\n  this.typeCache = {};\n  // check css transition type\n  this.type = hooks && hooks.type;\n  /* istanbul ignore if */\n  if (true) {\n    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {\n      warn('invalid CSS transition type for transition=\"' + this.id + '\": ' + this.type, vm);\n    }\n  }\n  // bind\n  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {\n    self[m] = bind(self[m], self);\n  });\n}\n\nvar p$1 = Transition.prototype;\n\n/**\n * Start an entering transition.\n *\n * 1. enter transition triggered\n * 2. call beforeEnter hook\n * 3. add enter class\n * 4. insert/show element\n * 5. call enter hook (with possible explicit js callback)\n * 6. reflow\n * 7. based on transition type:\n *    - transition:\n *        remove class now, wait for transitionend,\n *        then done if there's no explicit js callback.\n *    - animation:\n *        wait for animationend, remove class,\n *        then done if there's no explicit js callback.\n *    - no css transition:\n *        done now if there's no explicit js callback.\n * 8. wait for either done or js callback, then call\n *    afterEnter hook.\n *\n * @param {Function} op - insert/show the element\n * @param {Function} [cb]\n */\n\np$1.enter = function (op, cb) {\n  this.cancelPending();\n  this.callHook('beforeEnter');\n  this.cb = cb;\n  addClass(this.el, this.enterClass);\n  op();\n  this.entered = false;\n  this.callHookWithCb('enter');\n  if (this.entered) {\n    return; // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.enterCancelled;\n  pushJob(this.enterNextTick);\n};\n\n/**\n * The \"nextTick\" phase of an entering transition, which is\n * to be pushed into a queue and executed after a reflow so\n * that removing the class can trigger a CSS transition.\n */\n\np$1.enterNextTick = function () {\n  var _this = this;\n\n  // prevent transition skipping\n  this.justEntered = true;\n  waitForTransitionStart(function () {\n    _this.justEntered = false;\n  });\n  var enterDone = this.enterDone;\n  var type = this.getCssTransitionType(this.enterClass);\n  if (!this.pendingJsCb) {\n    if (type === TYPE_TRANSITION) {\n      // trigger transition by removing enter class now\n      removeClass(this.el, this.enterClass);\n      this.setupCssCb(transitionEndEvent, enterDone);\n    } else if (type === TYPE_ANIMATION) {\n      this.setupCssCb(animationEndEvent, enterDone);\n    } else {\n      enterDone();\n    }\n  } else if (type === TYPE_TRANSITION) {\n    removeClass(this.el, this.enterClass);\n  }\n};\n\n/**\n * The \"cleanup\" phase of an entering transition.\n */\n\np$1.enterDone = function () {\n  this.entered = true;\n  this.cancel = this.pendingJsCb = null;\n  removeClass(this.el, this.enterClass);\n  this.callHook('afterEnter');\n  if (this.cb) this.cb();\n};\n\n/**\n * Start a leaving transition.\n *\n * 1. leave transition triggered.\n * 2. call beforeLeave hook\n * 3. add leave class (trigger css transition)\n * 4. call leave hook (with possible explicit js callback)\n * 5. reflow if no explicit js callback is provided\n * 6. based on transition type:\n *    - transition or animation:\n *        wait for end event, remove class, then done if\n *        there's no explicit js callback.\n *    - no css transition:\n *        done if there's no explicit js callback.\n * 7. wait for either done or js callback, then call\n *    afterLeave hook.\n *\n * @param {Function} op - remove/hide the element\n * @param {Function} [cb]\n */\n\np$1.leave = function (op, cb) {\n  this.cancelPending();\n  this.callHook('beforeLeave');\n  this.op = op;\n  this.cb = cb;\n  addClass(this.el, this.leaveClass);\n  this.left = false;\n  this.callHookWithCb('leave');\n  if (this.left) {\n    return; // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.leaveCancelled;\n  // only need to handle leaveDone if\n  // 1. the transition is already done (synchronously called\n  //    by the user, which causes this.op set to null)\n  // 2. there's no explicit js callback\n  if (this.op && !this.pendingJsCb) {\n    // if a CSS transition leaves immediately after enter,\n    // the transitionend event never fires. therefore we\n    // detect such cases and end the leave immediately.\n    if (this.justEntered) {\n      this.leaveDone();\n    } else {\n      pushJob(this.leaveNextTick);\n    }\n  }\n};\n\n/**\n * The \"nextTick\" phase of a leaving transition.\n */\n\np$1.leaveNextTick = function () {\n  var type = this.getCssTransitionType(this.leaveClass);\n  if (type) {\n    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;\n    this.setupCssCb(event, this.leaveDone);\n  } else {\n    this.leaveDone();\n  }\n};\n\n/**\n * The \"cleanup\" phase of a leaving transition.\n */\n\np$1.leaveDone = function () {\n  this.left = true;\n  this.cancel = this.pendingJsCb = null;\n  this.op();\n  removeClass(this.el, this.leaveClass);\n  this.callHook('afterLeave');\n  if (this.cb) this.cb();\n  this.op = null;\n};\n\n/**\n * Cancel any pending callbacks from a previously running\n * but not finished transition.\n */\n\np$1.cancelPending = function () {\n  this.op = this.cb = null;\n  var hasPending = false;\n  if (this.pendingCssCb) {\n    hasPending = true;\n    off(this.el, this.pendingCssEvent, this.pendingCssCb);\n    this.pendingCssEvent = this.pendingCssCb = null;\n  }\n  if (this.pendingJsCb) {\n    hasPending = true;\n    this.pendingJsCb.cancel();\n    this.pendingJsCb = null;\n  }\n  if (hasPending) {\n    removeClass(this.el, this.enterClass);\n    removeClass(this.el, this.leaveClass);\n  }\n  if (this.cancel) {\n    this.cancel.call(this.vm, this.el);\n    this.cancel = null;\n  }\n};\n\n/**\n * Call a user-provided synchronous hook function.\n *\n * @param {String} type\n */\n\np$1.callHook = function (type) {\n  if (this.hooks && this.hooks[type]) {\n    this.hooks[type].call(this.vm, this.el);\n  }\n};\n\n/**\n * Call a user-provided, potentially-async hook function.\n * We check for the length of arguments to see if the hook\n * expects a `done` callback. If true, the transition's end\n * will be determined by when the user calls that callback;\n * otherwise, the end is determined by the CSS transition or\n * animation.\n *\n * @param {String} type\n */\n\np$1.callHookWithCb = function (type) {\n  var hook = this.hooks && this.hooks[type];\n  if (hook) {\n    if (hook.length > 1) {\n      this.pendingJsCb = cancellable(this[type + 'Done']);\n    }\n    hook.call(this.vm, this.el, this.pendingJsCb);\n  }\n};\n\n/**\n * Get an element's transition type based on the\n * calculated styles.\n *\n * @param {String} className\n * @return {Number}\n */\n\np$1.getCssTransitionType = function (className) {\n  /* istanbul ignore if */\n  if (!transitionEndEvent ||\n  // skip CSS transitions if page is not visible -\n  // this solves the issue of transitionend events not\n  // firing until the page is visible again.\n  // pageVisibility API is supported in IE10+, same as\n  // CSS transitions.\n  document.hidden ||\n  // explicit js-only transition\n  this.hooks && this.hooks.css === false ||\n  // element is hidden\n  isHidden(this.el)) {\n    return;\n  }\n  var type = this.type || this.typeCache[className];\n  if (type) return type;\n  var inlineStyles = this.el.style;\n  var computedStyles = window.getComputedStyle(this.el);\n  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];\n  if (transDuration && transDuration !== '0s') {\n    type = TYPE_TRANSITION;\n  } else {\n    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];\n    if (animDuration && animDuration !== '0s') {\n      type = TYPE_ANIMATION;\n    }\n  }\n  if (type) {\n    this.typeCache[className] = type;\n  }\n  return type;\n};\n\n/**\n * Setup a CSS transitionend/animationend callback.\n *\n * @param {String} event\n * @param {Function} cb\n */\n\np$1.setupCssCb = function (event, cb) {\n  this.pendingCssEvent = event;\n  var self = this;\n  var el = this.el;\n  var onEnd = this.pendingCssCb = function (e) {\n    if (e.target === el) {\n      off(el, event, onEnd);\n      self.pendingCssEvent = self.pendingCssCb = null;\n      if (!self.pendingJsCb && cb) {\n        cb();\n      }\n    }\n  };\n  on(el, event, onEnd);\n};\n\n/**\n * Check if an element is hidden - in that case we can just\n * skip the transition alltogether.\n *\n * @param {Element} el\n * @return {Boolean}\n */\n\nfunction isHidden(el) {\n  if (/svg$/.test(el.namespaceURI)) {\n    // SVG elements do not have offset(Width|Height)\n    // so we need to check the client rect\n    var rect = el.getBoundingClientRect();\n    return !(rect.width || rect.height);\n  } else {\n    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n  }\n}\n\nvar transition$1 = {\n\n  priority: TRANSITION,\n\n  update: function update(id, oldId) {\n    var el = this.el;\n    // resolve on owner vm\n    var hooks = resolveAsset(this.vm.$options, 'transitions', id);\n    id = id || 'v';\n    oldId = oldId || 'v';\n    el.__v_trans = new Transition(el, id, hooks, this.vm);\n    removeClass(el, oldId + '-transition');\n    addClass(el, id + '-transition');\n  }\n};\n\nvar internalDirectives = {\n  style: style,\n  'class': vClass,\n  component: component,\n  prop: propDef,\n  transition: transition$1\n};\n\n// special binding prefixes\nvar bindRE = /^v-bind:|^:/;\nvar onRE = /^v-on:|^@/;\nvar dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;\nvar modifierRE = /\\.[^\\.]+/g;\nvar transitionRE = /^(v-bind:|:)?transition$/;\n\n// default directive priority\nvar DEFAULT_PRIORITY = 1000;\nvar DEFAULT_TERMINAL_PRIORITY = 2000;\n\n/**\n * Compile a template and return a reusable composite link\n * function, which recursively contains more link functions\n * inside. This top level compile function would normally\n * be called on instance root nodes, but can also be used\n * for partial compilation if the partial argument is true.\n *\n * The returned composite link function, when called, will\n * return an unlink function that tearsdown all directives\n * created during the linking phase.\n *\n * @param {Element|DocumentFragment} el\n * @param {Object} options\n * @param {Boolean} partial\n * @return {Function}\n */\n\nfunction compile(el, options, partial) {\n  // link function for the node itself.\n  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;\n  // link function for the childNodes\n  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;\n\n  /**\n   * A composite linker function to be called on a already\n   * compiled piece of DOM, which instantiates all directive\n   * instances.\n   *\n   * @param {Vue} vm\n   * @param {Element|DocumentFragment} el\n   * @param {Vue} [host] - host vm of transcluded content\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - link context fragment\n   * @return {Function|undefined}\n   */\n\n  return function compositeLinkFn(vm, el, host, scope, frag) {\n    // cache childNodes before linking parent, fix #657\n    var childNodes = toArray(el.childNodes);\n    // link\n    var dirs = linkAndCapture(function compositeLinkCapturer() {\n      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\n      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);\n    }, vm);\n    return makeUnlinkFn(vm, dirs);\n  };\n}\n\n/**\n * Apply a linker to a vm/element pair and capture the\n * directives created during the process.\n *\n * @param {Function} linker\n * @param {Vue} vm\n */\n\nfunction linkAndCapture(linker, vm) {\n  /* istanbul ignore if */\n  if (false) {\n    // reset directives before every capture in production\n    // mode, so that when unlinking we don't need to splice\n    // them out (which turns out to be a perf hit).\n    // they are kept in development mode because they are\n    // useful for Vue's own tests.\n    vm._directives = [];\n  }\n  var originalDirCount = vm._directives.length;\n  linker();\n  var dirs = vm._directives.slice(originalDirCount);\n  dirs.sort(directiveComparator);\n  for (var i = 0, l = dirs.length; i < l; i++) {\n    dirs[i]._bind();\n  }\n  return dirs;\n}\n\n/**\n * Directive priority sort comparator\n *\n * @param {Object} a\n * @param {Object} b\n */\n\nfunction directiveComparator(a, b) {\n  a = a.descriptor.def.priority || DEFAULT_PRIORITY;\n  b = b.descriptor.def.priority || DEFAULT_PRIORITY;\n  return a > b ? -1 : a === b ? 0 : 1;\n}\n\n/**\n * Linker functions return an unlink function that\n * tearsdown all directives instances generated during\n * the process.\n *\n * We create unlink functions with only the necessary\n * information to avoid retaining additional closures.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Vue} [context]\n * @param {Array} [contextDirs]\n * @return {Function}\n */\n\nfunction makeUnlinkFn(vm, dirs, context, contextDirs) {\n  function unlink(destroying) {\n    teardownDirs(vm, dirs, destroying);\n    if (context && contextDirs) {\n      teardownDirs(context, contextDirs);\n    }\n  }\n  // expose linked directives\n  unlink.dirs = dirs;\n  return unlink;\n}\n\n/**\n * Teardown partial linked directives.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Boolean} destroying\n */\n\nfunction teardownDirs(vm, dirs, destroying) {\n  var i = dirs.length;\n  while (i--) {\n    dirs[i]._teardown();\n    if ((\"development\") !== 'production' && !destroying) {\n      vm._directives.$remove(dirs[i]);\n    }\n  }\n}\n\n/**\n * Compile link props on an instance.\n *\n * @param {Vue} vm\n * @param {Element} el\n * @param {Object} props\n * @param {Object} [scope]\n * @return {Function}\n */\n\nfunction compileAndLinkProps(vm, el, props, scope) {\n  var propsLinkFn = compileProps(el, props, vm);\n  var propDirs = linkAndCapture(function () {\n    propsLinkFn(vm, scope);\n  }, vm);\n  return makeUnlinkFn(vm, propDirs);\n}\n\n/**\n * Compile the root element of an instance.\n *\n * 1. attrs on context container (context scope)\n * 2. attrs on the component template root node, if\n *    replace:true (child scope)\n *\n * If this is a fragment instance, we only need to compile 1.\n *\n * @param {Element} el\n * @param {Object} options\n * @param {Object} contextOptions\n * @return {Function}\n */\n\nfunction compileRoot(el, options, contextOptions) {\n  var containerAttrs = options._containerAttrs;\n  var replacerAttrs = options._replacerAttrs;\n  var contextLinkFn, replacerLinkFn;\n\n  // only need to compile other attributes for\n  // non-fragment instances\n  if (el.nodeType !== 11) {\n    // for components, container and replacer need to be\n    // compiled separately and linked in different scopes.\n    if (options._asComponent) {\n      // 2. container attributes\n      if (containerAttrs && contextOptions) {\n        contextLinkFn = compileDirectives(containerAttrs, contextOptions);\n      }\n      if (replacerAttrs) {\n        // 3. replacer attributes\n        replacerLinkFn = compileDirectives(replacerAttrs, options);\n      }\n    } else {\n      // non-component, just compile as a normal element.\n      replacerLinkFn = compileDirectives(el.attributes, options);\n    }\n  } else if ((\"development\") !== 'production' && containerAttrs) {\n    // warn container directives for fragment instances\n    var names = containerAttrs.filter(function (attr) {\n      // allow vue-loader/vueify scoped css attributes\n      return attr.name.indexOf('_v-') < 0 &&\n      // allow event listeners\n      !onRE.test(attr.name) &&\n      // allow slots\n      attr.name !== 'slot';\n    }).map(function (attr) {\n      return '\"' + attr.name + '\"';\n    });\n    if (names.length) {\n      var plural = names.length > 1;\n      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');\n    }\n  }\n\n  options._containerAttrs = options._replacerAttrs = null;\n  return function rootLinkFn(vm, el, scope) {\n    // link context scope dirs\n    var context = vm._context;\n    var contextDirs;\n    if (context && contextLinkFn) {\n      contextDirs = linkAndCapture(function () {\n        contextLinkFn(context, el, null, scope);\n      }, context);\n    }\n\n    // link self\n    var selfDirs = linkAndCapture(function () {\n      if (replacerLinkFn) replacerLinkFn(vm, el);\n    }, vm);\n\n    // return the unlink function that tearsdown context\n    // container directives.\n    return makeUnlinkFn(vm, selfDirs, context, contextDirs);\n  };\n}\n\n/**\n * Compile a node and return a nodeLinkFn based on the\n * node type.\n *\n * @param {Node} node\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileNode(node, options) {\n  var type = node.nodeType;\n  if (type === 1 && !isScript(node)) {\n    return compileElement(node, options);\n  } else if (type === 3 && node.data.trim()) {\n    return compileTextNode(node, options);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Compile an element and return a nodeLinkFn.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileElement(el, options) {\n  // preprocess textareas.\n  // textarea treats its text content as the initial value.\n  // just bind it as an attr directive for value.\n  if (el.tagName === 'TEXTAREA') {\n    var tokens = parseText(el.value);\n    if (tokens) {\n      el.setAttribute(':value', tokensToExp(tokens));\n      el.value = '';\n    }\n  }\n  var linkFn;\n  var hasAttrs = el.hasAttributes();\n  var attrs = hasAttrs && toArray(el.attributes);\n  // check terminal directives (for & if)\n  if (hasAttrs) {\n    linkFn = checkTerminalDirectives(el, attrs, options);\n  }\n  // check element directives\n  if (!linkFn) {\n    linkFn = checkElementDirectives(el, options);\n  }\n  // check component\n  if (!linkFn) {\n    linkFn = checkComponent(el, options);\n  }\n  // normal directives\n  if (!linkFn && hasAttrs) {\n    linkFn = compileDirectives(attrs, options);\n  }\n  return linkFn;\n}\n\n/**\n * Compile a textNode and return a nodeLinkFn.\n *\n * @param {TextNode} node\n * @param {Object} options\n * @return {Function|null} textNodeLinkFn\n */\n\nfunction compileTextNode(node, options) {\n  // skip marked text nodes\n  if (node._skip) {\n    return removeText;\n  }\n\n  var tokens = parseText(node.wholeText);\n  if (!tokens) {\n    return null;\n  }\n\n  // mark adjacent text nodes as skipped,\n  // because we are using node.wholeText to compile\n  // all adjacent text nodes together. This fixes\n  // issues in IE where sometimes it splits up a single\n  // text node into multiple ones.\n  var next = node.nextSibling;\n  while (next && next.nodeType === 3) {\n    next._skip = true;\n    next = next.nextSibling;\n  }\n\n  var frag = document.createDocumentFragment();\n  var el, token;\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);\n    frag.appendChild(el);\n  }\n  return makeTextNodeLinkFn(tokens, frag, options);\n}\n\n/**\n * Linker for an skipped text node.\n *\n * @param {Vue} vm\n * @param {Text} node\n */\n\nfunction removeText(vm, node) {\n  remove(node);\n}\n\n/**\n * Process a single text token.\n *\n * @param {Object} token\n * @param {Object} options\n * @return {Node}\n */\n\nfunction processTextToken(token, options) {\n  var el;\n  if (token.oneTime) {\n    el = document.createTextNode(token.value);\n  } else {\n    if (token.html) {\n      el = document.createComment('v-html');\n      setTokenType('html');\n    } else {\n      // IE will clean up empty textNodes during\n      // frag.cloneNode(true), so we have to give it\n      // something here...\n      el = document.createTextNode(' ');\n      setTokenType('text');\n    }\n  }\n  function setTokenType(type) {\n    if (token.descriptor) return;\n    var parsed = parseDirective(token.value);\n    token.descriptor = {\n      name: type,\n      def: directives[type],\n      expression: parsed.expression,\n      filters: parsed.filters\n    };\n  }\n  return el;\n}\n\n/**\n * Build a function that processes a textNode.\n *\n * @param {Array<Object>} tokens\n * @param {DocumentFragment} frag\n */\n\nfunction makeTextNodeLinkFn(tokens, frag) {\n  return function textNodeLinkFn(vm, el, host, scope) {\n    var fragClone = frag.cloneNode(true);\n    var childNodes = toArray(fragClone.childNodes);\n    var token, value, node;\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      token = tokens[i];\n      value = token.value;\n      if (token.tag) {\n        node = childNodes[i];\n        if (token.oneTime) {\n          value = (scope || vm).$eval(value);\n          if (token.html) {\n            replace(node, parseTemplate(value, true));\n          } else {\n            node.data = _toString(value);\n          }\n        } else {\n          vm._bindDir(token.descriptor, node, host, scope);\n        }\n      }\n    }\n    replace(el, fragClone);\n  };\n}\n\n/**\n * Compile a node list and return a childLinkFn.\n *\n * @param {NodeList} nodeList\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction compileNodeList(nodeList, options) {\n  var linkFns = [];\n  var nodeLinkFn, childLinkFn, node;\n  for (var i = 0, l = nodeList.length; i < l; i++) {\n    node = nodeList[i];\n    nodeLinkFn = compileNode(node, options);\n    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;\n    linkFns.push(nodeLinkFn, childLinkFn);\n  }\n  return linkFns.length ? makeChildLinkFn(linkFns) : null;\n}\n\n/**\n * Make a child link function for a node's childNodes.\n *\n * @param {Array<Function>} linkFns\n * @return {Function} childLinkFn\n */\n\nfunction makeChildLinkFn(linkFns) {\n  return function childLinkFn(vm, nodes, host, scope, frag) {\n    var node, nodeLinkFn, childrenLinkFn;\n    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n      node = nodes[n];\n      nodeLinkFn = linkFns[i++];\n      childrenLinkFn = linkFns[i++];\n      // cache childNodes before linking parent, fix #657\n      var childNodes = toArray(node.childNodes);\n      if (nodeLinkFn) {\n        nodeLinkFn(vm, node, host, scope, frag);\n      }\n      if (childrenLinkFn) {\n        childrenLinkFn(vm, childNodes, host, scope, frag);\n      }\n    }\n  };\n}\n\n/**\n * Check for element directives (custom elements that should\n * be resovled as terminal directives).\n *\n * @param {Element} el\n * @param {Object} options\n */\n\nfunction checkElementDirectives(el, options) {\n  var tag = el.tagName.toLowerCase();\n  if (commonTagRE.test(tag)) {\n    return;\n  }\n  var def = resolveAsset(options, 'elementDirectives', tag);\n  if (def) {\n    return makeTerminalNodeLinkFn(el, tag, '', options, def);\n  }\n}\n\n/**\n * Check if an element is a component. If yes, return\n * a component link function.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction checkComponent(el, options) {\n  var component = checkComponentAttr(el, options);\n  if (component) {\n    var ref = findRef(el);\n    var descriptor = {\n      name: 'component',\n      ref: ref,\n      expression: component.id,\n      def: internalDirectives.component,\n      modifiers: {\n        literal: !component.dynamic\n      }\n    };\n    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {\n      if (ref) {\n        defineReactive((scope || vm).$refs, ref, null);\n      }\n      vm._bindDir(descriptor, el, host, scope, frag);\n    };\n    componentLinkFn.terminal = true;\n    return componentLinkFn;\n  }\n}\n\n/**\n * Check an element for terminal directives in fixed order.\n * If it finds one, return a terminal link function.\n *\n * @param {Element} el\n * @param {Array} attrs\n * @param {Object} options\n * @return {Function} terminalLinkFn\n */\n\nfunction checkTerminalDirectives(el, attrs, options) {\n  // skip v-pre\n  if (getAttr(el, 'v-pre') !== null) {\n    return skip;\n  }\n  // skip v-else block, but only if following v-if\n  if (el.hasAttribute('v-else')) {\n    var prev = el.previousElementSibling;\n    if (prev && prev.hasAttribute('v-if')) {\n      return skip;\n    }\n  }\n\n  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;\n  for (var i = 0, j = attrs.length; i < j; i++) {\n    attr = attrs[i];\n    name = attr.name.replace(modifierRE, '');\n    if (matched = name.match(dirAttrRE)) {\n      def = resolveAsset(options, 'directives', matched[1]);\n      if (def && def.terminal) {\n        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {\n          termDef = def;\n          rawName = attr.name;\n          modifiers = parseModifiers(attr.name);\n          value = attr.value;\n          dirName = matched[1];\n          arg = matched[2];\n        }\n      }\n    }\n  }\n\n  if (termDef) {\n    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);\n  }\n}\n\nfunction skip() {}\nskip.terminal = true;\n\n/**\n * Build a node link function for a terminal directive.\n * A terminal link function terminates the current\n * compilation recursion and handles compilation of the\n * subtree in the directive.\n *\n * @param {Element} el\n * @param {String} dirName\n * @param {String} value\n * @param {Object} options\n * @param {Object} def\n * @param {String} [rawName]\n * @param {String} [arg]\n * @param {Object} [modifiers]\n * @return {Function} terminalLinkFn\n */\n\nfunction makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {\n  var parsed = parseDirective(value);\n  var descriptor = {\n    name: dirName,\n    arg: arg,\n    expression: parsed.expression,\n    filters: parsed.filters,\n    raw: value,\n    attr: rawName,\n    modifiers: modifiers,\n    def: def\n  };\n  // check ref for v-for and router-view\n  if (dirName === 'for' || dirName === 'router-view') {\n    descriptor.ref = findRef(el);\n  }\n  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\n    if (descriptor.ref) {\n      defineReactive((scope || vm).$refs, descriptor.ref, null);\n    }\n    vm._bindDir(descriptor, el, host, scope, frag);\n  };\n  fn.terminal = true;\n  return fn;\n}\n\n/**\n * Compile the directives on an element and return a linker.\n *\n * @param {Array|NamedNodeMap} attrs\n * @param {Object} options\n * @return {Function}\n */\n\nfunction compileDirectives(attrs, options) {\n  var i = attrs.length;\n  var dirs = [];\n  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;\n  while (i--) {\n    attr = attrs[i];\n    name = rawName = attr.name;\n    value = rawValue = attr.value;\n    tokens = parseText(value);\n    // reset arg\n    arg = null;\n    // check modifiers\n    modifiers = parseModifiers(name);\n    name = name.replace(modifierRE, '');\n\n    // attribute interpolations\n    if (tokens) {\n      value = tokensToExp(tokens);\n      arg = name;\n      pushDir('bind', directives.bind, tokens);\n      // warn against mixing mustaches with v-bind\n      if (true) {\n        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {\n          return attr.name === ':class' || attr.name === 'v-bind:class';\n        })) {\n          warn('class=\"' + rawValue + '\": Do not mix mustache interpolation ' + 'and v-bind for \"class\" on the same element. Use one or the other.', options);\n        }\n      }\n    } else\n\n      // special attribute: transition\n      if (transitionRE.test(name)) {\n        modifiers.literal = !bindRE.test(name);\n        pushDir('transition', internalDirectives.transition);\n      } else\n\n        // event handlers\n        if (onRE.test(name)) {\n          arg = name.replace(onRE, '');\n          pushDir('on', directives.on);\n        } else\n\n          // attribute bindings\n          if (bindRE.test(name)) {\n            dirName = name.replace(bindRE, '');\n            if (dirName === 'style' || dirName === 'class') {\n              pushDir(dirName, internalDirectives[dirName]);\n            } else {\n              arg = dirName;\n              pushDir('bind', directives.bind);\n            }\n          } else\n\n            // normal directives\n            if (matched = name.match(dirAttrRE)) {\n              dirName = matched[1];\n              arg = matched[2];\n\n              // skip v-else (when used with v-show)\n              if (dirName === 'else') {\n                continue;\n              }\n\n              dirDef = resolveAsset(options, 'directives', dirName, true);\n              if (dirDef) {\n                pushDir(dirName, dirDef);\n              }\n            }\n  }\n\n  /**\n   * Push a directive.\n   *\n   * @param {String} dirName\n   * @param {Object|Function} def\n   * @param {Array} [interpTokens]\n   */\n\n  function pushDir(dirName, def, interpTokens) {\n    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);\n    var parsed = !hasOneTimeToken && parseDirective(value);\n    dirs.push({\n      name: dirName,\n      attr: rawName,\n      raw: rawValue,\n      def: def,\n      arg: arg,\n      modifiers: modifiers,\n      // conversion from interpolation strings with one-time token\n      // to expression is differed until directive bind time so that we\n      // have access to the actual vm context for one-time bindings.\n      expression: parsed && parsed.expression,\n      filters: parsed && parsed.filters,\n      interp: interpTokens,\n      hasOneTime: hasOneTimeToken\n    });\n  }\n\n  if (dirs.length) {\n    return makeNodeLinkFn(dirs);\n  }\n}\n\n/**\n * Parse modifiers from directive attribute name.\n *\n * @param {String} name\n * @return {Object}\n */\n\nfunction parseModifiers(name) {\n  var res = Object.create(null);\n  var match = name.match(modifierRE);\n  if (match) {\n    var i = match.length;\n    while (i--) {\n      res[match[i].slice(1)] = true;\n    }\n  }\n  return res;\n}\n\n/**\n * Build a link function for all directives on a single node.\n *\n * @param {Array} directives\n * @return {Function} directivesLinkFn\n */\n\nfunction makeNodeLinkFn(directives) {\n  return function nodeLinkFn(vm, el, host, scope, frag) {\n    // reverse apply because it's sorted low to high\n    var i = directives.length;\n    while (i--) {\n      vm._bindDir(directives[i], el, host, scope, frag);\n    }\n  };\n}\n\n/**\n * Check if an interpolation string contains one-time tokens.\n *\n * @param {Array} tokens\n * @return {Boolean}\n */\n\nfunction hasOneTime(tokens) {\n  var i = tokens.length;\n  while (i--) {\n    if (tokens[i].oneTime) return true;\n  }\n}\n\nfunction isScript(el) {\n  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');\n}\n\nvar specialCharRE = /[^\\w\\-:\\.]/;\n\n/**\n * Process an element or a DocumentFragment based on a\n * instance option object. This allows us to transclude\n * a template node/fragment before the instance is created,\n * so the processed fragment can then be cloned and reused\n * in v-for.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nfunction transclude(el, options) {\n  // extract container attributes to pass them down\n  // to compiler, because they need to be compiled in\n  // parent scope. we are mutating the options object here\n  // assuming the same object will be used for compile\n  // right after this.\n  if (options) {\n    options._containerAttrs = extractAttrs(el);\n  }\n  // for template tags, what we want is its content as\n  // a documentFragment (for fragment instances)\n  if (isTemplate(el)) {\n    el = parseTemplate(el);\n  }\n  if (options) {\n    if (options._asComponent && !options.template) {\n      options.template = '<slot></slot>';\n    }\n    if (options.template) {\n      options._content = extractContent(el);\n      el = transcludeTemplate(el, options);\n    }\n  }\n  if (isFragment(el)) {\n    // anchors for fragment instance\n    // passing in `persist: true` to avoid them being\n    // discarded by IE during template cloning\n    prepend(createAnchor('v-start', true), el);\n    el.appendChild(createAnchor('v-end', true));\n  }\n  return el;\n}\n\n/**\n * Process the template option.\n * If the replace option is true this will swap the $el.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nfunction transcludeTemplate(el, options) {\n  var template = options.template;\n  var frag = parseTemplate(template, true);\n  if (frag) {\n    var replacer = frag.firstChild;\n    var tag = replacer.tagName && replacer.tagName.toLowerCase();\n    if (options.replace) {\n      /* istanbul ignore if */\n      if (el === document.body) {\n        (\"development\") !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');\n      }\n      // there are many cases where the instance must\n      // become a fragment instance: basically anything that\n      // can create more than 1 root nodes.\n      if (\n      // multi-children template\n      frag.childNodes.length > 1 ||\n      // non-element template\n      replacer.nodeType !== 1 ||\n      // single nested component\n      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||\n      // element directive\n      resolveAsset(options, 'elementDirectives', tag) ||\n      // for block\n      replacer.hasAttribute('v-for') ||\n      // if block\n      replacer.hasAttribute('v-if')) {\n        return frag;\n      } else {\n        options._replacerAttrs = extractAttrs(replacer);\n        mergeAttrs(el, replacer);\n        return replacer;\n      }\n    } else {\n      el.appendChild(frag);\n      return el;\n    }\n  } else {\n    (\"development\") !== 'production' && warn('Invalid template option: ' + template);\n  }\n}\n\n/**\n * Helper to extract a component container's attributes\n * into a plain object array.\n *\n * @param {Element} el\n * @return {Array}\n */\n\nfunction extractAttrs(el) {\n  if (el.nodeType === 1 && el.hasAttributes()) {\n    return toArray(el.attributes);\n  }\n}\n\n/**\n * Merge the attributes of two elements, and make sure\n * the class names are merged properly.\n *\n * @param {Element} from\n * @param {Element} to\n */\n\nfunction mergeAttrs(from, to) {\n  var attrs = from.attributes;\n  var i = attrs.length;\n  var name, value;\n  while (i--) {\n    name = attrs[i].name;\n    value = attrs[i].value;\n    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n      to.setAttribute(name, value);\n    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {\n      value.split(/\\s+/).forEach(function (cls) {\n        addClass(to, cls);\n      });\n    }\n  }\n}\n\n/**\n * Scan and determine slot content distribution.\n * We do this during transclusion instead at compile time so that\n * the distribution is decoupled from the compilation order of\n * the slots.\n *\n * @param {Element|DocumentFragment} template\n * @param {Element} content\n * @param {Vue} vm\n */\n\nfunction resolveSlots(vm, content) {\n  if (!content) {\n    return;\n  }\n  var contents = vm._slotContents = Object.create(null);\n  var el, name;\n  for (var i = 0, l = content.children.length; i < l; i++) {\n    el = content.children[i];\n    /* eslint-disable no-cond-assign */\n    if (name = el.getAttribute('slot')) {\n      (contents[name] || (contents[name] = [])).push(el);\n    }\n    /* eslint-enable no-cond-assign */\n    if ((\"development\") !== 'production' && getBindAttr(el, 'slot')) {\n      warn('The \"slot\" attribute must be static.', vm.$parent);\n    }\n  }\n  for (name in contents) {\n    contents[name] = extractFragment(contents[name], content);\n  }\n  if (content.hasChildNodes()) {\n    var nodes = content.childNodes;\n    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {\n      return;\n    }\n    contents['default'] = extractFragment(content.childNodes, content);\n  }\n}\n\n/**\n * Extract qualified content nodes from a node list.\n *\n * @param {NodeList} nodes\n * @return {DocumentFragment}\n */\n\nfunction extractFragment(nodes, parent) {\n  var frag = document.createDocumentFragment();\n  nodes = toArray(nodes);\n  for (var i = 0, l = nodes.length; i < l; i++) {\n    var node = nodes[i];\n    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {\n      parent.removeChild(node);\n      node = parseTemplate(node, true);\n    }\n    frag.appendChild(node);\n  }\n  return frag;\n}\n\n\n\nvar compiler = Object.freeze({\n\tcompile: compile,\n\tcompileAndLinkProps: compileAndLinkProps,\n\tcompileRoot: compileRoot,\n\ttransclude: transclude,\n\tresolveSlots: resolveSlots\n});\n\nfunction stateMixin (Vue) {\n  /**\n   * Accessor for `$data` property, since setting $data\n   * requires observing the new object and updating\n   * proxied properties.\n   */\n\n  Object.defineProperty(Vue.prototype, '$data', {\n    get: function get() {\n      return this._data;\n    },\n    set: function set(newData) {\n      if (newData !== this._data) {\n        this._setData(newData);\n      }\n    }\n  });\n\n  /**\n   * Setup the scope of an instance, which contains:\n   * - observed data\n   * - computed properties\n   * - user methods\n   * - meta properties\n   */\n\n  Vue.prototype._initState = function () {\n    this._initProps();\n    this._initMeta();\n    this._initMethods();\n    this._initData();\n    this._initComputed();\n  };\n\n  /**\n   * Initialize props.\n   */\n\n  Vue.prototype._initProps = function () {\n    var options = this.$options;\n    var el = options.el;\n    var props = options.props;\n    if (props && !el) {\n      (\"development\") !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);\n    }\n    // make sure to convert string selectors into element now\n    el = options.el = query(el);\n    this._propsUnlinkFn = el && el.nodeType === 1 && props\n    // props must be linked in proper scope if inside v-for\n    ? compileAndLinkProps(this, el, props, this._scope) : null;\n  };\n\n  /**\n   * Initialize the data.\n   */\n\n  Vue.prototype._initData = function () {\n    var dataFn = this.$options.data;\n    var data = this._data = dataFn ? dataFn() : {};\n    if (!isPlainObject(data)) {\n      data = {};\n      (\"development\") !== 'production' && warn('data functions should return an object.', this);\n    }\n    var props = this._props;\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var i, key;\n    i = keys.length;\n    while (i--) {\n      key = keys[i];\n      // there are two scenarios where we can proxy a data key:\n      // 1. it's not already defined as a prop\n      // 2. it's provided via a instantiation option AND there are no\n      //    template prop present\n      if (!props || !hasOwn(props, key)) {\n        this._proxy(key);\n      } else if (true) {\n        warn('Data field \"' + key + '\" is already defined ' + 'as a prop. To provide default value for a prop, use the \"default\" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the \"propsData\" option.', this);\n      }\n    }\n    // observe data\n    observe(data, this);\n  };\n\n  /**\n   * Swap the instance's $data. Called in $data's setter.\n   *\n   * @param {Object} newData\n   */\n\n  Vue.prototype._setData = function (newData) {\n    newData = newData || {};\n    var oldData = this._data;\n    this._data = newData;\n    var keys, key, i;\n    // unproxy keys not present in new data\n    keys = Object.keys(oldData);\n    i = keys.length;\n    while (i--) {\n      key = keys[i];\n      if (!(key in newData)) {\n        this._unproxy(key);\n      }\n    }\n    // proxy keys not already proxied,\n    // and trigger change for changed values\n    keys = Object.keys(newData);\n    i = keys.length;\n    while (i--) {\n      key = keys[i];\n      if (!hasOwn(this, key)) {\n        // new property\n        this._proxy(key);\n      }\n    }\n    oldData.__ob__.removeVm(this);\n    observe(newData, this);\n    this._digest();\n  };\n\n  /**\n   * Proxy a property, so that\n   * vm.prop === vm._data.prop\n   *\n   * @param {String} key\n   */\n\n  Vue.prototype._proxy = function (key) {\n    if (!isReserved(key)) {\n      // need to store ref to self here\n      // because these getter/setters might\n      // be called by child scopes via\n      // prototype inheritance.\n      var self = this;\n      Object.defineProperty(self, key, {\n        configurable: true,\n        enumerable: true,\n        get: function proxyGetter() {\n          return self._data[key];\n        },\n        set: function proxySetter(val) {\n          self._data[key] = val;\n        }\n      });\n    }\n  };\n\n  /**\n   * Unproxy a property.\n   *\n   * @param {String} key\n   */\n\n  Vue.prototype._unproxy = function (key) {\n    if (!isReserved(key)) {\n      delete this[key];\n    }\n  };\n\n  /**\n   * Force update on every watcher in scope.\n   */\n\n  Vue.prototype._digest = function () {\n    for (var i = 0, l = this._watchers.length; i < l; i++) {\n      this._watchers[i].update(true); // shallow updates\n    }\n  };\n\n  /**\n   * Setup computed properties. They are essentially\n   * special getter/setters\n   */\n\n  function noop() {}\n  Vue.prototype._initComputed = function () {\n    var computed = this.$options.computed;\n    if (computed) {\n      for (var key in computed) {\n        var userDef = computed[key];\n        var def = {\n          enumerable: true,\n          configurable: true\n        };\n        if (typeof userDef === 'function') {\n          def.get = makeComputedGetter(userDef, this);\n          def.set = noop;\n        } else {\n          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;\n          def.set = userDef.set ? bind(userDef.set, this) : noop;\n        }\n        Object.defineProperty(this, key, def);\n      }\n    }\n  };\n\n  function makeComputedGetter(getter, owner) {\n    var watcher = new Watcher(owner, getter, null, {\n      lazy: true\n    });\n    return function computedGetter() {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value;\n    };\n  }\n\n  /**\n   * Setup instance methods. Methods must be bound to the\n   * instance since they might be passed down as a prop to\n   * child components.\n   */\n\n  Vue.prototype._initMethods = function () {\n    var methods = this.$options.methods;\n    if (methods) {\n      for (var key in methods) {\n        this[key] = bind(methods[key], this);\n      }\n    }\n  };\n\n  /**\n   * Initialize meta information like $index, $key & $value.\n   */\n\n  Vue.prototype._initMeta = function () {\n    var metas = this.$options._meta;\n    if (metas) {\n      for (var key in metas) {\n        defineReactive(this, key, metas[key]);\n      }\n    }\n  };\n}\n\nvar eventRE = /^v-on:|^@/;\n\nfunction eventsMixin (Vue) {\n  /**\n   * Setup the instance's option events & watchers.\n   * If the value is a string, we pull it from the\n   * instance's methods by name.\n   */\n\n  Vue.prototype._initEvents = function () {\n    var options = this.$options;\n    if (options._asComponent) {\n      registerComponentEvents(this, options.el);\n    }\n    registerCallbacks(this, '$on', options.events);\n    registerCallbacks(this, '$watch', options.watch);\n  };\n\n  /**\n   * Register v-on events on a child component\n   *\n   * @param {Vue} vm\n   * @param {Element} el\n   */\n\n  function registerComponentEvents(vm, el) {\n    var attrs = el.attributes;\n    var name, value, handler;\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      name = attrs[i].name;\n      if (eventRE.test(name)) {\n        name = name.replace(eventRE, '');\n        // force the expression into a statement so that\n        // it always dynamically resolves the method to call (#2670)\n        // kinda ugly hack, but does the job.\n        value = attrs[i].value;\n        if (isSimplePath(value)) {\n          value += '.apply(this, $arguments)';\n        }\n        handler = (vm._scope || vm._context).$eval(value, true);\n        handler._fromParent = true;\n        vm.$on(name.replace(eventRE), handler);\n      }\n    }\n  }\n\n  /**\n   * Register callbacks for option events and watchers.\n   *\n   * @param {Vue} vm\n   * @param {String} action\n   * @param {Object} hash\n   */\n\n  function registerCallbacks(vm, action, hash) {\n    if (!hash) return;\n    var handlers, key, i, j;\n    for (key in hash) {\n      handlers = hash[key];\n      if (isArray(handlers)) {\n        for (i = 0, j = handlers.length; i < j; i++) {\n          register(vm, action, key, handlers[i]);\n        }\n      } else {\n        register(vm, action, key, handlers);\n      }\n    }\n  }\n\n  /**\n   * Helper to register an event/watch callback.\n   *\n   * @param {Vue} vm\n   * @param {String} action\n   * @param {String} key\n   * @param {Function|String|Object} handler\n   * @param {Object} [options]\n   */\n\n  function register(vm, action, key, handler, options) {\n    var type = typeof handler;\n    if (type === 'function') {\n      vm[action](key, handler, options);\n    } else if (type === 'string') {\n      var methods = vm.$options.methods;\n      var method = methods && methods[handler];\n      if (method) {\n        vm[action](key, method, options);\n      } else {\n        (\"development\") !== 'production' && warn('Unknown method: \"' + handler + '\" when ' + 'registering callback for ' + action + ': \"' + key + '\".', vm);\n      }\n    } else if (handler && type === 'object') {\n      register(vm, action, key, handler.handler, handler);\n    }\n  }\n\n  /**\n   * Setup recursive attached/detached calls\n   */\n\n  Vue.prototype._initDOMHooks = function () {\n    this.$on('hook:attached', onAttached);\n    this.$on('hook:detached', onDetached);\n  };\n\n  /**\n   * Callback to recursively call attached hook on children\n   */\n\n  function onAttached() {\n    if (!this._isAttached) {\n      this._isAttached = true;\n      this.$children.forEach(callAttach);\n    }\n  }\n\n  /**\n   * Iterator to call attached hook\n   *\n   * @param {Vue} child\n   */\n\n  function callAttach(child) {\n    if (!child._isAttached && inDoc(child.$el)) {\n      child._callHook('attached');\n    }\n  }\n\n  /**\n   * Callback to recursively call detached hook on children\n   */\n\n  function onDetached() {\n    if (this._isAttached) {\n      this._isAttached = false;\n      this.$children.forEach(callDetach);\n    }\n  }\n\n  /**\n   * Iterator to call detached hook\n   *\n   * @param {Vue} child\n   */\n\n  function callDetach(child) {\n    if (child._isAttached && !inDoc(child.$el)) {\n      child._callHook('detached');\n    }\n  }\n\n  /**\n   * Trigger all handlers for a hook\n   *\n   * @param {String} hook\n   */\n\n  Vue.prototype._callHook = function (hook) {\n    this.$emit('pre-hook:' + hook);\n    var handlers = this.$options[hook];\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        handlers[i].call(this);\n      }\n    }\n    this.$emit('hook:' + hook);\n  };\n}\n\nfunction noop$1() {}\n\n/**\n * A directive links a DOM element with a piece of data,\n * which is the result of evaluating an expression.\n * It registers a watcher with the expression and calls\n * the DOM update function when a change is triggered.\n *\n * @param {Object} descriptor\n *                 - {String} name\n *                 - {Object} def\n *                 - {String} expression\n *                 - {Array<Object>} [filters]\n *                 - {Object} [modifiers]\n *                 - {Boolean} literal\n *                 - {String} attr\n *                 - {String} arg\n *                 - {String} raw\n *                 - {String} [ref]\n *                 - {Array<Object>} [interp]\n *                 - {Boolean} [hasOneTime]\n * @param {Vue} vm\n * @param {Node} el\n * @param {Vue} [host] - transclusion host component\n * @param {Object} [scope] - v-for scope\n * @param {Fragment} [frag] - owner fragment\n * @constructor\n */\nfunction Directive(descriptor, vm, el, host, scope, frag) {\n  this.vm = vm;\n  this.el = el;\n  // copy descriptor properties\n  this.descriptor = descriptor;\n  this.name = descriptor.name;\n  this.expression = descriptor.expression;\n  this.arg = descriptor.arg;\n  this.modifiers = descriptor.modifiers;\n  this.filters = descriptor.filters;\n  this.literal = this.modifiers && this.modifiers.literal;\n  // private\n  this._locked = false;\n  this._bound = false;\n  this._listeners = null;\n  // link context\n  this._host = host;\n  this._scope = scope;\n  this._frag = frag;\n  // store directives on node in dev mode\n  if ((\"development\") !== 'production' && this.el) {\n    this.el._vue_directives = this.el._vue_directives || [];\n    this.el._vue_directives.push(this);\n  }\n}\n\n/**\n * Initialize the directive, mixin definition properties,\n * setup the watcher, call definition bind() and update()\n * if present.\n */\n\nDirective.prototype._bind = function () {\n  var name = this.name;\n  var descriptor = this.descriptor;\n\n  // remove attribute\n  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {\n    var attr = descriptor.attr || 'v-' + name;\n    this.el.removeAttribute(attr);\n  }\n\n  // copy def properties\n  var def = descriptor.def;\n  if (typeof def === 'function') {\n    this.update = def;\n  } else {\n    extend(this, def);\n  }\n\n  // setup directive params\n  this._setupParams();\n\n  // initial bind\n  if (this.bind) {\n    this.bind();\n  }\n  this._bound = true;\n\n  if (this.literal) {\n    this.update && this.update(descriptor.raw);\n  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {\n    // wrapped updater for context\n    var dir = this;\n    if (this.update) {\n      this._update = function (val, oldVal) {\n        if (!dir._locked) {\n          dir.update(val, oldVal);\n        }\n      };\n    } else {\n      this._update = noop$1;\n    }\n    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;\n    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;\n    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\n    {\n      filters: this.filters,\n      twoWay: this.twoWay,\n      deep: this.deep,\n      preProcess: preProcess,\n      postProcess: postProcess,\n      scope: this._scope\n    });\n    // v-model with inital inline value need to sync back to\n    // model instead of update to DOM on init. They would\n    // set the afterBind hook to indicate that.\n    if (this.afterBind) {\n      this.afterBind();\n    } else if (this.update) {\n      this.update(watcher.value);\n    }\n  }\n};\n\n/**\n * Setup all param attributes, e.g. track-by,\n * transition-mode, etc...\n */\n\nDirective.prototype._setupParams = function () {\n  if (!this.params) {\n    return;\n  }\n  var params = this.params;\n  // swap the params array with a fresh object.\n  this.params = Object.create(null);\n  var i = params.length;\n  var key, val, mappedKey;\n  while (i--) {\n    key = hyphenate(params[i]);\n    mappedKey = camelize(key);\n    val = getBindAttr(this.el, key);\n    if (val != null) {\n      // dynamic\n      this._setupParamWatcher(mappedKey, val);\n    } else {\n      // static\n      val = getAttr(this.el, key);\n      if (val != null) {\n        this.params[mappedKey] = val === '' ? true : val;\n      }\n    }\n  }\n};\n\n/**\n * Setup a watcher for a dynamic param.\n *\n * @param {String} key\n * @param {String} expression\n */\n\nDirective.prototype._setupParamWatcher = function (key, expression) {\n  var self = this;\n  var called = false;\n  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n    self.params[key] = val;\n    // since we are in immediate mode,\n    // only call the param change callbacks if this is not the first update.\n    if (called) {\n      var cb = self.paramWatchers && self.paramWatchers[key];\n      if (cb) {\n        cb.call(self, val, oldVal);\n      }\n    } else {\n      called = true;\n    }\n  }, {\n    immediate: true,\n    user: false\n  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);\n};\n\n/**\n * Check if the directive is a function caller\n * and if the expression is a callable one. If both true,\n * we wrap up the expression and use it as the event\n * handler.\n *\n * e.g. on-click=\"a++\"\n *\n * @return {Boolean}\n */\n\nDirective.prototype._checkStatement = function () {\n  var expression = this.expression;\n  if (expression && this.acceptStatement && !isSimplePath(expression)) {\n    var fn = parseExpression(expression).get;\n    var scope = this._scope || this.vm;\n    var handler = function handler(e) {\n      scope.$event = e;\n      fn.call(scope, scope);\n      scope.$event = null;\n    };\n    if (this.filters) {\n      handler = scope._applyFilters(handler, null, this.filters);\n    }\n    this.update(handler);\n    return true;\n  }\n};\n\n/**\n * Set the corresponding value with the setter.\n * This should only be used in two-way directives\n * e.g. v-model.\n *\n * @param {*} value\n * @public\n */\n\nDirective.prototype.set = function (value) {\n  /* istanbul ignore else */\n  if (this.twoWay) {\n    this._withLock(function () {\n      this._watcher.set(value);\n    });\n  } else if (true) {\n    warn('Directive.set() can only be used inside twoWay' + 'directives.');\n  }\n};\n\n/**\n * Execute a function while preventing that function from\n * triggering updates on this directive instance.\n *\n * @param {Function} fn\n */\n\nDirective.prototype._withLock = function (fn) {\n  var self = this;\n  self._locked = true;\n  fn.call(self);\n  nextTick(function () {\n    self._locked = false;\n  });\n};\n\n/**\n * Convenience method that attaches a DOM event listener\n * to the directive element and autometically tears it down\n * during unbind.\n *\n * @param {String} event\n * @param {Function} handler\n * @param {Boolean} [useCapture]\n */\n\nDirective.prototype.on = function (event, handler, useCapture) {\n  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);\n};\n\n/**\n * Teardown the watcher and call unbind.\n */\n\nDirective.prototype._teardown = function () {\n  if (this._bound) {\n    this._bound = false;\n    if (this.unbind) {\n      this.unbind();\n    }\n    if (this._watcher) {\n      this._watcher.teardown();\n    }\n    var listeners = this._listeners;\n    var i;\n    if (listeners) {\n      i = listeners.length;\n      while (i--) {\n        off(this.el, listeners[i][0], listeners[i][1]);\n      }\n    }\n    var unwatchFns = this._paramUnwatchFns;\n    if (unwatchFns) {\n      i = unwatchFns.length;\n      while (i--) {\n        unwatchFns[i]();\n      }\n    }\n    if ((\"development\") !== 'production' && this.el) {\n      this.el._vue_directives.$remove(this);\n    }\n    this.vm = this.el = this._watcher = this._listeners = null;\n  }\n};\n\nfunction lifecycleMixin (Vue) {\n  /**\n   * Update v-ref for component.\n   *\n   * @param {Boolean} remove\n   */\n\n  Vue.prototype._updateRef = function (remove) {\n    var ref = this.$options._ref;\n    if (ref) {\n      var refs = (this._scope || this._context).$refs;\n      if (remove) {\n        if (refs[ref] === this) {\n          refs[ref] = null;\n        }\n      } else {\n        refs[ref] = this;\n      }\n    }\n  };\n\n  /**\n   * Transclude, compile and link element.\n   *\n   * If a pre-compiled linker is available, that means the\n   * passed in element will be pre-transcluded and compiled\n   * as well - all we need to do is to call the linker.\n   *\n   * Otherwise we need to call transclude/compile/link here.\n   *\n   * @param {Element} el\n   */\n\n  Vue.prototype._compile = function (el) {\n    var options = this.$options;\n\n    // transclude and init element\n    // transclude can potentially replace original\n    // so we need to keep reference; this step also injects\n    // the template and caches the original attributes\n    // on the container node and replacer node.\n    var original = el;\n    el = transclude(el, options);\n    this._initElement(el);\n\n    // handle v-pre on root node (#2026)\n    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {\n      return;\n    }\n\n    // root is always compiled per-instance, because\n    // container attrs and props can be different every time.\n    var contextOptions = this._context && this._context.$options;\n    var rootLinker = compileRoot(el, options, contextOptions);\n\n    // resolve slot distribution\n    resolveSlots(this, options._content);\n\n    // compile and link the rest\n    var contentLinkFn;\n    var ctor = this.constructor;\n    // component compilation can be cached\n    // as long as it's not using inline-template\n    if (options._linkerCachable) {\n      contentLinkFn = ctor.linker;\n      if (!contentLinkFn) {\n        contentLinkFn = ctor.linker = compile(el, options);\n      }\n    }\n\n    // link phase\n    // make sure to link root with prop scope!\n    var rootUnlinkFn = rootLinker(this, el, this._scope);\n    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);\n\n    // register composite unlink function\n    // to be called during instance destruction\n    this._unlinkFn = function () {\n      rootUnlinkFn();\n      // passing destroying: true to avoid searching and\n      // splicing the directives\n      contentUnlinkFn(true);\n    };\n\n    // finally replace original\n    if (options.replace) {\n      replace(original, el);\n    }\n\n    this._isCompiled = true;\n    this._callHook('compiled');\n  };\n\n  /**\n   * Initialize instance element. Called in the public\n   * $mount() method.\n   *\n   * @param {Element} el\n   */\n\n  Vue.prototype._initElement = function (el) {\n    if (isFragment(el)) {\n      this._isFragment = true;\n      this.$el = this._fragmentStart = el.firstChild;\n      this._fragmentEnd = el.lastChild;\n      // set persisted text anchors to empty\n      if (this._fragmentStart.nodeType === 3) {\n        this._fragmentStart.data = this._fragmentEnd.data = '';\n      }\n      this._fragment = el;\n    } else {\n      this.$el = el;\n    }\n    this.$el.__vue__ = this;\n    this._callHook('beforeCompile');\n  };\n\n  /**\n   * Create and bind a directive to an element.\n   *\n   * @param {Object} descriptor - parsed directive descriptor\n   * @param {Node} node   - target node\n   * @param {Vue} [host] - transclusion host component\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - owner fragment\n   */\n\n  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {\n    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));\n  };\n\n  /**\n   * Teardown an instance, unobserves the data, unbind all the\n   * directives, turn off all the event listeners, etc.\n   *\n   * @param {Boolean} remove - whether to remove the DOM node.\n   * @param {Boolean} deferCleanup - if true, defer cleanup to\n   *                                 be called later\n   */\n\n  Vue.prototype._destroy = function (remove, deferCleanup) {\n    if (this._isBeingDestroyed) {\n      if (!deferCleanup) {\n        this._cleanup();\n      }\n      return;\n    }\n\n    var destroyReady;\n    var pendingRemoval;\n\n    var self = this;\n    // Cleanup should be called either synchronously or asynchronoysly as\n    // callback of this.$remove(), or if remove and deferCleanup are false.\n    // In any case it should be called after all other removing, unbinding and\n    // turning of is done\n    var cleanupIfPossible = function cleanupIfPossible() {\n      if (destroyReady && !pendingRemoval && !deferCleanup) {\n        self._cleanup();\n      }\n    };\n\n    // remove DOM element\n    if (remove && this.$el) {\n      pendingRemoval = true;\n      this.$remove(function () {\n        pendingRemoval = false;\n        cleanupIfPossible();\n      });\n    }\n\n    this._callHook('beforeDestroy');\n    this._isBeingDestroyed = true;\n    var i;\n    // remove self from parent. only necessary\n    // if parent is not being destroyed as well.\n    var parent = this.$parent;\n    if (parent && !parent._isBeingDestroyed) {\n      parent.$children.$remove(this);\n      // unregister ref (remove: true)\n      this._updateRef(true);\n    }\n    // destroy all children.\n    i = this.$children.length;\n    while (i--) {\n      this.$children[i].$destroy();\n    }\n    // teardown props\n    if (this._propsUnlinkFn) {\n      this._propsUnlinkFn();\n    }\n    // teardown all directives. this also tearsdown all\n    // directive-owned watchers.\n    if (this._unlinkFn) {\n      this._unlinkFn();\n    }\n    i = this._watchers.length;\n    while (i--) {\n      this._watchers[i].teardown();\n    }\n    // remove reference to self on $el\n    if (this.$el) {\n      this.$el.__vue__ = null;\n    }\n\n    destroyReady = true;\n    cleanupIfPossible();\n  };\n\n  /**\n   * Clean up to ensure garbage collection.\n   * This is called after the leave transition if there\n   * is any.\n   */\n\n  Vue.prototype._cleanup = function () {\n    if (this._isDestroyed) {\n      return;\n    }\n    // remove self from owner fragment\n    // do it in cleanup so that we can call $destroy with\n    // defer right when a fragment is about to be removed.\n    if (this._frag) {\n      this._frag.children.$remove(this);\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (this._data && this._data.__ob__) {\n      this._data.__ob__.removeVm(this);\n    }\n    // Clean up references to private properties and other\n    // instances. preserve reference to _data so that proxy\n    // accessors still work. The only potential side effect\n    // here is that mutating the instance after it's destroyed\n    // may affect the state of other components that are still\n    // observing the same object, but that seems to be a\n    // reasonable responsibility for the user rather than\n    // always throwing an error on them.\n    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;\n    // call the last hook...\n    this._isDestroyed = true;\n    this._callHook('destroyed');\n    // turn off all instance listeners.\n    this.$off();\n  };\n}\n\nfunction miscMixin (Vue) {\n  /**\n   * Apply a list of filter (descriptors) to a value.\n   * Using plain for loops here because this will be called in\n   * the getter of any watcher with filters so it is very\n   * performance sensitive.\n   *\n   * @param {*} value\n   * @param {*} [oldValue]\n   * @param {Array} filters\n   * @param {Boolean} write\n   * @return {*}\n   */\n\n  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {\n    var filter, fn, args, arg, offset, i, l, j, k;\n    for (i = 0, l = filters.length; i < l; i++) {\n      filter = filters[write ? l - i - 1 : i];\n      fn = resolveAsset(this.$options, 'filters', filter.name, true);\n      if (!fn) continue;\n      fn = write ? fn.write : fn.read || fn;\n      if (typeof fn !== 'function') continue;\n      args = write ? [value, oldValue] : [value];\n      offset = write ? 2 : 1;\n      if (filter.args) {\n        for (j = 0, k = filter.args.length; j < k; j++) {\n          arg = filter.args[j];\n          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;\n        }\n      }\n      value = fn.apply(this, args);\n    }\n    return value;\n  };\n\n  /**\n   * Resolve a component, depending on whether the component\n   * is defined normally or using an async factory function.\n   * Resolves synchronously if already resolved, otherwise\n   * resolves asynchronously and caches the resolved\n   * constructor on the factory.\n   *\n   * @param {String|Function} value\n   * @param {Function} cb\n   */\n\n  Vue.prototype._resolveComponent = function (value, cb) {\n    var factory;\n    if (typeof value === 'function') {\n      factory = value;\n    } else {\n      factory = resolveAsset(this.$options, 'components', value, true);\n    }\n    /* istanbul ignore if */\n    if (!factory) {\n      return;\n    }\n    // async component factory\n    if (!factory.options) {\n      if (factory.resolved) {\n        // cached\n        cb(factory.resolved);\n      } else if (factory.requested) {\n        // pool callbacks\n        factory.pendingCallbacks.push(cb);\n      } else {\n        factory.requested = true;\n        var cbs = factory.pendingCallbacks = [cb];\n        factory.call(this, function resolve(res) {\n          if (isPlainObject(res)) {\n            res = Vue.extend(res);\n          }\n          // cache resolved\n          factory.resolved = res;\n          // invoke callbacks\n          for (var i = 0, l = cbs.length; i < l; i++) {\n            cbs[i](res);\n          }\n        }, function reject(reason) {\n          (\"development\") !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\\nReason: ' + reason : ''));\n        });\n      }\n    } else {\n      // normal component\n      cb(factory);\n    }\n  };\n}\n\nvar filterRE$1 = /[^|]\\|[^|]/;\n\nfunction dataAPI (Vue) {\n  /**\n   * Get the value from an expression on this vm.\n   *\n   * @param {String} exp\n   * @param {Boolean} [asStatement]\n   * @return {*}\n   */\n\n  Vue.prototype.$get = function (exp, asStatement) {\n    var res = parseExpression(exp);\n    if (res) {\n      if (asStatement) {\n        var self = this;\n        return function statementHandler() {\n          self.$arguments = toArray(arguments);\n          var result = res.get.call(self, self);\n          self.$arguments = null;\n          return result;\n        };\n      } else {\n        try {\n          return res.get.call(this, this);\n        } catch (e) {}\n      }\n    }\n  };\n\n  /**\n   * Set the value from an expression on this vm.\n   * The expression must be a valid left-hand\n   * expression in an assignment.\n   *\n   * @param {String} exp\n   * @param {*} val\n   */\n\n  Vue.prototype.$set = function (exp, val) {\n    var res = parseExpression(exp, true);\n    if (res && res.set) {\n      res.set.call(this, this, val);\n    }\n  };\n\n  /**\n   * Delete a property on the VM\n   *\n   * @param {String} key\n   */\n\n  Vue.prototype.$delete = function (key) {\n    del(this._data, key);\n  };\n\n  /**\n   * Watch an expression, trigger callback when its\n   * value changes.\n   *\n   * @param {String|Function} expOrFn\n   * @param {Function} cb\n   * @param {Object} [options]\n   *                 - {Boolean} deep\n   *                 - {Boolean} immediate\n   * @return {Function} - unwatchFn\n   */\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n    var parsed;\n    if (typeof expOrFn === 'string') {\n      parsed = parseDirective(expOrFn);\n      expOrFn = parsed.expression;\n    }\n    var watcher = new Watcher(vm, expOrFn, cb, {\n      deep: options && options.deep,\n      sync: options && options.sync,\n      filters: parsed && parsed.filters,\n      user: !options || options.user !== false\n    });\n    if (options && options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n\n  /**\n   * Evaluate a text directive, including filters.\n   *\n   * @param {String} text\n   * @param {Boolean} [asStatement]\n   * @return {String}\n   */\n\n  Vue.prototype.$eval = function (text, asStatement) {\n    // check for filters.\n    if (filterRE$1.test(text)) {\n      var dir = parseDirective(text);\n      // the filter regex check might give false positive\n      // for pipes inside strings, so it's possible that\n      // we don't get any filters here\n      var val = this.$get(dir.expression, asStatement);\n      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;\n    } else {\n      // no filter\n      return this.$get(text, asStatement);\n    }\n  };\n\n  /**\n   * Interpolate a piece of template text.\n   *\n   * @param {String} text\n   * @return {String}\n   */\n\n  Vue.prototype.$interpolate = function (text) {\n    var tokens = parseText(text);\n    var vm = this;\n    if (tokens) {\n      if (tokens.length === 1) {\n        return vm.$eval(tokens[0].value) + '';\n      } else {\n        return tokens.map(function (token) {\n          return token.tag ? vm.$eval(token.value) : token.value;\n        }).join('');\n      }\n    } else {\n      return text;\n    }\n  };\n\n  /**\n   * Log instance data as a plain JS object\n   * so that it is easier to inspect in console.\n   * This method assumes console is available.\n   *\n   * @param {String} [path]\n   */\n\n  Vue.prototype.$log = function (path) {\n    var data = path ? getPath(this._data, path) : this._data;\n    if (data) {\n      data = clean(data);\n    }\n    // include computed fields\n    if (!path) {\n      var key;\n      for (key in this.$options.computed) {\n        data[key] = clean(this[key]);\n      }\n      if (this._props) {\n        for (key in this._props) {\n          data[key] = clean(this[key]);\n        }\n      }\n    }\n    console.log(data);\n  };\n\n  /**\n   * \"clean\" a getter/setter converted object into a plain\n   * object copy.\n   *\n   * @param {Object} - obj\n   * @return {Object}\n   */\n\n  function clean(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n}\n\nfunction domAPI (Vue) {\n  /**\n   * Convenience on-instance nextTick. The callback is\n   * auto-bound to the instance, and this avoids component\n   * modules having to rely on the global Vue.\n   *\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$nextTick = function (fn) {\n    nextTick(fn, this);\n  };\n\n  /**\n   * Append instance to target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$appendTo = function (target, cb, withTransition) {\n    return insert(this, target, cb, withTransition, append, appendWithTransition);\n  };\n\n  /**\n   * Prepend instance to target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$prependTo = function (target, cb, withTransition) {\n    target = query(target);\n    if (target.hasChildNodes()) {\n      this.$before(target.firstChild, cb, withTransition);\n    } else {\n      this.$appendTo(target, cb, withTransition);\n    }\n    return this;\n  };\n\n  /**\n   * Insert instance before target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$before = function (target, cb, withTransition) {\n    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);\n  };\n\n  /**\n   * Insert instance after target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$after = function (target, cb, withTransition) {\n    target = query(target);\n    if (target.nextSibling) {\n      this.$before(target.nextSibling, cb, withTransition);\n    } else {\n      this.$appendTo(target.parentNode, cb, withTransition);\n    }\n    return this;\n  };\n\n  /**\n   * Remove instance from DOM\n   *\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$remove = function (cb, withTransition) {\n    if (!this.$el.parentNode) {\n      return cb && cb();\n    }\n    var inDocument = this._isAttached && inDoc(this.$el);\n    // if we are not in document, no need to check\n    // for transitions\n    if (!inDocument) withTransition = false;\n    var self = this;\n    var realCb = function realCb() {\n      if (inDocument) self._callHook('detached');\n      if (cb) cb();\n    };\n    if (this._isFragment) {\n      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);\n    } else {\n      var op = withTransition === false ? removeWithCb : removeWithTransition;\n      op(this.$el, this, realCb);\n    }\n    return this;\n  };\n\n  /**\n   * Shared DOM insertion function.\n   *\n   * @param {Vue} vm\n   * @param {Element} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition]\n   * @param {Function} op1 - op for non-transition insert\n   * @param {Function} op2 - op for transition insert\n   * @return vm\n   */\n\n  function insert(vm, target, cb, withTransition, op1, op2) {\n    target = query(target);\n    var targetIsDetached = !inDoc(target);\n    var op = withTransition === false || targetIsDetached ? op1 : op2;\n    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);\n    if (vm._isFragment) {\n      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n        op(node, target, vm);\n      });\n      cb && cb();\n    } else {\n      op(vm.$el, target, vm, cb);\n    }\n    if (shouldCallHook) {\n      vm._callHook('attached');\n    }\n    return vm;\n  }\n\n  /**\n   * Check for selectors\n   *\n   * @param {String|Element} el\n   */\n\n  function query(el) {\n    return typeof el === 'string' ? document.querySelector(el) : el;\n  }\n\n  /**\n   * Append operation that takes a callback.\n   *\n   * @param {Node} el\n   * @param {Node} target\n   * @param {Vue} vm - unused\n   * @param {Function} [cb]\n   */\n\n  function append(el, target, vm, cb) {\n    target.appendChild(el);\n    if (cb) cb();\n  }\n\n  /**\n   * InsertBefore operation that takes a callback.\n   *\n   * @param {Node} el\n   * @param {Node} target\n   * @param {Vue} vm - unused\n   * @param {Function} [cb]\n   */\n\n  function beforeWithCb(el, target, vm, cb) {\n    before(el, target);\n    if (cb) cb();\n  }\n\n  /**\n   * Remove operation that takes a callback.\n   *\n   * @param {Node} el\n   * @param {Vue} vm - unused\n   * @param {Function} [cb]\n   */\n\n  function removeWithCb(el, vm, cb) {\n    remove(el);\n    if (cb) cb();\n  }\n}\n\nfunction eventsAPI (Vue) {\n  /**\n   * Listen on the given `event` with `fn`.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$on = function (event, fn) {\n    (this._events[event] || (this._events[event] = [])).push(fn);\n    modifyListenerCount(this, event, 1);\n    return this;\n  };\n\n  /**\n   * Adds an `event` listener that will be invoked a single\n   * time then automatically removed.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$once = function (event, fn) {\n    var self = this;\n    function on() {\n      self.$off(event, on);\n      fn.apply(this, arguments);\n    }\n    on.fn = fn;\n    this.$on(event, on);\n    return this;\n  };\n\n  /**\n   * Remove the given callback for `event` or all\n   * registered callbacks.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$off = function (event, fn) {\n    var cbs;\n    // all\n    if (!arguments.length) {\n      if (this.$parent) {\n        for (event in this._events) {\n          cbs = this._events[event];\n          if (cbs) {\n            modifyListenerCount(this, event, -cbs.length);\n          }\n        }\n      }\n      this._events = {};\n      return this;\n    }\n    // specific event\n    cbs = this._events[event];\n    if (!cbs) {\n      return this;\n    }\n    if (arguments.length === 1) {\n      modifyListenerCount(this, event, -cbs.length);\n      this._events[event] = null;\n      return this;\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        modifyListenerCount(this, event, -1);\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Trigger an event on self.\n   *\n   * @param {String|Object} event\n   * @return {Boolean} shouldPropagate\n   */\n\n  Vue.prototype.$emit = function (event) {\n    var isSource = typeof event === 'string';\n    event = isSource ? event : event.name;\n    var cbs = this._events[event];\n    var shouldPropagate = isSource || !cbs;\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      // this is a somewhat hacky solution to the question raised\n      // in #2102: for an inline component listener like <comp @test=\"doThis\">,\n      // the propagation handling is somewhat broken. Therefore we\n      // need to treat these inline callbacks differently.\n      var hasParentCbs = isSource && cbs.some(function (cb) {\n        return cb._fromParent;\n      });\n      if (hasParentCbs) {\n        shouldPropagate = false;\n      }\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        var cb = cbs[i];\n        var res = cb.apply(this, args);\n        if (res === true && (!hasParentCbs || cb._fromParent)) {\n          shouldPropagate = true;\n        }\n      }\n    }\n    return shouldPropagate;\n  };\n\n  /**\n   * Recursively broadcast an event to all children instances.\n   *\n   * @param {String|Object} event\n   * @param {...*} additional arguments\n   */\n\n  Vue.prototype.$broadcast = function (event) {\n    var isSource = typeof event === 'string';\n    event = isSource ? event : event.name;\n    // if no child has registered for this event,\n    // then there's no need to broadcast.\n    if (!this._eventsCount[event]) return;\n    var children = this.$children;\n    var args = toArray(arguments);\n    if (isSource) {\n      // use object event to indicate non-source emit\n      // on children\n      args[0] = { name: event, source: this };\n    }\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var shouldPropagate = child.$emit.apply(child, args);\n      if (shouldPropagate) {\n        child.$broadcast.apply(child, args);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Recursively propagate an event up the parent chain.\n   *\n   * @param {String} event\n   * @param {...*} additional arguments\n   */\n\n  Vue.prototype.$dispatch = function (event) {\n    var shouldPropagate = this.$emit.apply(this, arguments);\n    if (!shouldPropagate) return;\n    var parent = this.$parent;\n    var args = toArray(arguments);\n    // use object event to indicate non-source emit\n    // on parents\n    args[0] = { name: event, source: this };\n    while (parent) {\n      shouldPropagate = parent.$emit.apply(parent, args);\n      parent = shouldPropagate ? parent.$parent : null;\n    }\n    return this;\n  };\n\n  /**\n   * Modify the listener counts on all parents.\n   * This bookkeeping allows $broadcast to return early when\n   * no child has listened to a certain event.\n   *\n   * @param {Vue} vm\n   * @param {String} event\n   * @param {Number} count\n   */\n\n  var hookRE = /^hook:/;\n  function modifyListenerCount(vm, event, count) {\n    var parent = vm.$parent;\n    // hooks do not get broadcasted so no need\n    // to do bookkeeping for them\n    if (!parent || !count || hookRE.test(event)) return;\n    while (parent) {\n      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;\n      parent = parent.$parent;\n    }\n  }\n}\n\nfunction lifecycleAPI (Vue) {\n  /**\n   * Set instance target element and kick off the compilation\n   * process. The passed in `el` can be a selector string, an\n   * existing Element, or a DocumentFragment (for block\n   * instances).\n   *\n   * @param {Element|DocumentFragment|string} el\n   * @public\n   */\n\n  Vue.prototype.$mount = function (el) {\n    if (this._isCompiled) {\n      (\"development\") !== 'production' && warn('$mount() should be called only once.', this);\n      return;\n    }\n    el = query(el);\n    if (!el) {\n      el = document.createElement('div');\n    }\n    this._compile(el);\n    this._initDOMHooks();\n    if (inDoc(this.$el)) {\n      this._callHook('attached');\n      ready.call(this);\n    } else {\n      this.$once('hook:attached', ready);\n    }\n    return this;\n  };\n\n  /**\n   * Mark an instance as ready.\n   */\n\n  function ready() {\n    this._isAttached = true;\n    this._isReady = true;\n    this._callHook('ready');\n  }\n\n  /**\n   * Teardown the instance, simply delegate to the internal\n   * _destroy.\n   *\n   * @param {Boolean} remove\n   * @param {Boolean} deferCleanup\n   */\n\n  Vue.prototype.$destroy = function (remove, deferCleanup) {\n    this._destroy(remove, deferCleanup);\n  };\n\n  /**\n   * Partially compile a piece of DOM and return a\n   * decompile function.\n   *\n   * @param {Element|DocumentFragment} el\n   * @param {Vue} [host]\n   * @param {Object} [scope]\n   * @param {Fragment} [frag]\n   * @return {Function}\n   */\n\n  Vue.prototype.$compile = function (el, host, scope, frag) {\n    return compile(el, this.$options, true)(this, el, host, scope, frag);\n  };\n}\n\n/**\n * The exposed Vue constructor.\n *\n * API conventions:\n * - public API methods/properties are prefixed with `$`\n * - internal methods/properties are prefixed with `_`\n * - non-prefixed properties are assumed to be proxied user\n *   data.\n *\n * @constructor\n * @param {Object} [options]\n * @public\n */\n\nfunction Vue(options) {\n  this._init(options);\n}\n\n// install internals\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nmiscMixin(Vue);\n\n// install instance APIs\ndataAPI(Vue);\ndomAPI(Vue);\neventsAPI(Vue);\nlifecycleAPI(Vue);\n\nvar slot = {\n\n  priority: SLOT,\n  params: ['name'],\n\n  bind: function bind() {\n    // this was resolved during component transclusion\n    var name = this.params.name || 'default';\n    var content = this.vm._slotContents && this.vm._slotContents[name];\n    if (!content || !content.hasChildNodes()) {\n      this.fallback();\n    } else {\n      this.compile(content.cloneNode(true), this.vm._context, this.vm);\n    }\n  },\n\n  compile: function compile(content, context, host) {\n    if (content && context) {\n      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {\n        // if the inserted slot has v-if\n        // inject fallback content as the v-else\n        var elseBlock = document.createElement('template');\n        elseBlock.setAttribute('v-else', '');\n        elseBlock.innerHTML = this.el.innerHTML;\n        // the else block should be compiled in child scope\n        elseBlock._context = this.vm;\n        content.appendChild(elseBlock);\n      }\n      var scope = host ? host._scope : this._scope;\n      this.unlink = context.$compile(content, host, scope, this._frag);\n    }\n    if (content) {\n      replace(this.el, content);\n    } else {\n      remove(this.el);\n    }\n  },\n\n  fallback: function fallback() {\n    this.compile(extractContent(this.el, true), this.vm);\n  },\n\n  unbind: function unbind() {\n    if (this.unlink) {\n      this.unlink();\n    }\n  }\n};\n\nvar partial = {\n\n  priority: PARTIAL,\n\n  params: ['name'],\n\n  // watch changes to name for dynamic partials\n  paramWatchers: {\n    name: function name(value) {\n      vIf.remove.call(this);\n      if (value) {\n        this.insert(value);\n      }\n    }\n  },\n\n  bind: function bind() {\n    this.anchor = createAnchor('v-partial');\n    replace(this.el, this.anchor);\n    this.insert(this.params.name);\n  },\n\n  insert: function insert(id) {\n    var partial = resolveAsset(this.vm.$options, 'partials', id, true);\n    if (partial) {\n      this.factory = new FragmentFactory(this.vm, partial);\n      vIf.insert.call(this);\n    }\n  },\n\n  unbind: function unbind() {\n    if (this.frag) {\n      this.frag.destroy();\n    }\n  }\n};\n\nvar elementDirectives = {\n  slot: slot,\n  partial: partial\n};\n\nvar convertArray = vFor._postProcess;\n\n/**\n * Limit filter for arrays\n *\n * @param {Number} n\n * @param {Number} offset (Decimal expected)\n */\n\nfunction limitBy(arr, n, offset) {\n  offset = offset ? parseInt(offset, 10) : 0;\n  n = toNumber(n);\n  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String} search\n * @param {String} [delimiter]\n * @param {String} ...dataKeys\n */\n\nfunction filterBy(arr, search, delimiter) {\n  arr = convertArray(arr);\n  if (search == null) {\n    return arr;\n  }\n  if (typeof search === 'function') {\n    return arr.filter(search);\n  }\n  // cast to lowercase string\n  search = ('' + search).toLowerCase();\n  // allow optional `in` delimiter\n  // because why not\n  var n = delimiter === 'in' ? 3 : 2;\n  // extract and flatten keys\n  var keys = Array.prototype.concat.apply([], toArray(arguments, n));\n  var res = [];\n  var item, key, val, j;\n  for (var i = 0, l = arr.length; i < l; i++) {\n    item = arr[i];\n    val = item && item.$value || item;\n    j = keys.length;\n    if (j) {\n      while (j--) {\n        key = keys[j];\n        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {\n          res.push(item);\n          break;\n        }\n      }\n    } else if (contains(item, search)) {\n      res.push(item);\n    }\n  }\n  return res;\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String|Array<String>|Function} ...sortKeys\n * @param {Number} [order]\n */\n\nfunction orderBy(arr) {\n  var comparator = null;\n  var sortKeys = undefined;\n  arr = convertArray(arr);\n\n  // determine order (last argument)\n  var args = toArray(arguments, 1);\n  var order = args[args.length - 1];\n  if (typeof order === 'number') {\n    order = order < 0 ? -1 : 1;\n    args = args.length > 1 ? args.slice(0, -1) : args;\n  } else {\n    order = 1;\n  }\n\n  // determine sortKeys & comparator\n  var firstArg = args[0];\n  if (!firstArg) {\n    return arr;\n  } else if (typeof firstArg === 'function') {\n    // custom comparator\n    comparator = function (a, b) {\n      return firstArg(a, b) * order;\n    };\n  } else {\n    // string keys. flatten first\n    sortKeys = Array.prototype.concat.apply([], args);\n    comparator = function (a, b, i) {\n      i = i || 0;\n      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);\n    };\n  }\n\n  function baseCompare(a, b, sortKeyIndex) {\n    var sortKey = sortKeys[sortKeyIndex];\n    if (sortKey) {\n      if (sortKey !== '$key') {\n        if (isObject(a) && '$value' in a) a = a.$value;\n        if (isObject(b) && '$value' in b) b = b.$value;\n      }\n      a = isObject(a) ? getPath(a, sortKey) : a;\n      b = isObject(b) ? getPath(b, sortKey) : b;\n    }\n    return a === b ? 0 : a > b ? order : -order;\n  }\n\n  // sort on a copy to avoid mutating original array\n  return arr.slice().sort(comparator);\n}\n\n/**\n * String contain helper\n *\n * @param {*} val\n * @param {String} search\n */\n\nfunction contains(val, search) {\n  var i;\n  if (isPlainObject(val)) {\n    var keys = Object.keys(val);\n    i = keys.length;\n    while (i--) {\n      if (contains(val[keys[i]], search)) {\n        return true;\n      }\n    }\n  } else if (isArray(val)) {\n    i = val.length;\n    while (i--) {\n      if (contains(val[i], search)) {\n        return true;\n      }\n    }\n  } else if (val != null) {\n    return val.toString().toLowerCase().indexOf(search) > -1;\n  }\n}\n\nvar digitsRE = /(\\d{3})(?=\\d)/g;\n\n// asset collections must be a plain object.\nvar filters = {\n\n  orderBy: orderBy,\n  filterBy: filterBy,\n  limitBy: limitBy,\n\n  /**\n   * Stringify value.\n   *\n   * @param {Number} indent\n   */\n\n  json: {\n    read: function read(value, indent) {\n      return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);\n    },\n    write: function write(value) {\n      try {\n        return JSON.parse(value);\n      } catch (e) {\n        return value;\n      }\n    }\n  },\n\n  /**\n   * 'abc' => 'Abc'\n   */\n\n  capitalize: function capitalize(value) {\n    if (!value && value !== 0) return '';\n    value = value.toString();\n    return value.charAt(0).toUpperCase() + value.slice(1);\n  },\n\n  /**\n   * 'abc' => 'ABC'\n   */\n\n  uppercase: function uppercase(value) {\n    return value || value === 0 ? value.toString().toUpperCase() : '';\n  },\n\n  /**\n   * 'AbC' => 'abc'\n   */\n\n  lowercase: function lowercase(value) {\n    return value || value === 0 ? value.toString().toLowerCase() : '';\n  },\n\n  /**\n   * 12345 => $12,345.00\n   *\n   * @param {String} sign\n   * @param {Number} decimals Decimal places\n   */\n\n  currency: function currency(value, _currency, decimals) {\n    value = parseFloat(value);\n    if (!isFinite(value) || !value && value !== 0) return '';\n    _currency = _currency != null ? _currency : '$';\n    decimals = decimals != null ? decimals : 2;\n    var stringified = Math.abs(value).toFixed(decimals);\n    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;\n    var i = _int.length % 3;\n    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';\n    var _float = decimals ? stringified.slice(-1 - decimals) : '';\n    var sign = value < 0 ? '-' : '';\n    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;\n  },\n\n  /**\n   * 'item' => 'items'\n   *\n   * @params\n   *  an array of strings corresponding to\n   *  the single, double, triple ... forms of the word to\n   *  be pluralized. When the number to be pluralized\n   *  exceeds the length of the args, it will use the last\n   *  entry in the array.\n   *\n   *  e.g. ['single', 'double', 'triple', 'multiple']\n   */\n\n  pluralize: function pluralize(value) {\n    var args = toArray(arguments, 1);\n    var length = args.length;\n    if (length > 1) {\n      var index = value % 10 - 1;\n      return index in args ? args[index] : args[length - 1];\n    } else {\n      return args[0] + (value === 1 ? '' : 's');\n    }\n  },\n\n  /**\n   * Debounce a handler function.\n   *\n   * @param {Function} handler\n   * @param {Number} delay = 300\n   * @return {Function}\n   */\n\n  debounce: function debounce(handler, delay) {\n    if (!handler) return;\n    if (!delay) {\n      delay = 300;\n    }\n    return _debounce(handler, delay);\n  }\n};\n\nfunction installGlobalAPI (Vue) {\n  /**\n   * Vue and every constructor that extends Vue has an\n   * associated options object, which can be accessed during\n   * compilation steps as `this.constructor.options`.\n   *\n   * These can be seen as the default options of every\n   * Vue instance.\n   */\n\n  Vue.options = {\n    directives: directives,\n    elementDirectives: elementDirectives,\n    filters: filters,\n    transitions: {},\n    components: {},\n    partials: {},\n    replace: true\n  };\n\n  /**\n   * Expose useful internals\n   */\n\n  Vue.util = util;\n  Vue.config = config;\n  Vue.set = set;\n  Vue['delete'] = del;\n  Vue.nextTick = nextTick;\n\n  /**\n   * The following are exposed for advanced usage / plugins\n   */\n\n  Vue.compiler = compiler;\n  Vue.FragmentFactory = FragmentFactory;\n  Vue.internalDirectives = internalDirectives;\n  Vue.parsers = {\n    path: path,\n    text: text,\n    template: template,\n    directive: directive,\n    expression: expression\n  };\n\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   *\n   * @param {Object} extendOptions\n   */\n\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var isFirstExtend = Super.cid === 0;\n    if (isFirstExtend && extendOptions._Ctor) {\n      return extendOptions._Ctor;\n    }\n    var name = extendOptions.name || Super.options.name;\n    if (true) {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');\n        name = null;\n      }\n    }\n    var Sub = createClass(name || 'VueComponent');\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super;\n    // allow further extension\n    Sub.extend = Super.extend;\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n    // cache constructor\n    if (isFirstExtend) {\n      extendOptions._Ctor = Sub;\n    }\n    return Sub;\n  };\n\n  /**\n   * A function that returns a sub-class constructor with the\n   * given name. This gives us much nicer output when\n   * logging instances in the console.\n   *\n   * @param {String} name\n   * @return {Function}\n   */\n\n  function createClass(name) {\n    /* eslint-disable no-new-func */\n    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();\n    /* eslint-enable no-new-func */\n  }\n\n  /**\n   * Plugin system\n   *\n   * @param {Object} plugin\n   */\n\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return;\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this;\n  };\n\n  /**\n   * Apply a global mixin by merging it into the default\n   * options.\n   */\n\n  Vue.mixin = function (mixin) {\n    Vue.options = mergeOptions(Vue.options, mixin);\n  };\n\n  /**\n   * Create asset registration methods with the following\n   * signature:\n   *\n   * @param {String} id\n   * @param {*} definition\n   */\n\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if (true) {\n          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {\n            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          if (!definition.name) {\n            definition.name = id;\n          }\n          definition = Vue.extend(definition);\n        }\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n\n  // expose internal transition API\n  extend(Vue.transition, transition);\n}\n\ninstallGlobalAPI(Vue);\n\nVue.version = '1.0.26';\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue);\n    } else if ((\"development\") !== 'production' && inBrowser && /Chrome\\/\\d+/.test(window.navigator.userAgent)) {\n      console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n    }\n  }\n}, 0);\n\nmodule.exports = Vue;\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanM/ZTg4MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFP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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxJQUFJO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtB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Q0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztB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QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLEVBQUU7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQ0FBK0M7QUFDL0MsS0FBSztBQUNMLG1DQUFtQztBQUNuQztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQ0FBbUM7QUFDbkM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxx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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLE9BQU87QUFDckQscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQixhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixFQUFFOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0EsMkVBQTJFLHNCQUFzQjtBQUNqRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLEVBQUU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHFCIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFZ1ZS5qcyB2MS4wLjI2XG4gKiAoYykgMjAxNiBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHNldChvYmosIGtleSwgdmFsKSB7XG4gIGlmIChoYXNPd24ob2JqLCBrZXkpKSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvYmouX2lzVnVlKSB7XG4gICAgc2V0KG9iai5fZGF0YSwga2V5LCB2YWwpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2IgPSBvYmouX19vYl9fO1xuICBpZiAoIW9iKSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9iLmNvbnZlcnQoa2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIGlmIChvYi52bXMpIHtcbiAgICB2YXIgaSA9IG9iLnZtcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZtID0gb2Iudm1zW2ldO1xuICAgICAgdm0uX3Byb3h5KGtleSk7XG4gICAgICB2bS5fZGlnZXN0KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24gZGVsKG9iaiwga2V5KSB7XG4gIGlmICghaGFzT3duKG9iaiwga2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkZWxldGUgb2JqW2tleV07XG4gIHZhciBvYiA9IG9iai5fX29iX187XG4gIGlmICghb2IpIHtcbiAgICBpZiAob2JqLl9pc1Z1ZSkge1xuICAgICAgZGVsZXRlIG9iai5fZGF0YVtrZXldO1xuICAgICAgb2JqLl9kaWdlc3QoKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgaWYgKG9iLnZtcykge1xuICAgIHZhciBpID0gb2Iudm1zLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdm0gPSBvYi52bXNbaV07XG4gICAgICB2bS5fdW5wcm94eShrZXkpO1xuICAgICAgdm0uX2RpZ2VzdCgpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZXhwcmVzc2lvbiBpcyBhIGxpdGVyYWwgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgbGl0ZXJhbFZhbHVlUkUgPSAvXlxccz8odHJ1ZXxmYWxzZXwtP1tcXGRcXC5dK3wnW14nXSonfFwiW15cIl0qXCIpXFxzPyQvO1xuXG5mdW5jdGlvbiBpc0xpdGVyYWwoZXhwKSB7XG4gIHJldHVybiBsaXRlcmFsVmFsdWVSRS50ZXN0KGV4cCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1Jlc2VydmVkKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1Rjtcbn1cblxuLyoqXG4gKiBHdWFyZCB0ZXh0IG91dHB1dCwgbWFrZSBzdXJlIHVuZGVmaW5lZCBvdXRwdXRzXG4gKiBlbXB0eSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gX3RvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZS50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIENoZWNrIGFuZCBjb252ZXJ0IHBvc3NpYmxlIG51bWVyaWMgc3RyaW5ncyB0byBudW1iZXJzXG4gKiBiZWZvcmUgc2V0dGluZyBiYWNrIHRvIGRhdGFcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfE51bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyc2VkID0gTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gaXNOYU4ocGFyc2VkKSA/IHZhbHVlIDogcGFyc2VkO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBzdHJpbmcgYm9vbGVhbiBsaXRlcmFscyBpbnRvIHJlYWwgYm9vbGVhbnMuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7KnxCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJyA/IHRydWUgOiB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWU7XG59XG5cbi8qKlxuICogU3RyaXAgcXVvdGVzIGZyb20gYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmcgfCBmYWxzZX1cbiAqL1xuXG5mdW5jdGlvbiBzdHJpcFF1b3RlcyhzdHIpIHtcbiAgdmFyIGEgPSBzdHIuY2hhckNvZGVBdCgwKTtcbiAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChzdHIubGVuZ3RoIC0gMSk7XG4gIHJldHVybiBhID09PSBiICYmIChhID09PSAweDIyIHx8IGEgPT09IDB4MjcpID8gc3RyLnNsaWNlKDEsIC0xKSA6IHN0cjtcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxtaXRlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIHRvVXBwZXIpO1xufVxuXG5mdW5jdGlvbiB0b1VwcGVyKF8sIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJztcbn1cblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgaHlwaGVuYXRlUkUgPSAvKFthLXpcXGRdKShbQS1aXSkvZztcblxuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgaHlwaGVuL3VuZGVyc2NvcmUvc2xhc2ggZGVsaW1pdGVyZWQgbmFtZXMgaW50b1xuICogY2FtZWxpemVkIGNsYXNzTmFtZXMuXG4gKlxuICogZS5nLiBteS1jb21wb25lbnQgPT4gTXlDb21wb25lbnRcbiAqICAgICAgc29tZV9lbHNlICAgID0+IFNvbWVFbHNlXG4gKiAgICAgIHNvbWUvY29tcCAgICA9PiBTb21lQ29tcFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX1xcL10pKFxcdykvZztcblxuZnVuY3Rpb24gY2xhc3NpZnkoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCB0b1VwcGVyKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHhcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGJpbmQoZm4sIGN0eCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGwgPyBsID4gMSA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKSA6IGZuLmNhbGwoY3R4LCBhKSA6IGZuLmNhbGwoY3R4KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LWxpa2V9IGxpc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdIC0gc3RhcnQgaW5kZXhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICovXG5cbmZ1bmN0aW9uIGV4dGVuZCh0bywgZnJvbSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdG9ba2V5c1tpXV0gPSBmcm9tW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HO1xufVxuXG4vKipcbiAqIEFycmF5IHR5cGUgY2hlY2suXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtlbnVtZXJhYmxlXVxuICovXG5cbmZ1bmN0aW9uIGRlZihvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBEZWJvdW5jZSBhIGZ1bmN0aW9uIHNvIGl0IG9ubHkgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlXG4gKiBpbnB1dCBzdG9wcyBhcnJpdmluZyBhZnRlciB0aGUgZ2l2ZW4gd2FpdCBwZXJpb2QuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHtOdW1iZXJ9IHdhaXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBfZGVib3VuY2UoZnVuYywgd2FpdCkge1xuICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG4gIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgIHZhciBsYXN0ID0gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcbiAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGlmICghdGltZW91dCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIE1hbnVhbCBpbmRleE9mIGJlY2F1c2UgaXQncyBzbGlnaHRseSBmYXN0ZXIgdGhhblxuICogbmF0aXZlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHsqfSBvYmpcbiAqL1xuXG5mdW5jdGlvbiBpbmRleE9mKGFyciwgb2JqKSB7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIE1ha2UgYSBjYW5jZWxsYWJsZSB2ZXJzaW9uIG9mIGFuIGFzeW5jIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjYW5jZWxsYWJsZShmbikge1xuICB2YXIgY2IgPSBmdW5jdGlvbiBjYigpIHtcbiAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuICBjYi5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgfTtcbiAgcmV0dXJuIGNiO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICpcbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgcmV0dXJuIGEgPT0gYiB8fCAoaXNPYmplY3QoYSkgJiYgaXNPYmplY3QoYikgPyBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYikgOiBmYWxzZSk7XG4gIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG59XG5cbnZhciBoYXNQcm90byA9ICgnX19wcm90b19fJyBpbiB7fSk7XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93KSAhPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vLyBVQSBzbmlmZmluZyBmb3Igd29ya2luZyBhcm91bmQgYnJvd3Nlci1zcGVjaWZpYyBxdWlya3NcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiBVQS5pbmRleE9mKCd0cmlkZW50JykgPiAwO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbnZhciBpc0lvcyA9IFVBICYmIC8oaXBob25lfGlwYWR8aXBvZHxpb3MpL2kudGVzdChVQSk7XG52YXIgaW9zVmVyc2lvbk1hdGNoID0gaXNJb3MgJiYgVUEubWF0Y2goL29zIChbXFxkX10rKS8pO1xudmFyIGlvc1ZlcnNpb24gPSBpb3NWZXJzaW9uTWF0Y2ggJiYgaW9zVmVyc2lvbk1hdGNoWzFdLnNwbGl0KCdfJyk7XG5cbi8vIGRldGVjdGluZyBpT1MgVUlXZWJWaWV3IGJ5IGluZGV4ZWREQlxudmFyIGhhc011dGF0aW9uT2JzZXJ2ZXJCdWcgPSBpb3NWZXJzaW9uICYmIE51bWJlcihpb3NWZXJzaW9uWzBdKSA+PSA5ICYmIE51bWJlcihpb3NWZXJzaW9uWzFdKSA+PSAzICYmICF3aW5kb3cuaW5kZXhlZERCO1xuXG52YXIgdHJhbnNpdGlvblByb3AgPSB1bmRlZmluZWQ7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gdW5kZWZpbmVkO1xudmFyIGFuaW1hdGlvblByb3AgPSB1bmRlZmluZWQ7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSB1bmRlZmluZWQ7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUU5KSB7XG4gIHZhciBpc1dlYmtpdFRyYW5zID0gd2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZDtcbiAgdmFyIGlzV2Via2l0QW5pbSA9IHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkO1xuICB0cmFuc2l0aW9uUHJvcCA9IGlzV2Via2l0VHJhbnMgPyAnV2Via2l0VHJhbnNpdGlvbicgOiAndHJhbnNpdGlvbic7XG4gIHRyYW5zaXRpb25FbmRFdmVudCA9IGlzV2Via2l0VHJhbnMgPyAnd2Via2l0VHJhbnNpdGlvbkVuZCcgOiAndHJhbnNpdGlvbmVuZCc7XG4gIGFuaW1hdGlvblByb3AgPSBpc1dlYmtpdEFuaW0gPyAnV2Via2l0QW5pbWF0aW9uJyA6ICdhbmltYXRpb24nO1xuICBhbmltYXRpb25FbmRFdmVudCA9IGlzV2Via2l0QW5pbSA/ICd3ZWJraXRBbmltYXRpb25FbmQnIDogJ2FuaW1hdGlvbmVuZCc7XG59XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuIElkZWFsbHkgdGhpc1xuICogc2hvdWxkIGJlIGV4ZWN1dGVkIGFzIGEgbWljcm90YXNrLCBzbyB3ZSBsZXZlcmFnZVxuICogTXV0YXRpb25PYnNlcnZlciBpZiBpdCdzIGF2YWlsYWJsZSwgYW5kIGZhbGxiYWNrIHRvXG4gKiBzZXRUaW1lb3V0KDApLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKi9cblxudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmICFoYXNNdXRhdGlvbk9ic2VydmVyQnVnKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY291bnRlcik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBjb3VudGVyO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gd2VicGFjayBhdHRlbXB0cyB0byBpbmplY3QgYSBzaGltIGZvciBzZXRJbW1lZGlhdGVcbiAgICAvLyBpZiBpdCBpcyB1c2VkIGFzIGEgZ2xvYmFsLCBzbyB3ZSBoYXZlIHRvIHdvcmsgYXJvdW5kIHRoYXQgdG9cbiAgICAvLyBhdm9pZCBidW5kbGluZyB1bm5lY2Vzc2FyeSBjb2RlLlxuICAgIHZhciBjb250ZXh0ID0gaW5Ccm93c2VyID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB7fTtcbiAgICB0aW1lckZ1bmMgPSBjb250ZXh0LnNldEltbWVkaWF0ZSB8fCBzZXRUaW1lb3V0O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoY2IsIGN0eCkge1xuICAgIHZhciBmdW5jID0gY3R4ID8gZnVuY3Rpb24gKCkge1xuICAgICAgY2IuY2FsbChjdHgpO1xuICAgIH0gOiBjYjtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jKTtcbiAgICBpZiAocGVuZGluZykgcmV0dXJuO1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIHRpbWVyRnVuYyhuZXh0VGlja0hhbmRsZXIsIDApO1xuICB9O1xufSkoKTtcblxudmFyIF9TZXQgPSB1bmRlZmluZWQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBTZXQudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH07XG4gIF9TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuICBfU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGhpcy5zZXRba2V5XSA9IDE7XG4gIH07XG4gIF9TZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQ2FjaGUobGltaXQpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2tleW1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbnZhciBwID0gQ2FjaGUucHJvdG90eXBlO1xuXG4vKipcbiAqIFB1dCA8dmFsdWU+IGludG8gdGhlIGNhY2hlIGFzc29jaWF0ZWQgd2l0aCA8a2V5Pi5cbiAqIFJldHVybnMgdGhlIGVudHJ5IHdoaWNoIHdhcyByZW1vdmVkIHRvIG1ha2Ugcm9vbSBmb3JcbiAqIHRoZSBuZXcgZW50cnkuIE90aGVyd2lzZSB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKiAoaS5lLiBpZiB0aGVyZSB3YXMgZW5vdWdoIHJvb20gYWxyZWFkeSkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7RW50cnl8dW5kZWZpbmVkfVxuICovXG5cbnAucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdmFyIHJlbW92ZWQ7XG5cbiAgdmFyIGVudHJ5ID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgaWYgKCFlbnRyeSkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IHRoaXMubGltaXQpIHtcbiAgICAgIHJlbW92ZWQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGVudHJ5ID0ge1xuICAgICAga2V5OiBrZXlcbiAgICB9O1xuICAgIHRoaXMuX2tleW1hcFtrZXldID0gZW50cnk7XG4gICAgaWYgKHRoaXMudGFpbCkge1xuICAgICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnk7XG4gICAgICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgfVxuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuc2l6ZSsrO1xuICB9XG4gIGVudHJ5LnZhbHVlID0gdmFsdWU7XG5cbiAgcmV0dXJuIHJlbW92ZWQ7XG59O1xuXG4vKipcbiAqIFB1cmdlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIChvbGRlc3QpIGVudHJ5IGZyb20gdGhlXG4gKiBjYWNoZS4gUmV0dXJucyB0aGUgcmVtb3ZlZCBlbnRyeSBvciB1bmRlZmluZWQgaWYgdGhlXG4gKiBjYWNoZSB3YXMgZW1wdHkuXG4gKi9cblxucC5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVudHJ5ID0gdGhpcy5oZWFkO1xuICBpZiAoZW50cnkpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV3ZXI7XG4gICAgdGhpcy5oZWFkLm9sZGVyID0gdW5kZWZpbmVkO1xuICAgIGVudHJ5Lm5ld2VyID0gZW50cnkub2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fa2V5bWFwW2VudHJ5LmtleV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zaXplLS07XG4gIH1cbiAgcmV0dXJuIGVudHJ5O1xufTtcblxuLyoqXG4gKiBHZXQgYW5kIHJlZ2lzdGVyIHJlY2VudCB1c2Ugb2YgPGtleT4uIFJldHVybnMgdGhlIHZhbHVlXG4gKiBhc3NvY2lhdGVkIHdpdGggPGtleT4gb3IgdW5kZWZpbmVkIGlmIG5vdCBpbiBjYWNoZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkVudHJ5XG4gKiBAcmV0dXJuIHtFbnRyeXwqfVxuICovXG5cbnAuZ2V0ID0gZnVuY3Rpb24gKGtleSwgcmV0dXJuRW50cnkpIHtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fa2V5bWFwW2tleV07XG4gIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIGlmIChlbnRyeSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuIHJldHVybkVudHJ5ID8gZW50cnkgOiBlbnRyeS52YWx1ZTtcbiAgfVxuICAvLyBIRUFELS0tLS0tLS0tLS0tLS1UQUlMXG4gIC8vICAgPC5vbGRlciAgIC5uZXdlcj5cbiAgLy8gIDwtLS0gYWRkIGRpcmVjdGlvbiAtLVxuICAvLyAgIEEgIEIgIEMgIDxEPiAgRVxuICBpZiAoZW50cnkubmV3ZXIpIHtcbiAgICBpZiAoZW50cnkgPT09IHRoaXMuaGVhZCkge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gZW50cnkub2xkZXI7IC8vIEMgPC0tIEUuXG4gIH1cbiAgaWYgKGVudHJ5Lm9sZGVyKSB7XG4gICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjsgLy8gQy4gLS0+IEVcbiAgfVxuICBlbnRyeS5uZXdlciA9IHVuZGVmaW5lZDsgLy8gRCAtLXhcbiAgZW50cnkub2xkZXIgPSB0aGlzLnRhaWw7IC8vIEQuIC0tPiBFXG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV3ZXIgPSBlbnRyeTsgLy8gRS4gPC0tIERcbiAgfVxuICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgcmV0dXJuIHJldHVybkVudHJ5ID8gZW50cnkgOiBlbnRyeS52YWx1ZTtcbn07XG5cbnZhciBjYWNoZSQxID0gbmV3IENhY2hlKDEwMDApO1xudmFyIGZpbHRlclRva2VuUkUgPSAvW15cXHMnXCJdK3wnW14nXSonfFwiW15cIl0qXCIvZztcbnZhciByZXNlcnZlZEFyZ1JFID0gL15pbiR8Xi0/XFxkKy87XG5cbi8qKlxuICogUGFyc2VyIHN0YXRlXG4gKi9cblxudmFyIHN0cjtcbnZhciBkaXI7XG52YXIgYztcbnZhciBwcmV2O1xudmFyIGk7XG52YXIgbDtcbnZhciBsYXN0RmlsdGVySW5kZXg7XG52YXIgaW5TaW5nbGU7XG52YXIgaW5Eb3VibGU7XG52YXIgY3VybHk7XG52YXIgc3F1YXJlO1xudmFyIHBhcmVuO1xuLyoqXG4gKiBQdXNoIGEgZmlsdGVyIHRvIHRoZSBjdXJyZW50IGRpcmVjdGl2ZSBvYmplY3RcbiAqL1xuXG5mdW5jdGlvbiBwdXNoRmlsdGVyKCkge1xuICB2YXIgZXhwID0gc3RyLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpO1xuICB2YXIgZmlsdGVyO1xuICBpZiAoZXhwKSB7XG4gICAgZmlsdGVyID0ge307XG4gICAgdmFyIHRva2VucyA9IGV4cC5tYXRjaChmaWx0ZXJUb2tlblJFKTtcbiAgICBmaWx0ZXIubmFtZSA9IHRva2Vuc1swXTtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZpbHRlci5hcmdzID0gdG9rZW5zLnNsaWNlKDEpLm1hcChwcm9jZXNzRmlsdGVyQXJnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlcikge1xuICAgIChkaXIuZmlsdGVycyA9IGRpci5maWx0ZXJzIHx8IFtdKS5wdXNoKGZpbHRlcik7XG4gIH1cbiAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gYXJndW1lbnQgaXMgZHluYW1pYyBhbmQgc3RyaXAgcXVvdGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhcmdcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzRmlsdGVyQXJnKGFyZykge1xuICBpZiAocmVzZXJ2ZWRBcmdSRS50ZXN0KGFyZykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHRvTnVtYmVyKGFyZyksXG4gICAgICBkeW5hbWljOiBmYWxzZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0cmlwcGVkID0gc3RyaXBRdW90ZXMoYXJnKTtcbiAgICB2YXIgZHluYW1pYyA9IHN0cmlwcGVkID09PSBhcmc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBkeW5hbWljID8gYXJnIDogc3RyaXBwZWQsXG4gICAgICBkeW5hbWljOiBkeW5hbWljXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgZGlyZWN0aXZlIHZhbHVlIGFuZCBleHRyYWN0IHRoZSBleHByZXNzaW9uXG4gKiBhbmQgaXRzIGZpbHRlcnMgaW50byBhIGRlc2NyaXB0b3IuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBcImEgKyAxIHwgdXBwZXJjYXNlXCIgd2lsbCB5aWVsZDpcbiAqIHtcbiAqICAgZXhwcmVzc2lvbjogJ2EgKyAxJyxcbiAqICAgZmlsdGVyczogW1xuICogICAgIHsgbmFtZTogJ3VwcGVyY2FzZScsIGFyZ3M6IG51bGwgfVxuICogICBdXG4gKiB9XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZURpcmVjdGl2ZShzKSB7XG4gIHZhciBoaXQgPSBjYWNoZSQxLmdldChzKTtcbiAgaWYgKGhpdCkge1xuICAgIHJldHVybiBoaXQ7XG4gIH1cblxuICAvLyByZXNldCBwYXJzZXIgc3RhdGVcbiAgc3RyID0gcztcbiAgaW5TaW5nbGUgPSBpbkRvdWJsZSA9IGZhbHNlO1xuICBjdXJseSA9IHNxdWFyZSA9IHBhcmVuID0gMDtcbiAgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgZGlyID0ge307XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICAvLyBjaGVjayBzaW5nbGUgcXVvdGVcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIGluU2luZ2xlID0gIWluU2luZ2xlO1xuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIC8vIGNoZWNrIGRvdWJsZSBxdW90ZVxuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgaW5Eb3VibGUgPSAhaW5Eb3VibGU7XG4gICAgfSBlbHNlIGlmIChjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICBzdHIuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiYgc3RyLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDKSB7XG4gICAgICBpZiAoZGlyLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhbHJlYWR5IGhhcyBmaWx0ZXJcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOlxuICAgICAgICAgIGluRG91YmxlID0gdHJ1ZTticmVhazsgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OlxuICAgICAgICAgIGluU2luZ2xlID0gdHJ1ZTticmVhazsgLy8gJ1xuICAgICAgICBjYXNlIDB4Mjg6XG4gICAgICAgICAgcGFyZW4rKzticmVhazsgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6XG4gICAgICAgICAgcGFyZW4tLTticmVhazsgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6XG4gICAgICAgICAgc3F1YXJlKys7YnJlYWs7IC8vIFtcbiAgICAgICAgY2FzZSAweDVEOlxuICAgICAgICAgIHNxdWFyZS0tO2JyZWFrOyAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjpcbiAgICAgICAgICBjdXJseSsrO2JyZWFrOyAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDpcbiAgICAgICAgICBjdXJseS0tO2JyZWFrOyAvLyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpci5leHByZXNzaW9uID09IG51bGwpIHtcbiAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgY2FjaGUkMS5wdXQocywgZGlyKTtcbiAgcmV0dXJuIGRpcjtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IE9iamVjdC5mcmVlemUoe1xuICBwYXJzZURpcmVjdGl2ZTogcGFyc2VEaXJlY3RpdmVcbn0pO1xuXG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG52YXIgY2FjaGUgPSB1bmRlZmluZWQ7XG52YXIgdGFnUkUgPSB1bmRlZmluZWQ7XG52YXIgaHRtbFJFID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBFc2NhcGUgYSBzdHJpbmcgc28gaXQgY2FuIGJlIHVzZWQgaW4gYSBSZWdFeHBcbiAqIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZVJlZ2V4KCkge1xuICB2YXIgb3BlbiA9IGVzY2FwZVJlZ2V4KGNvbmZpZy5kZWxpbWl0ZXJzWzBdKTtcbiAgdmFyIGNsb3NlID0gZXNjYXBlUmVnZXgoY29uZmlnLmRlbGltaXRlcnNbMV0pO1xuICB2YXIgdW5zYWZlT3BlbiA9IGVzY2FwZVJlZ2V4KGNvbmZpZy51bnNhZmVEZWxpbWl0ZXJzWzBdKTtcbiAgdmFyIHVuc2FmZUNsb3NlID0gZXNjYXBlUmVnZXgoY29uZmlnLnVuc2FmZURlbGltaXRlcnNbMV0pO1xuICB0YWdSRSA9IG5ldyBSZWdFeHAodW5zYWZlT3BlbiArICcoKD86LnxcXFxcbikrPyknICsgdW5zYWZlQ2xvc2UgKyAnfCcgKyBvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKTtcbiAgaHRtbFJFID0gbmV3IFJlZ0V4cCgnXicgKyB1bnNhZmVPcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyB1bnNhZmVDbG9zZSArICckJyk7XG4gIC8vIHJlc2V0IGNhY2hlXG4gIGNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgdGVtcGxhdGUgdGV4dCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB0b2tlbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD4gfCBudWxsfVxuICogICAgICAgICAgICAgICAtIHtTdHJpbmd9IHR5cGVcbiAqICAgICAgICAgICAgICAgLSB7U3RyaW5nfSB2YWx1ZVxuICogICAgICAgICAgICAgICAtIHtCb29sZWFufSBbaHRtbF1cbiAqICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW29uZVRpbWVdXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQpIHtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNvbXBpbGVSZWdleCgpO1xuICB9XG4gIHZhciBoaXQgPSBjYWNoZS5nZXQodGV4dCk7XG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0O1xuICB9XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXgsIGh0bWwsIHZhbHVlLCBmaXJzdCwgb25lVGltZTtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgd2hpbGUgKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkge1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB2YWx1ZTogdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIGh0bWwgPSBodG1sUkUudGVzdChtYXRjaFswXSk7XG4gICAgdmFsdWUgPSBodG1sID8gbWF0Y2hbMV0gOiBtYXRjaFsyXTtcbiAgICBmaXJzdCA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgb25lVGltZSA9IGZpcnN0ID09PSA0MjsgLy8gKlxuICAgIHZhbHVlID0gb25lVGltZSA/IHZhbHVlLnNsaWNlKDEpIDogdmFsdWU7XG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdGFnOiB0cnVlLFxuICAgICAgdmFsdWU6IHZhbHVlLnRyaW0oKSxcbiAgICAgIGh0bWw6IGh0bWwsXG4gICAgICBvbmVUaW1lOiBvbmVUaW1lXG4gICAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdmFsdWU6IHRleHQuc2xpY2UobGFzdEluZGV4KVxuICAgIH0pO1xuICB9XG4gIGNhY2hlLnB1dCh0ZXh0LCB0b2tlbnMpO1xuICByZXR1cm4gdG9rZW5zO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIGxpc3Qgb2YgdG9rZW5zIGludG8gYW4gZXhwcmVzc2lvbi5cbiAqIGUuZy4gdG9rZW5zIHBhcnNlZCBmcm9tICdhIHt7Yn19IGMnIGNhbiBiZSBzZXJpYWxpemVkXG4gKiBpbnRvIG9uZSBzaW5nbGUgZXhwcmVzc2lvbiBhcyAnXCJhIFwiICsgYiArIFwiIGNcIicuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHRva2Vuc1RvRXhwKHRva2Vucywgdm0pIHtcbiAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICByZXR1cm4gZm9ybWF0VG9rZW4odG9rZW4sIHZtKTtcbiAgICB9KS5qb2luKCcrJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZvcm1hdFRva2VuKHRva2Vuc1swXSwgdm0sIHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IGEgc2luZ2xlIHRva2VuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlblxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbmdsZV1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRUb2tlbih0b2tlbiwgdm0sIHNpbmdsZSkge1xuICByZXR1cm4gdG9rZW4udGFnID8gdG9rZW4ub25lVGltZSAmJiB2bSA/ICdcIicgKyB2bS4kZXZhbCh0b2tlbi52YWx1ZSkgKyAnXCInIDogaW5saW5lRmlsdGVycyh0b2tlbi52YWx1ZSwgc2luZ2xlKSA6ICdcIicgKyB0b2tlbi52YWx1ZSArICdcIic7XG59XG5cbi8qKlxuICogRm9yIGFuIGF0dHJpYnV0ZSB3aXRoIG11bHRpcGxlIGludGVycG9sYXRpb24gdGFncyxcbiAqIGUuZy4gYXR0cj1cInNvbWUte3t0aGluZyB8IGZpbHRlcn19XCIsIGluIG9yZGVyIHRvIGNvbWJpbmVcbiAqIHRoZSB3aG9sZSB0aGluZyBpbnRvIGEgc2luZ2xlIHdhdGNoYWJsZSBleHByZXNzaW9uLCB3ZVxuICogaGF2ZSB0byBpbmxpbmUgdGhvc2UgZmlsdGVycy4gVGhpcyBmdW5jdGlvbiBkb2VzIGV4YWN0bHlcbiAqIHRoYXQuIFRoaXMgaXMgYSBiaXQgaGFja3kgYnV0IGl0IGF2b2lkcyBoZWF2eSBjaGFuZ2VzXG4gKiB0byBkaXJlY3RpdmUgcGFyc2VyIGFuZCB3YXRjaGVyIG1lY2hhbmlzbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNpbmdsZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBmaWx0ZXJSRSA9IC9bXnxdXFx8W158XS87XG5mdW5jdGlvbiBpbmxpbmVGaWx0ZXJzKGV4cCwgc2luZ2xlKSB7XG4gIGlmICghZmlsdGVyUkUudGVzdChleHApKSB7XG4gICAgcmV0dXJuIHNpbmdsZSA/IGV4cCA6ICcoJyArIGV4cCArICcpJztcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlyID0gcGFyc2VEaXJlY3RpdmUoZXhwKTtcbiAgICBpZiAoIWRpci5maWx0ZXJzKSB7XG4gICAgICByZXR1cm4gJygnICsgZXhwICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3RoaXMuX2FwcGx5RmlsdGVycygnICsgZGlyLmV4cHJlc3Npb24gKyAvLyB2YWx1ZVxuICAgICAgJyxudWxsLCcgKyAvLyBvbGRWYWx1ZSAobnVsbCBmb3IgcmVhZClcbiAgICAgIEpTT04uc3RyaW5naWZ5KGRpci5maWx0ZXJzKSArIC8vIGZpbHRlciBkZXNjcmlwdG9yc1xuICAgICAgJyxmYWxzZSknOyAvLyB3cml0ZT9cbiAgICB9XG4gIH1cbn1cblxudmFyIHRleHQgPSBPYmplY3QuZnJlZXplKHtcbiAgY29tcGlsZVJlZ2V4OiBjb21waWxlUmVnZXgsXG4gIHBhcnNlVGV4dDogcGFyc2VUZXh0LFxuICB0b2tlbnNUb0V4cDogdG9rZW5zVG9FeHBcbn0pO1xuXG52YXIgZGVsaW1pdGVycyA9IFsne3snLCAnfX0nXTtcbnZhciB1bnNhZmVEZWxpbWl0ZXJzID0gWyd7e3snLCAnfX19J107XG5cbnZhciBjb25maWcgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcHJpbnQgZGVidWcgbWVzc2FnZXMuXG4gICAqIEFsc28gZW5hYmxlcyBzdGFjayB0cmFjZSBmb3Igd2FybmluZ3MuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICBkZWJ1ZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBhc3luYyByZW5kZXJpbmcuXG4gICAqL1xuXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHdhcm4gYWdhaW5zdCBlcnJvcnMgY2F1Z2h0IHdoZW4gZXZhbHVhdGluZ1xuICAgKiBleHByZXNzaW9ucy5cbiAgICovXG5cbiAgd2FybkV4cHJlc3Npb25FcnJvcnM6IHRydWUsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYWxsb3cgZGV2dG9vbHMgaW5zcGVjdGlvbi5cbiAgICogRGlzYWJsZWQgYnkgZGVmYXVsdCBpbiBwcm9kdWN0aW9uIGJ1aWxkcy5cbiAgICovXG5cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIEludGVybmFsIGZsYWcgdG8gaW5kaWNhdGUgdGhlIGRlbGltaXRlcnMgaGF2ZSBiZWVuXG4gICAqIGNoYW5nZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICBfZGVsaW1pdGVyc0NoYW5nZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXNzZXQgdHlwZXMgdGhhdCBhIGNvbXBvbmVudCBjYW4gb3duLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuXG4gIF9hc3NldFR5cGVzOiBbJ2NvbXBvbmVudCcsICdkaXJlY3RpdmUnLCAnZWxlbWVudERpcmVjdGl2ZScsICdmaWx0ZXInLCAndHJhbnNpdGlvbicsICdwYXJ0aWFsJ10sXG5cbiAgLyoqXG4gICAqIHByb3AgYmluZGluZyBtb2Rlc1xuICAgKi9cblxuICBfcHJvcEJpbmRpbmdNb2Rlczoge1xuICAgIE9ORV9XQVk6IDAsXG4gICAgVFdPX1dBWTogMSxcbiAgICBPTkVfVElNRTogMlxuICB9LFxuXG4gIC8qKlxuICAgKiBNYXggY2lyY3VsYXIgdXBkYXRlcyBhbGxvd2VkIGluIGEgYmF0Y2hlciBmbHVzaCBjeWNsZS5cbiAgICovXG5cbiAgX21heFVwZGF0ZUNvdW50OiAxMDBcblxufSwge1xuICBkZWxpbWl0ZXJzOiB7IC8qKlxuICAgICAgICAgICAgICAgICAqIEludGVycG9sYXRpb24gZGVsaW1pdGVycy4gQ2hhbmdpbmcgdGhlc2Ugd291bGQgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAqIHRoZSB0ZXh0IHBhcnNlciB0byByZS1jb21waWxlIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5PFN0cmluZz59XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBkZWxpbWl0ZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICBkZWxpbWl0ZXJzID0gdmFsO1xuICAgICAgY29tcGlsZVJlZ2V4KCk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9LFxuICB1bnNhZmVEZWxpbWl0ZXJzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdW5zYWZlRGVsaW1pdGVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgdW5zYWZlRGVsaW1pdGVycyA9IHZhbDtcbiAgICAgIGNvbXBpbGVSZWdleCgpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfVxufSk7XG5cbnZhciB3YXJuID0gdW5kZWZpbmVkO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSB1bmRlZmluZWQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICAgIGlmIChoYXNDb25zb2xlICYmICFjb25maWcuc2lsZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWdWUgd2Fybl06ICcgKyBtc2cgKyAodm0gPyBmb3JtYXRDb21wb25lbnROYW1lKHZtKSA6ICcnKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0pIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX2lzVnVlID8gdm0uJG9wdGlvbnMubmFtZSA6IHZtLm5hbWU7XG4gICAgICByZXR1cm4gbmFtZSA/ICcgKGZvdW5kIGluIGNvbXBvbmVudDogPCcgKyBoeXBoZW5hdGUobmFtZSkgKyAnPiknIDogJyc7XG4gICAgfTtcbiAgfSkoKTtcbn1cblxuLyoqXG4gKiBBcHBlbmQgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBhcHBlbmRXaXRoVHJhbnNpdGlvbihlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgYXBwbHlUcmFuc2l0aW9uKGVsLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgfSwgdm0sIGNiKTtcbn1cblxuLyoqXG4gKiBJbnNlcnRCZWZvcmUgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBiZWZvcmVXaXRoVHJhbnNpdGlvbihlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgYXBwbHlUcmFuc2l0aW9uKGVsLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQpO1xuICB9LCB2bSwgY2IpO1xufVxuXG4vKipcbiAqIFJlbW92ZSB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlV2l0aFRyYW5zaXRpb24oZWwsIHZtLCBjYikge1xuICBhcHBseVRyYW5zaXRpb24oZWwsIC0xLCBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlKGVsKTtcbiAgfSwgdm0sIGNiKTtcbn1cblxuLyoqXG4gKiBBcHBseSB0cmFuc2l0aW9ucyB3aXRoIGFuIG9wZXJhdGlvbiBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uXG4gKiAgICAgICAgICAgICAgICAgIDE6IGVudGVyXG4gKiAgICAgICAgICAgICAgICAgLTE6IGxlYXZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHRoZSBhY3R1YWwgRE9NIG9wZXJhdGlvblxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2l0aW9uKGVsLCBkaXJlY3Rpb24sIG9wLCB2bSwgY2IpIHtcbiAgdmFyIHRyYW5zaXRpb24gPSBlbC5fX3ZfdHJhbnM7XG4gIGlmICghdHJhbnNpdGlvbiB8fFxuICAvLyBza2lwIGlmIHRoZXJlIGFyZSBubyBqcyBob29rcyBhbmQgQ1NTIHRyYW5zaXRpb24gaXNcbiAgLy8gbm90IHN1cHBvcnRlZFxuICAhdHJhbnNpdGlvbi5ob29rcyAmJiAhdHJhbnNpdGlvbkVuZEV2ZW50IHx8XG4gIC8vIHNraXAgdHJhbnNpdGlvbnMgZm9yIGluaXRpYWwgY29tcGlsZVxuICAhdm0uX2lzQ29tcGlsZWQgfHxcbiAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIG1hbmlwdWxhdGVkIGJ5IGEgcGFyZW50IGRpcmVjdGl2ZVxuICAvLyBkdXJpbmcgdGhlIHBhcmVudCdzIGNvbXBpbGF0aW9uIHBoYXNlLCBza2lwIHRoZVxuICAvLyBhbmltYXRpb24uXG4gIHZtLiRwYXJlbnQgJiYgIXZtLiRwYXJlbnQuX2lzQ29tcGlsZWQpIHtcbiAgICBvcCgpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGFjdGlvbiA9IGRpcmVjdGlvbiA+IDAgPyAnZW50ZXInIDogJ2xlYXZlJztcbiAgdHJhbnNpdGlvblthY3Rpb25dKG9wLCBjYik7XG59XG5cbnZhciB0cmFuc2l0aW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGFwcGVuZFdpdGhUcmFuc2l0aW9uOiBhcHBlbmRXaXRoVHJhbnNpdGlvbixcbiAgYmVmb3JlV2l0aFRyYW5zaXRpb246IGJlZm9yZVdpdGhUcmFuc2l0aW9uLFxuICByZW1vdmVXaXRoVHJhbnNpdGlvbjogcmVtb3ZlV2l0aFRyYW5zaXRpb24sXG4gIGFwcGx5VHJhbnNpdGlvbjogYXBwbHlUcmFuc2l0aW9uXG59KTtcblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBxdWVyeShlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RvciA9IGVsO1xuICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgc2VsZWN0b3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAqIE5vdGU6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyBzaG91bGQgd29yayBoZXJlXG4gKiBidXQgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGNvbW1lbnQgbm9kZXMgaW4gcGhhbnRvbWpzLFxuICogbWFraW5nIHVuaXQgdGVzdHMgZGlmZmljdWx0LiBUaGlzIGlzIGZpeGVkIGJ5IGRvaW5nIHRoZVxuICogY29udGFpbnMoKSBjaGVjayBvbiB0aGUgbm9kZSdzIHBhcmVudE5vZGUgaW5zdGVhZCBvZlxuICogdGhlIG5vZGUgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpbkRvYyhub2RlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgcmV0dXJuIGRvYyA9PT0gbm9kZSB8fCBkb2MgPT09IHBhcmVudCB8fCAhIShwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxICYmIGRvYy5jb250YWlucyhwYXJlbnQpKTtcbn1cblxuLyoqXG4gKiBHZXQgYW5kIHJlbW92ZSBhbiBhdHRyaWJ1dGUgZnJvbSBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gX2F0dHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRBdHRyKG5vZGUsIF9hdHRyKSB7XG4gIHZhciB2YWwgPSBub2RlLmdldEF0dHJpYnV0ZShfYXR0cik7XG4gIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShfYXR0cik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBHZXQgYW4gYXR0cmlidXRlIHdpdGggY29sb24gb3Igdi1iaW5kOiBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cblxuZnVuY3Rpb24gZ2V0QmluZEF0dHIobm9kZSwgbmFtZSkge1xuICB2YXIgdmFsID0gZ2V0QXR0cihub2RlLCAnOicgKyBuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHZhbCA9IGdldEF0dHIobm9kZSwgJ3YtYmluZDonICsgbmFtZSk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBDaGVjayB0aGUgcHJlc2VuY2Ugb2YgYSBiaW5kIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmRBdHRyKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuaGFzQXR0cmlidXRlKG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKCc6JyArIG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2LWJpbmQ6JyArIG5hbWUpO1xufVxuXG4vKipcbiAqIEluc2VydCBlbCBiZWZvcmUgdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBiZWZvcmUoZWwsIHRhcmdldCkge1xuICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHRhcmdldCk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGVsIGFmdGVyIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gYWZ0ZXIoZWwsIHRhcmdldCkge1xuICBpZiAodGFyZ2V0Lm5leHRTaWJsaW5nKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQubmV4dFNpYmxpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBlbCBmcm9tIERPTVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmUoZWwpIHtcbiAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG59XG5cbi8qKlxuICogUHJlcGVuZCBlbCB0byB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIHByZXBlbmQoZWwsIHRhcmdldCkge1xuICBpZiAodGFyZ2V0LmZpcnN0Q2hpbGQpIHtcbiAgICBiZWZvcmUoZWwsIHRhcmdldC5maXJzdENoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG59XG5cbi8qKlxuICogUmVwbGFjZSB0YXJnZXQgd2l0aCBlbFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gcmVwbGFjZSh0YXJnZXQsIGVsKSB7XG4gIHZhciBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoZWwsIHRhcmdldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXIgc2hvcnRoYW5kLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdXG4gKi9cblxuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBjYiwgdXNlQ2FwdHVyZSkge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYiwgdXNlQ2FwdHVyZSk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIHNob3J0aGFuZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZnVuY3Rpb24gb2ZmKGVsLCBldmVudCwgY2IpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2IpO1xufVxuXG4vKipcbiAqIEZvciBJRTkgY29tcGF0OiB3aGVuIGJvdGggY2xhc3MgYW5kIDpjbGFzcyBhcmUgcHJlc2VudFxuICogZ2V0QXR0cmlidXRlKCdjbGFzcycpIHJldHVybnMgd3JvbmcgdmFsdWUuLi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoZWwpIHtcbiAgdmFyIGNsYXNzbmFtZSA9IGVsLmNsYXNzTmFtZTtcbiAgaWYgKHR5cGVvZiBjbGFzc25hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgY2xhc3NuYW1lID0gY2xhc3NuYW1lLmJhc2VWYWwgfHwgJyc7XG4gIH1cbiAgcmV0dXJuIGNsYXNzbmFtZTtcbn1cblxuLyoqXG4gKiBJbiBJRTksIHNldEF0dHJpYnV0ZSgnY2xhc3MnKSB3aWxsIHJlc3VsdCBpbiBlbXB0eSBjbGFzc1xuICogaWYgdGhlIGVsZW1lbnQgYWxzbyBoYXMgdGhlIDpjbGFzcyBhdHRyaWJ1dGU7IEhvd2V2ZXIgaW5cbiAqIFBoYW50b21KUywgc2V0dGluZyBgY2xhc3NOYW1lYCBkb2VzIG5vdCB3b3JrIG9uIFNWRyBlbGVtZW50cy4uLlxuICogU28gd2UgaGF2ZSB0byBkbyBhIGNvbmRpdGlvbmFsIGNoZWNrIGhlcmUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICovXG5cbmZ1bmN0aW9uIHNldENsYXNzKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiAhL3N2ZyQvLnRlc3QoZWwubmFtZXNwYWNlVVJJKSkge1xuICAgIGVsLmNsYXNzTmFtZSA9IGNscztcbiAgfSBlbHNlIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIElFICYgU1ZHXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICovXG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbHMpIHtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgc2V0Q2xhc3MoZWwsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNscykge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSAnICcgKyBnZXRDbGFzcyhlbCkgKyAnICc7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIHNldENsYXNzKGVsLCBjdXIudHJpbSgpKTtcbiAgfVxuICBpZiAoIWVsLmNsYXNzTmFtZSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgcmF3IGNvbnRlbnQgaW5zaWRlIGFuIGVsZW1lbnQgaW50byBhIHRlbXBvcmFyeVxuICogY29udGFpbmVyIGRpdlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNGcmFnbWVudFxuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RDb250ZW50KGVsLCBhc0ZyYWdtZW50KSB7XG4gIHZhciBjaGlsZDtcbiAgdmFyIHJhd0NvbnRlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNUZW1wbGF0ZShlbCkgJiYgaXNGcmFnbWVudChlbC5jb250ZW50KSkge1xuICAgIGVsID0gZWwuY29udGVudDtcbiAgfVxuICBpZiAoZWwuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgdHJpbU5vZGUoZWwpO1xuICAgIHJhd0NvbnRlbnQgPSBhc0ZyYWdtZW50ID8gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICB3aGlsZSAoY2hpbGQgPSBlbC5maXJzdENoaWxkKSB7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgICByYXdDb250ZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhd0NvbnRlbnQ7XG59XG5cbi8qKlxuICogVHJpbSBwb3NzaWJsZSBlbXB0eSBoZWFkL3RhaWwgdGV4dCBhbmQgY29tbWVudFxuICogbm9kZXMgaW5zaWRlIGEgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICovXG5cbmZ1bmN0aW9uIHRyaW1Ob2RlKG5vZGUpIHtcbiAgdmFyIGNoaWxkO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZXF1ZW5jZXMgKi9cbiAgd2hpbGUgKChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCwgaXNUcmltbWFibGUoY2hpbGQpKSkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG4gIHdoaWxlICgoY2hpbGQgPSBub2RlLmxhc3RDaGlsZCwgaXNUcmltbWFibGUoY2hpbGQpKSkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tc2VxdWVuY2VzICovXG59XG5cbmZ1bmN0aW9uIGlzVHJpbW1hYmxlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IDMgJiYgIW5vZGUuZGF0YS50cmltKCkgfHwgbm9kZS5ub2RlVHlwZSA9PT0gOCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIHRlbXBsYXRlIHRhZy5cbiAqIE5vdGUgaWYgdGhlIHRlbXBsYXRlIGFwcGVhcnMgaW5zaWRlIGFuIFNWRyBpdHMgdGFnTmFtZVxuICogd2lsbCBiZSBpbiBsb3dlcmNhc2UuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIGlzVGVtcGxhdGUoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGVtcGxhdGUnO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBcImFuY2hvclwiIGZvciBwZXJmb3JtaW5nIGRvbSBpbnNlcnRpb24vcmVtb3ZhbHMuXG4gKiBUaGlzIGlzIHVzZWQgaW4gYSBudW1iZXIgb2Ygc2NlbmFyaW9zOlxuICogLSBmcmFnbWVudCBpbnN0YW5jZVxuICogLSB2LWh0bWxcbiAqIC0gdi1pZlxuICogLSB2LWZvclxuICogLSBjb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtCb29sZWFufSBwZXJzaXN0IC0gSUUgdHJhc2hlcyBlbXB0eSB0ZXh0Tm9kZXMgb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lTm9kZSh0cnVlKSwgc28gaW4gY2VydGFpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZXMgdGhlIGFuY2hvciBuZWVkcyB0byBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uLWVtcHR5IHRvIGJlIHBlcnNpc3RlZCBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLlxuICogQHJldHVybiB7Q29tbWVudHxUZXh0fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUFuY2hvcihjb250ZW50LCBwZXJzaXN0KSB7XG4gIHZhciBhbmNob3IgPSBjb25maWcuZGVidWcgPyBkb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRlbnQpIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGVyc2lzdCA/ICcgJyA6ICcnKTtcbiAgYW5jaG9yLl9fdl9hbmNob3IgPSB0cnVlO1xuICByZXR1cm4gYW5jaG9yO1xufVxuXG4vKipcbiAqIEZpbmQgYSBjb21wb25lbnQgcmVmIGF0dHJpYnV0ZSB0aGF0IHN0YXJ0cyB3aXRoICQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd8dW5kZWZpbmVkfVxuICovXG5cbnZhciByZWZSRSA9IC9edi1yZWY6LztcblxuZnVuY3Rpb24gZmluZFJlZihub2RlKSB7XG4gIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgaWYgKHJlZlJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGNhbWVsaXplKG5hbWUucmVwbGFjZShyZWZSRSwgJycpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYXAgYSBmdW5jdGlvbiB0byBhIHJhbmdlIG9mIG5vZGVzIC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcFxuICovXG5cbmZ1bmN0aW9uIG1hcE5vZGVSYW5nZShub2RlLCBlbmQsIG9wKSB7XG4gIHZhciBuZXh0O1xuICB3aGlsZSAobm9kZSAhPT0gZW5kKSB7XG4gICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgb3Aobm9kZSk7XG4gICAgbm9kZSA9IG5leHQ7XG4gIH1cbiAgb3AoZW5kKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSByYW5nZSBvZiBub2RlcyB3aXRoIHRyYW5zaXRpb24sIHN0b3JlXG4gKiB0aGUgbm9kZXMgaW4gYSBmcmFnbWVudCB3aXRoIGNvcnJlY3Qgb3JkZXJpbmcsXG4gKiBhbmQgY2FsbCBjYWxsYmFjayB3aGVuIGRvbmUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBzdGFydFxuICogQHBhcmFtIHtOb2RlfSBlbmRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGVSYW5nZShzdGFydCwgZW5kLCB2bSwgZnJhZywgY2IpIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdmFyIHJlbW92ZWQgPSAwO1xuICB2YXIgbm9kZXMgPSBbXTtcbiAgbWFwTm9kZVJhbmdlKHN0YXJ0LCBlbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVuZCkgZG9uZSA9IHRydWU7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgICByZW1vdmVXaXRoVHJhbnNpdGlvbihub2RlLCB2bSwgb25SZW1vdmVkKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIG9uUmVtb3ZlZCgpIHtcbiAgICByZW1vdmVkKys7XG4gICAgaWYgKGRvbmUgJiYgcmVtb3ZlZCA+PSBub2Rlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgICBjYiAmJiBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIERvY3VtZW50RnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzRnJhZ21lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAxMTtcbn1cblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldE91dGVySFRNTChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG4gIH1cbn1cblxudmFyIGNvbW1vblRhZ1JFID0gL14oZGl2fHB8c3BhbnxpbWd8YXxifGl8YnJ8dWx8b2x8bGl8aDF8aDJ8aDN8aDR8aDV8aDZ8Y29kZXxwcmV8dGFibGV8dGh8dGR8dHJ8Zm9ybXxsYWJlbHxpbnB1dHxzZWxlY3R8b3B0aW9ufG5hdnxhcnRpY2xlfHNlY3Rpb258aGVhZGVyfGZvb3RlcikkL2k7XG52YXIgcmVzZXJ2ZWRUYWdSRSA9IC9eKHNsb3R8cGFydGlhbHxjb21wb25lbnQpJC9pO1xuXG52YXIgaXNVbmtub3duRWxlbWVudCA9IHVuZGVmaW5lZDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlzVW5rbm93bkVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIHRhZykge1xuICAgIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICAgIHJldHVybiBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fCBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkgJiZcbiAgICAgICAgLy8gQ2hyb21lIHJldHVybnMgdW5rbm93biBmb3Igc2V2ZXJhbCBIVE1MNSBlbGVtZW50cy5cbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU0MDUyNlxuICAgICAgICAvLyBGaXJlZm94IHJldHVybnMgdW5rbm93biBmb3Igc29tZSBcIkludGVyYWN0aXZlIGVsZW1lbnRzLlwiXG4gICAgICAgICEvXihkYXRhfHRpbWV8cnRjfHJifGRldGFpbHN8ZGlhbG9nfHN1bW1hcnkpJC8udGVzdCh0YWcpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGEgY29tcG9uZW50LCBpZiB5ZXMgcmV0dXJuIGl0c1xuICogY29tcG9uZW50IGlkLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50QXR0cihlbCwgb3B0aW9ucykge1xuICB2YXIgdGFnID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaGFzQXR0cnMgPSBlbC5oYXNBdHRyaWJ1dGVzKCk7XG4gIGlmICghY29tbW9uVGFnUkUudGVzdCh0YWcpICYmICFyZXNlcnZlZFRhZ1JFLnRlc3QodGFnKSkge1xuICAgIGlmIChyZXNvbHZlQXNzZXQob3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSB7XG4gICAgICByZXR1cm4geyBpZDogdGFnIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpcyA9IGhhc0F0dHJzICYmIGdldElzQmluZGluZyhlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoaXMpIHtcbiAgICAgICAgcmV0dXJuIGlzO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBleHBlY3RlZFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudE5hbWVNYXAgJiYgb3B0aW9ucy5fY29tcG9uZW50TmFtZU1hcFt0YWddO1xuICAgICAgICBpZiAoZXhwZWN0ZWRUYWcpIHtcbiAgICAgICAgICB3YXJuKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gJyArICdkaWQgeW91IG1lYW4gPCcgKyBleHBlY3RlZFRhZyArICc+PyAnICsgJ0hUTUwgaXMgY2FzZS1pbnNlbnNpdGl2ZSwgcmVtZW1iZXIgdG8gdXNlIGtlYmFiLWNhc2UgaW4gdGVtcGxhdGVzLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVW5rbm93bkVsZW1lbnQoZWwsIHRhZykpIHtcbiAgICAgICAgICB3YXJuKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICsgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgKyAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChoYXNBdHRycykge1xuICAgIHJldHVybiBnZXRJc0JpbmRpbmcoZWwsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IFwiaXNcIiBiaW5kaW5nIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRJc0JpbmRpbmcoZWwsIG9wdGlvbnMpIHtcbiAgLy8gZHluYW1pYyBzeW50YXhcbiAgdmFyIGV4cCA9IGVsLmdldEF0dHJpYnV0ZSgnaXMnKTtcbiAgaWYgKGV4cCAhPSBudWxsKSB7XG4gICAgaWYgKHJlc29sdmVBc3NldChvcHRpb25zLCAnY29tcG9uZW50cycsIGV4cCkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnaXMnKTtcbiAgICAgIHJldHVybiB7IGlkOiBleHAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXhwID0gZ2V0QmluZEF0dHIoZWwsICdpcycpO1xuICAgIGlmIChleHAgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgaWQ6IGV4cCwgZHluYW1pYzogdHJ1ZSB9O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqXG4gKiBBbGwgc3RyYXRlZ3kgZnVuY3Rpb25zIGZvbGxvdyB0aGUgc2FtZSBzaWduYXR1cmU6XG4gKlxuICogQHBhcmFtIHsqfSBwYXJlbnRWYWxcbiAqIEBwYXJhbSB7Kn0gY2hpbGRWYWxcbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKi9cblxudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlRGF0YSh0bywgZnJvbSkge1xuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgZm9yIChrZXkgaW4gZnJvbSkge1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh0b1ZhbCkgJiYgaXNPYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICsgJ2RlZmluaXRpb25zLicsIHZtKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShjaGlsZFZhbC5jYWxsKHRoaXMpLCBwYXJlbnRWYWwuY2FsbCh0aGlzKSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4oKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodm0pIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodm0pIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogRWxcbiAqL1xuXG5zdHJhdHMuZWwgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSAmJiBjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1RoZSBcImVsXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICsgJ2RlZmluaXRpb25zLicsIHZtKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJldCA9IGNoaWxkVmFsIHx8IHBhcmVudFZhbDtcbiAgLy8gaW52b2tlIHRoZSBlbGVtZW50IGZhY3RvcnkgaWYgdGhpcyBpcyBpbnN0YW5jZSBtZXJnZVxuICByZXR1cm4gdm0gJiYgdHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyA/IHJldC5jYWxsKHZtKSA6IHJldDtcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHBhcmFtIGF0dHJpYnV0ZXMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cblxuc3RyYXRzLmluaXQgPSBzdHJhdHMuY3JlYXRlZCA9IHN0cmF0cy5yZWFkeSA9IHN0cmF0cy5hdHRhY2hlZCA9IHN0cmF0cy5kZXRhY2hlZCA9IHN0cmF0cy5iZWZvcmVDb21waWxlID0gc3RyYXRzLmNvbXBpbGVkID0gc3RyYXRzLmJlZm9yZURlc3Ryb3kgPSBzdHJhdHMuZGVzdHJveWVkID0gc3RyYXRzLmFjdGl2YXRlID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID8gcGFyZW50VmFsID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbCkgOiBpc0FycmF5KGNoaWxkVmFsKSA/IGNoaWxkVmFsIDogW2NoaWxkVmFsXSA6IHBhcmVudFZhbDtcbn07XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VBc3NldHMocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbCA/IGV4dGVuZChyZXMsIGd1YXJkQXJyYXlBc3NldHMoY2hpbGRWYWwpKSA6IHJlcztcbn1cblxuY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBFdmVudHMgJiBXYXRjaGVycy5cbiAqXG4gKiBFdmVudHMgJiB3YXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuXG5zdHJhdHMud2F0Y2ggPSBzdHJhdHMuZXZlbnRzID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgcmV0dXJuIHBhcmVudFZhbDtcbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbDtcbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICBpZiAocGFyZW50ICYmICFpc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudCA/IHBhcmVudC5jb25jYXQoY2hpbGQpIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5cbnN0cmF0cy5wcm9wcyA9IHN0cmF0cy5tZXRob2RzID0gc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgcmV0dXJuIHBhcmVudFZhbDtcbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbDtcbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xuXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gZGVmYXVsdFN0cmF0KHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWQgPyBwYXJlbnRWYWwgOiBjaGlsZFZhbDtcbn07XG5cbi8qKlxuICogTWFrZSBzdXJlIGNvbXBvbmVudCBvcHRpb25zIGdldCBjb252ZXJ0ZWQgdG8gYWN0dWFsXG4gKiBjb25zdHJ1Y3RvcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBndWFyZENvbXBvbmVudHMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmNvbXBvbmVudHMgPSBndWFyZEFycmF5QXNzZXRzKG9wdGlvbnMuY29tcG9uZW50cyk7XG4gICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKGNvbXBvbmVudHMpO1xuICAgIHZhciBkZWY7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYXAgPSBvcHRpb25zLl9jb21wb25lbnROYW1lTWFwID0ge307XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaWRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGlkc1tpXTtcbiAgICAgIGlmIChjb21tb25UYWdSRS50ZXN0KGtleSkgfHwgcmVzZXJ2ZWRUYWdSRS50ZXN0KGtleSkpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgKyAnaWQ6ICcgKyBrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY29yZCBhIGFsbCBsb3dlcmNhc2UgPC0+IGtlYmFiLWNhc2UgbWFwcGluZyBmb3JcbiAgICAgIC8vIHBvc3NpYmxlIGN1c3RvbSBlbGVtZW50IGNhc2UgZXJyb3Igd2FybmluZ1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbWFwW2tleS5yZXBsYWNlKC8tL2csICcnKS50b0xvd2VyQ2FzZSgpXSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgfVxuICAgICAgZGVmID0gY29tcG9uZW50c1trZXldO1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3QoZGVmKSkge1xuICAgICAgICBjb21wb25lbnRzW2tleV0gPSBWdWUuZXh0ZW5kKGRlZik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRQcm9wcyhvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIHZhciBpLCB2YWw7XG4gIGlmIChpc0FycmF5KHByb3BzKSkge1xuICAgIG9wdGlvbnMucHJvcHMgPSB7fTtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMucHJvcHNbdmFsXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHZhbC5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMucHJvcHNbdmFsLm5hbWVdID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXlzW2ldXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3BzW2tleXNbaV1dID0geyB0eXBlOiB2YWwgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHdWFyZCBhbiBBcnJheS1mb3JtYXQgYXNzZXRzIG9wdGlvbiBhbmQgY29udmVydGVkIGl0XG4gKiBpbnRvIHRoZSBrZXktdmFsdWUgT2JqZWN0IGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYXNzZXRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRBcnJheUFzc2V0cyhhc3NldHMpIHtcbiAgaWYgKGlzQXJyYXkoYXNzZXRzKSkge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgaSA9IGFzc2V0cy5sZW5ndGg7XG4gICAgdmFyIGFzc2V0O1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFzc2V0ID0gYXNzZXRzW2ldO1xuICAgICAgdmFyIGlkID0gdHlwZW9mIGFzc2V0ID09PSAnZnVuY3Rpb24nID8gYXNzZXQub3B0aW9ucyAmJiBhc3NldC5vcHRpb25zLm5hbWUgfHwgYXNzZXQuaWQgOiBhc3NldC5uYW1lIHx8IGFzc2V0LmlkO1xuICAgICAgaWYgKCFpZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0FycmF5LXN5bnRheCBhc3NldHMgbXVzdCBwcm92aWRlIGEgXCJuYW1lXCIgb3IgXCJpZFwiIGZpZWxkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzW2lkXSA9IGFzc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHJldHVybiBhc3NldHM7XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY2hpbGRcbiAqIEBwYXJhbSB7VnVlfSBbdm1dIC0gaWYgdm0gaXMgcHJlc2VudCwgaW5kaWNhdGVzIHRoaXMgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgYW4gaW5zdGFudGlhdGlvbiBtZXJnZS5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZCwgdm0pIHtcbiAgZ3VhcmRDb21wb25lbnRzKGNoaWxkKTtcbiAgZ3VhcmRQcm9wcyhjaGlsZCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGNoaWxkLnByb3BzRGF0YSAmJiAhdm0pIHtcbiAgICAgIHdhcm4oJ3Byb3BzRGF0YSBjYW4gb25seSBiZSB1c2VkIGFzIGFuIGluc3RhbnRpYXRpb24gb3B0aW9uLicpO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBpZiAoY2hpbGRbJ2V4dGVuZHMnXSkge1xuICAgIHBhcmVudCA9IHR5cGVvZiBjaGlsZFsnZXh0ZW5kcyddID09PSAnZnVuY3Rpb24nID8gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGRbJ2V4dGVuZHMnXS5vcHRpb25zLCB2bSkgOiBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZFsnZXh0ZW5kcyddLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG1peGluID0gY2hpbGQubWl4aW5zW2ldO1xuICAgICAgdmFyIG1peGluT3B0aW9ucyA9IG1peGluLnByb3RvdHlwZSBpbnN0YW5jZW9mIFZ1ZSA/IG1peGluLm9wdGlvbnMgOiBtaXhpbjtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIG1peGluT3B0aW9ucywgdm0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtCb29sZWFufSB3YXJuTWlzc2luZ1xuICogQHJldHVybiB7T2JqZWN0fEZ1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVBc3NldChvcHRpb25zLCB0eXBlLCBpZCwgd2Fybk1pc3NpbmcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICB2YXIgY2FtZWxpemVkSWQ7XG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8XG4gIC8vIGNhbWVsQ2FzZSBJRFxuICBhc3NldHNbY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCldIHx8XG4gIC8vIFBhc2NhbCBDYXNlIElEXG4gIGFzc2V0c1tjYW1lbGl6ZWRJZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsaXplZElkLnNsaWNlKDEpXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERlcCgpIHtcbiAgdGhpcy5pZCA9IHVpZCQxKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufVxuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xuXG4vKipcbiAqIEFkZCBhIGRpcmVjdGl2ZSBzdWJzY3JpYmVyLlxuICpcbiAqIEBwYXJhbSB7RGlyZWN0aXZlfSBzdWJcbiAqL1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgZGlyZWN0aXZlIHN1YnNjcmliZXIuXG4gKlxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHN1YlxuICovXG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gKHN1Yikge1xuICB0aGlzLnN1YnMuJHJlbW92ZShzdWIpO1xufTtcblxuLyoqXG4gKiBBZGQgc2VsZiBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRhcmdldCB3YXRjaGVyLlxuICovXG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbn07XG5cbi8qKlxuICogTm90aWZ5IGFsbCBzdWJzY3JpYmVycyBvZiBhIG5ldyB2YWx1ZS5cbiAqL1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gc3RhYmxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRvQXJyYXkodGhpcy5zdWJzKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90bylcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xuXG47WydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICd1bnNoaWZ0JywgJ3NwbGljZScsICdzb3J0JywgJ3JldmVyc2UnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yKCkge1xuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTtcbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aCBhIG5ldyB2YWx1ZVxuICogYW5kIGVtaXRzIGNvcnJlc3BvbmRpbmcgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Kn0gLSByZXBsYWNlZCBlbGVtZW50XG4gKi9cblxuZGVmKGFycmF5UHJvdG8sICckc2V0JywgZnVuY3Rpb24gJHNldChpbmRleCwgdmFsKSB7XG4gIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRoaXMubGVuZ3RoID0gTnVtYmVyKGluZGV4KSArIDE7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAxLCB2YWwpWzBdO1xufSk7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBhdCBnaXZlbiBpbmRleCBvciB0YXJnZXQgZWxlbWVudCByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHsqfSBpdGVtXG4gKi9cblxuZGVmKGFycmF5UHJvdG8sICckcmVtb3ZlJywgZnVuY3Rpb24gJHJlbW92ZShpdGVtKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcywgaXRlbSk7XG4gIGlmIChpbmRleCA+IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufSk7XG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciBpbiBjZXJ0YWluIGNhc2VzLCBlLmcuXG4gKiB2LWZvciBzY29wZSBhbGlhcyBhbmQgcHJvcHMsIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvblxuICogYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLlxuICpcbiAqIFNvIHdoZW5ldmVyIHdlIHdhbnQgdG8gc2V0IGEgcmVhY3RpdmUgcHJvcGVydHkgd2l0aG91dCBmb3JjaW5nXG4gKiBjb252ZXJzaW9uIG9uIHRoZSBuZXcgdmFsdWUsIHdlIHdyYXAgdGhhdCBjYWxsIGluc2lkZSB0aGlzIGZ1bmN0aW9uLlxuICovXG5cbnZhciBzaG91bGRDb252ZXJ0ID0gdHJ1ZTtcblxuZnVuY3Rpb24gd2l0aG91dENvbnZlcnNpb24oZm4pIHtcbiAgc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICBmbigpO1xuICBzaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gT2JzZXJ2ZXIodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG8gPyBwcm90b0F1Z21lbnQgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn1cblxuLy8gSW5zdGFuY2UgbWV0aG9kc1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRoaXMuY29udmVydChrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBwcm9wZXJ0eSBpbnRvIGdldHRlci9zZXR0ZXIgc28gd2UgY2FuIGVtaXRcbiAqIHRoZSBldmVudHMgd2hlbiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQvY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIGRlZmluZVJlYWN0aXZlKHRoaXMudmFsdWUsIGtleSwgdmFsKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIG93bmVyIHZtLCBzbyB0aGF0IHdoZW4gJHNldC8kZGVsZXRlIG11dGF0aW9uc1xuICogaGFwcGVuIHdlIGNhbiBub3RpZnkgb3duZXIgdm1zIHRvIHByb3h5IHRoZSBrZXlzIGFuZFxuICogZGlnZXN0IHRoZSB3YXRjaGVycy4gVGhpcyBpcyBvbmx5IGNhbGxlZCB3aGVuIHRoZSBvYmplY3RcbiAqIGlzIG9ic2VydmVkIGFzIGFuIGluc3RhbmNlJ3Mgcm9vdCAkZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUuYWRkVm0gPSBmdW5jdGlvbiAodm0pIHtcbiAgKHRoaXMudm1zIHx8ICh0aGlzLnZtcyA9IFtdKSkucHVzaCh2bSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBvd25lciB2bS4gVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0IGlzXG4gKiBzd2FwcGVkIG91dCBhcyBhbiBpbnN0YW5jZSdzICRkYXRhIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUucmVtb3ZlVm0gPSBmdW5jdGlvbiAodm0pIHtcbiAgdGhpcy52bXMuJHJlbW92ZSh2bSk7XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKi9cblxuZnVuY3Rpb24gcHJvdG9BdWdtZW50KHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1xuICovXG5cbmZ1bmN0aW9uIGNvcHlBdWdtZW50KHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKiBAcmV0dXJuIHtPYnNlcnZlcnx1bmRlZmluZWR9XG4gKiBAc3RhdGljXG4gKi9cblxuZnVuY3Rpb24gb2JzZXJ2ZSh2YWx1ZSwgdm0pIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoc2hvdWxkQ29udmVydCAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmICF2YWx1ZS5faXNWdWUpIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKG9iICYmIHZtKSB7XG4gICAgb2IuYWRkVm0odm0pO1xuICB9XG4gIHJldHVybiBvYjtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZShvYmosIGtleSwgdmFsKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGZvciAodmFyIGUsIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBlID0gdmFsdWVbaV07XG4gICAgICAgICAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cblxuXG52YXIgdXRpbCA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUsXG5cdHNldDogc2V0LFxuXHRkZWw6IGRlbCxcblx0aGFzT3duOiBoYXNPd24sXG5cdGlzTGl0ZXJhbDogaXNMaXRlcmFsLFxuXHRpc1Jlc2VydmVkOiBpc1Jlc2VydmVkLFxuXHRfdG9TdHJpbmc6IF90b1N0cmluZyxcblx0dG9OdW1iZXI6IHRvTnVtYmVyLFxuXHR0b0Jvb2xlYW46IHRvQm9vbGVhbixcblx0c3RyaXBRdW90ZXM6IHN0cmlwUXVvdGVzLFxuXHRjYW1lbGl6ZTogY2FtZWxpemUsXG5cdGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuXHRjbGFzc2lmeTogY2xhc3NpZnksXG5cdGJpbmQ6IGJpbmQsXG5cdHRvQXJyYXk6IHRvQXJyYXksXG5cdGV4dGVuZDogZXh0ZW5kLFxuXHRpc09iamVjdDogaXNPYmplY3QsXG5cdGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG5cdGRlZjogZGVmLFxuXHRkZWJvdW5jZTogX2RlYm91bmNlLFxuXHRpbmRleE9mOiBpbmRleE9mLFxuXHRjYW5jZWxsYWJsZTogY2FuY2VsbGFibGUsXG5cdGxvb3NlRXF1YWw6IGxvb3NlRXF1YWwsXG5cdGlzQXJyYXk6IGlzQXJyYXksXG5cdGhhc1Byb3RvOiBoYXNQcm90byxcblx0aW5Ccm93c2VyOiBpbkJyb3dzZXIsXG5cdGRldnRvb2xzOiBkZXZ0b29scyxcblx0aXNJRTogaXNJRSxcblx0aXNJRTk6IGlzSUU5LFxuXHRpc0FuZHJvaWQ6IGlzQW5kcm9pZCxcblx0aXNJb3M6IGlzSW9zLFxuXHRpb3NWZXJzaW9uTWF0Y2g6IGlvc1ZlcnNpb25NYXRjaCxcblx0aW9zVmVyc2lvbjogaW9zVmVyc2lvbixcblx0aGFzTXV0YXRpb25PYnNlcnZlckJ1ZzogaGFzTXV0YXRpb25PYnNlcnZlckJ1Zyxcblx0Z2V0IHRyYW5zaXRpb25Qcm9wICgpIHsgcmV0dXJuIHRyYW5zaXRpb25Qcm9wOyB9LFxuXHRnZXQgdHJhbnNpdGlvbkVuZEV2ZW50ICgpIHsgcmV0dXJuIHRyYW5zaXRpb25FbmRFdmVudDsgfSxcblx0Z2V0IGFuaW1hdGlvblByb3AgKCkgeyByZXR1cm4gYW5pbWF0aW9uUHJvcDsgfSxcblx0Z2V0IGFuaW1hdGlvbkVuZEV2ZW50ICgpIHsgcmV0dXJuIGFuaW1hdGlvbkVuZEV2ZW50OyB9LFxuXHRuZXh0VGljazogbmV4dFRpY2ssXG5cdGdldCBfU2V0ICgpIHsgcmV0dXJuIF9TZXQ7IH0sXG5cdHF1ZXJ5OiBxdWVyeSxcblx0aW5Eb2M6IGluRG9jLFxuXHRnZXRBdHRyOiBnZXRBdHRyLFxuXHRnZXRCaW5kQXR0cjogZ2V0QmluZEF0dHIsXG5cdGhhc0JpbmRBdHRyOiBoYXNCaW5kQXR0cixcblx0YmVmb3JlOiBiZWZvcmUsXG5cdGFmdGVyOiBhZnRlcixcblx0cmVtb3ZlOiByZW1vdmUsXG5cdHByZXBlbmQ6IHByZXBlbmQsXG5cdHJlcGxhY2U6IHJlcGxhY2UsXG5cdG9uOiBvbixcblx0b2ZmOiBvZmYsXG5cdHNldENsYXNzOiBzZXRDbGFzcyxcblx0YWRkQ2xhc3M6IGFkZENsYXNzLFxuXHRyZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG5cdGV4dHJhY3RDb250ZW50OiBleHRyYWN0Q29udGVudCxcblx0dHJpbU5vZGU6IHRyaW1Ob2RlLFxuXHRpc1RlbXBsYXRlOiBpc1RlbXBsYXRlLFxuXHRjcmVhdGVBbmNob3I6IGNyZWF0ZUFuY2hvcixcblx0ZmluZFJlZjogZmluZFJlZixcblx0bWFwTm9kZVJhbmdlOiBtYXBOb2RlUmFuZ2UsXG5cdHJlbW92ZU5vZGVSYW5nZTogcmVtb3ZlTm9kZVJhbmdlLFxuXHRpc0ZyYWdtZW50OiBpc0ZyYWdtZW50LFxuXHRnZXRPdXRlckhUTUw6IGdldE91dGVySFRNTCxcblx0bWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG5cdHJlc29sdmVBc3NldDogcmVzb2x2ZUFzc2V0LFxuXHRjaGVja0NvbXBvbmVudEF0dHI6IGNoZWNrQ29tcG9uZW50QXR0cixcblx0Y29tbW9uVGFnUkU6IGNvbW1vblRhZ1JFLFxuXHRyZXNlcnZlZFRhZ1JFOiByZXNlcnZlZFRhZ1JFLFxuXHRnZXQgd2FybiAoKSB7IHJldHVybiB3YXJuOyB9XG59KTtcblxudmFyIHVpZCA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBUaGUgbWFpbiBpbml0IHNlcXVlbmNlLiBUaGlzIGlzIGNhbGxlZCBmb3IgZXZlcnlcbiAgICogaW5zdGFuY2UsIGluY2x1ZGluZyBvbmVzIHRoYXQgYXJlIGNyZWF0ZWQgZnJvbSBleHRlbmRlZFxuICAgKiBjb25zdHJ1Y3RvcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhpcyBvcHRpb25zIG9iamVjdCBzaG91bGQgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmVzdWx0IG9mIG1lcmdpbmcgY2xhc3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIGFuZCB0aGUgb3B0aW9ucyBwYXNzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0byB0aGUgY29uc3RydWN0b3IuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy4kZWwgPSBudWxsO1xuICAgIHRoaXMuJHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIHRoaXMuJHJvb3QgPSB0aGlzLiRwYXJlbnQgPyB0aGlzLiRwYXJlbnQuJHJvb3QgOiB0aGlzO1xuICAgIHRoaXMuJGNoaWxkcmVuID0gW107XG4gICAgdGhpcy4kcmVmcyA9IHt9OyAvLyBjaGlsZCB2bSByZWZlcmVuY2VzXG4gICAgdGhpcy4kZWxzID0ge307IC8vIGVsZW1lbnQgcmVmZXJlbmNlc1xuICAgIHRoaXMuX3dhdGNoZXJzID0gW107IC8vIGFsbCB3YXRjaGVycyBhcyBhbiBhcnJheVxuICAgIHRoaXMuX2RpcmVjdGl2ZXMgPSBbXTsgLy8gYWxsIGRpcmVjdGl2ZXNcblxuICAgIC8vIGEgdWlkXG4gICAgdGhpcy5fdWlkID0gdWlkKys7XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHRoaXMuX2lzVnVlID0gdHJ1ZTtcblxuICAgIC8vIGV2ZW50cyBib29ra2VlcGluZ1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9OyAvLyByZWdpc3RlcmVkIGNhbGxiYWNrc1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0ge307IC8vIGZvciAkYnJvYWRjYXN0IG9wdGltaXphdGlvblxuXG4gICAgLy8gZnJhZ21lbnQgaW5zdGFuY2UgcHJvcGVydGllc1xuICAgIHRoaXMuX2lzRnJhZ21lbnQgPSBmYWxzZTtcbiAgICB0aGlzLl9mcmFnbWVudCA9IC8vIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fVxuICAgIHRoaXMuX2ZyYWdtZW50U3RhcnQgPSAvLyBAdHlwZSB7VGV4dHxDb21tZW50fVxuICAgIHRoaXMuX2ZyYWdtZW50RW5kID0gbnVsbDsgLy8gQHR5cGUge1RleHR8Q29tbWVudH1cblxuICAgIC8vIGxpZmVjeWNsZSBzdGF0ZVxuICAgIHRoaXMuX2lzQ29tcGlsZWQgPSB0aGlzLl9pc0Rlc3Ryb3llZCA9IHRoaXMuX2lzUmVhZHkgPSB0aGlzLl9pc0F0dGFjaGVkID0gdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCA9IHRoaXMuX3ZGb3JSZW1vdmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3VubGlua0ZuID0gbnVsbDtcblxuICAgIC8vIGNvbnRleHQ6XG4gICAgLy8gaWYgdGhpcyBpcyBhIHRyYW5zY2x1ZGVkIGNvbXBvbmVudCwgY29udGV4dFxuICAgIC8vIHdpbGwgYmUgdGhlIGNvbW1vbiBwYXJlbnQgdm0gb2YgdGhpcyBpbnN0YW5jZVxuICAgIC8vIGFuZCBpdHMgaG9zdC5cbiAgICB0aGlzLl9jb250ZXh0ID0gb3B0aW9ucy5fY29udGV4dCB8fCB0aGlzLiRwYXJlbnQ7XG5cbiAgICAvLyBzY29wZTpcbiAgICAvLyBpZiB0aGlzIGlzIGluc2lkZSBhbiBpbmxpbmUgdi1mb3IsIHRoZSBzY29wZVxuICAgIC8vIHdpbGwgYmUgdGhlIGludGVybWVkaWF0ZSBzY29wZSBjcmVhdGVkIGZvciB0aGlzXG4gICAgLy8gcmVwZWF0IGZyYWdtZW50LiB0aGlzIGlzIHVzZWQgZm9yIGxpbmtpbmcgcHJvcHNcbiAgICAvLyBhbmQgY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gICAgdGhpcy5fc2NvcGUgPSBvcHRpb25zLl9zY29wZTtcblxuICAgIC8vIGZyYWdtZW50OlxuICAgIC8vIGlmIHRoaXMgaW5zdGFuY2UgaXMgY29tcGlsZWQgaW5zaWRlIGEgRnJhZ21lbnQsIGl0XG4gICAgLy8gbmVlZHMgdG8gcmVpZ3N0ZXIgaXRzZWxmIGFzIGEgY2hpbGQgb2YgdGhhdCBmcmFnbWVudFxuICAgIC8vIGZvciBhdHRhY2gvZGV0YWNoIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgdGhpcy5fZnJhZyA9IG9wdGlvbnMuX2ZyYWc7XG4gICAgaWYgKHRoaXMuX2ZyYWcpIHtcbiAgICAgIHRoaXMuX2ZyYWcuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBwdXNoIHNlbGYgaW50byBwYXJlbnQgLyB0cmFuc2NsdXNpb24gaG9zdFxuICAgIGlmICh0aGlzLiRwYXJlbnQpIHtcbiAgICAgIHRoaXMuJHBhcmVudC4kY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBvcHRpb25zLlxuICAgIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMuY29uc3RydWN0b3Iub3B0aW9ucywgb3B0aW9ucywgdGhpcyk7XG5cbiAgICAvLyBzZXQgcmVmXG4gICAgdGhpcy5fdXBkYXRlUmVmKCk7XG5cbiAgICAvLyBpbml0aWFsaXplIGRhdGEgYXMgZW1wdHkgb2JqZWN0LlxuICAgIC8vIGl0IHdpbGwgYmUgZmlsbGVkIHVwIGluIF9pbml0RGF0YSgpLlxuICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgIC8vIGNhbGwgaW5pdCBob29rXG4gICAgdGhpcy5fY2FsbEhvb2soJ2luaXQnKTtcblxuICAgIC8vIGluaXRpYWxpemUgZGF0YSBvYnNlcnZhdGlvbiBhbmQgc2NvcGUgaW5oZXJpdGFuY2UuXG4gICAgdGhpcy5faW5pdFN0YXRlKCk7XG5cbiAgICAvLyBzZXR1cCBldmVudCBzeXN0ZW0gYW5kIG9wdGlvbiBldmVudHMuXG4gICAgdGhpcy5faW5pdEV2ZW50cygpO1xuXG4gICAgLy8gY2FsbCBjcmVhdGVkIGhvb2tcbiAgICB0aGlzLl9jYWxsSG9vaygnY3JlYXRlZCcpO1xuXG4gICAgLy8gaWYgYGVsYCBvcHRpb24gaXMgcGFzc2VkLCBzdGFydCBjb21waWxhdGlvbi5cbiAgICBpZiAob3B0aW9ucy5lbCkge1xuICAgICAgdGhpcy4kbW91bnQob3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgcGF0aENhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG4vLyBhY3Rpb25zXG52YXIgQVBQRU5EID0gMDtcbnZhciBQVVNIID0gMTtcbnZhciBJTkNfU1VCX1BBVEhfREVQVEggPSAyO1xudmFyIFBVU0hfU1VCX1BBVEggPSAzO1xuXG4vLyBzdGF0ZXNcbnZhciBCRUZPUkVfUEFUSCA9IDA7XG52YXIgSU5fUEFUSCA9IDE7XG52YXIgQkVGT1JFX0lERU5UID0gMjtcbnZhciBJTl9JREVOVCA9IDM7XG52YXIgSU5fU1VCX1BBVEggPSA0O1xudmFyIElOX1NJTkdMRV9RVU9URSA9IDU7XG52YXIgSU5fRE9VQkxFX1FVT1RFID0gNjtcbnZhciBBRlRFUl9QQVRIID0gNztcbnZhciBFUlJPUiA9IDg7XG5cbnZhciBwYXRoU3RhdGVNYWNoaW5lID0gW107XG5cbnBhdGhTdGF0ZU1hY2hpbmVbQkVGT1JFX1BBVEhdID0ge1xuICAnd3MnOiBbQkVGT1JFX1BBVEhdLFxuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICdbJzogW0lOX1NVQl9QQVRIXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9QQVRIXSA9IHtcbiAgJ3dzJzogW0lOX1BBVEhdLFxuICAnLic6IFtCRUZPUkVfSURFTlRdLFxuICAnWyc6IFtJTl9TVUJfUEFUSF0sXG4gICdlb2YnOiBbQUZURVJfUEFUSF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbQkVGT1JFX0lERU5UXSA9IHtcbiAgJ3dzJzogW0JFRk9SRV9JREVOVF0sXG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9JREVOVF0gPSB7XG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJzAnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICdudW1iZXInOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICd3cyc6IFtJTl9QQVRILCBQVVNIXSxcbiAgJy4nOiBbQkVGT1JFX0lERU5ULCBQVVNIXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEgsIFBVU0hdLFxuICAnZW9mJzogW0FGVEVSX1BBVEgsIFBVU0hdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NVQl9QQVRIXSA9IHtcbiAgXCInXCI6IFtJTl9TSU5HTEVfUVVPVEUsIEFQUEVORF0sXG4gICdcIic6IFtJTl9ET1VCTEVfUVVPVEUsIEFQUEVORF0sXG4gICdbJzogW0lOX1NVQl9QQVRILCBJTkNfU1VCX1BBVEhfREVQVEhdLFxuICAnXSc6IFtJTl9QQVRILCBQVVNIX1NVQl9QQVRIXSxcbiAgJ2VvZic6IEVSUk9SLFxuICAnZWxzZSc6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9TSU5HTEVfUVVPVEVdID0ge1xuICBcIidcIjogW0lOX1NVQl9QQVRILCBBUFBFTkRdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX1NJTkdMRV9RVU9URSwgQVBQRU5EXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9ET1VCTEVfUVVPVEVdID0ge1xuICAnXCInOiBbSU5fU1VCX1BBVEgsIEFQUEVORF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fRE9VQkxFX1FVT1RFLCBBUFBFTkRdXG59O1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgdHlwZSBvZiBhIGNoYXJhY3RlciBpbiBhIGtleXBhdGguXG4gKlxuICogQHBhcmFtIHtDaGFyfSBjaFxuICogQHJldHVybiB7U3RyaW5nfSB0eXBlXG4gKi9cblxuZnVuY3Rpb24gZ2V0UGF0aENoYXJUeXBlKGNoKSB7XG4gIGlmIChjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICdlb2YnO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuXG4gIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgMHg1QjogLy8gW1xuICAgIGNhc2UgMHg1RDogLy8gXVxuICAgIGNhc2UgMHgyRTogLy8gLlxuICAgIGNhc2UgMHgyMjogLy8gXCJcbiAgICBjYXNlIDB4Mjc6IC8vICdcbiAgICBjYXNlIDB4MzA6XG4gICAgICAvLyAwXG4gICAgICByZXR1cm4gY2g7XG5cbiAgICBjYXNlIDB4NUY6IC8vIF9cbiAgICBjYXNlIDB4MjQ6XG4gICAgICAvLyAkXG4gICAgICByZXR1cm4gJ2lkZW50JztcblxuICAgIGNhc2UgMHgyMDogLy8gU3BhY2VcbiAgICBjYXNlIDB4MDk6IC8vIFRhYlxuICAgIGNhc2UgMHgwQTogLy8gTmV3bGluZVxuICAgIGNhc2UgMHgwRDogLy8gUmV0dXJuXG4gICAgY2FzZSAweEEwOiAvLyBOby1icmVhayBzcGFjZVxuICAgIGNhc2UgMHhGRUZGOiAvLyBCeXRlIE9yZGVyIE1hcmtcbiAgICBjYXNlIDB4MjAyODogLy8gTGluZSBTZXBhcmF0b3JcbiAgICBjYXNlIDB4MjAyOTpcbiAgICAgIC8vIFBhcmFncmFwaCBTZXBhcmF0b3JcbiAgICAgIHJldHVybiAnd3MnO1xuICB9XG5cbiAgLy8gYS16LCBBLVpcbiAgaWYgKGNvZGUgPj0gMHg2MSAmJiBjb2RlIDw9IDB4N0EgfHwgY29kZSA+PSAweDQxICYmIGNvZGUgPD0gMHg1QSkge1xuICAgIHJldHVybiAnaWRlbnQnO1xuICB9XG5cbiAgLy8gMS05XG4gIGlmIChjb2RlID49IDB4MzEgJiYgY29kZSA8PSAweDM5KSB7XG4gICAgcmV0dXJuICdudW1iZXInO1xuICB9XG5cbiAgcmV0dXJuICdlbHNlJztcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBzdWJQYXRoLCByZXR1cm4gaXRzIHBsYWluIGZvcm0gaWYgaXQgaXNcbiAqIGEgbGl0ZXJhbCBzdHJpbmcgb3IgbnVtYmVyLiBPdGhlcndpc2UgcHJlcGVuZCB0aGVcbiAqIGR5bmFtaWMgaW5kaWNhdG9yICgqKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFN1YlBhdGgocGF0aCkge1xuICB2YXIgdHJpbW1lZCA9IHBhdGgudHJpbSgpO1xuICAvLyBpbnZhbGlkIGxlYWRpbmcgMFxuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcwJyAmJiBpc05hTihwYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNMaXRlcmFsKHRyaW1tZWQpID8gc3RyaXBRdW90ZXModHJpbW1lZCkgOiAnKicgKyB0cmltbWVkO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIHBhdGggaW50byBhbiBhcnJheSBvZiBzZWdtZW50c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheXx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuICB2YXIga2V5cyA9IFtdO1xuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIG1vZGUgPSBCRUZPUkVfUEFUSDtcbiAgdmFyIHN1YlBhdGhEZXB0aCA9IDA7XG4gIHZhciBjLCBuZXdDaGFyLCBrZXksIHR5cGUsIHRyYW5zaXRpb24sIGFjdGlvbiwgdHlwZU1hcDtcblxuICB2YXIgYWN0aW9ucyA9IFtdO1xuXG4gIGFjdGlvbnNbUFVTSF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgYWN0aW9uc1tBUFBFTkRdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gbmV3Q2hhcjtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ICs9IG5ld0NoYXI7XG4gICAgfVxuICB9O1xuXG4gIGFjdGlvbnNbSU5DX1NVQl9QQVRIX0RFUFRIXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBhY3Rpb25zW0FQUEVORF0oKTtcbiAgICBzdWJQYXRoRGVwdGgrKztcbiAgfTtcblxuICBhY3Rpb25zW1BVU0hfU1VCX1BBVEhdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdWJQYXRoRGVwdGggPiAwKSB7XG4gICAgICBzdWJQYXRoRGVwdGgtLTtcbiAgICAgIG1vZGUgPSBJTl9TVUJfUEFUSDtcbiAgICAgIGFjdGlvbnNbQVBQRU5EXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJQYXRoRGVwdGggPSAwO1xuICAgICAga2V5ID0gZm9ybWF0U3ViUGF0aChrZXkpO1xuICAgICAgaWYgKGtleSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uc1tQVVNIXSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBtYXliZVVuZXNjYXBlUXVvdGUoKSB7XG4gICAgdmFyIG5leHRDaGFyID0gcGF0aFtpbmRleCArIDFdO1xuICAgIGlmIChtb2RlID09PSBJTl9TSU5HTEVfUVVPVEUgJiYgbmV4dENoYXIgPT09IFwiJ1wiIHx8IG1vZGUgPT09IElOX0RPVUJMRV9RVU9URSAmJiBuZXh0Q2hhciA9PT0gJ1wiJykge1xuICAgICAgaW5kZXgrKztcbiAgICAgIG5ld0NoYXIgPSAnXFxcXCcgKyBuZXh0Q2hhcjtcbiAgICAgIGFjdGlvbnNbQVBQRU5EXSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKG1vZGUgIT0gbnVsbCkge1xuICAgIGluZGV4Kys7XG4gICAgYyA9IHBhdGhbaW5kZXhdO1xuXG4gICAgaWYgKGMgPT09ICdcXFxcJyAmJiBtYXliZVVuZXNjYXBlUXVvdGUoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdHlwZSA9IGdldFBhdGhDaGFyVHlwZShjKTtcbiAgICB0eXBlTWFwID0gcGF0aFN0YXRlTWFjaGluZVttb2RlXTtcbiAgICB0cmFuc2l0aW9uID0gdHlwZU1hcFt0eXBlXSB8fCB0eXBlTWFwWydlbHNlJ10gfHwgRVJST1I7XG5cbiAgICBpZiAodHJhbnNpdGlvbiA9PT0gRVJST1IpIHtcbiAgICAgIHJldHVybjsgLy8gcGFyc2UgZXJyb3JcbiAgICB9XG5cbiAgICBtb2RlID0gdHJhbnNpdGlvblswXTtcbiAgICBhY3Rpb24gPSBhY3Rpb25zW3RyYW5zaXRpb25bMV1dO1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIG5ld0NoYXIgPSB0cmFuc2l0aW9uWzJdO1xuICAgICAgbmV3Q2hhciA9IG5ld0NoYXIgPT09IHVuZGVmaW5lZCA/IGMgOiBuZXdDaGFyO1xuICAgICAgaWYgKGFjdGlvbigpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09IEFGVEVSX1BBVEgpIHtcbiAgICAgIGtleXMucmF3ID0gcGF0aDtcbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4dGVybmFsIHBhcnNlIHRoYXQgY2hlY2sgZm9yIGEgY2FjaGUgaGl0IGZpcnN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgaGl0ID0gcGF0aENhY2hlLmdldChwYXRoKTtcbiAgaWYgKCFoaXQpIHtcbiAgICBoaXQgPSBwYXJzZShwYXRoKTtcbiAgICBpZiAoaGl0KSB7XG4gICAgICBwYXRoQ2FjaGUucHV0KHBhdGgsIGhpdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoaXQ7XG59XG5cbi8qKlxuICogR2V0IGZyb20gYW4gb2JqZWN0IGZyb20gYSBwYXRoIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKi9cblxuZnVuY3Rpb24gZ2V0UGF0aChvYmosIHBhdGgpIHtcbiAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbihwYXRoKS5nZXQob2JqKTtcbn1cblxuLyoqXG4gKiBXYXJuIGFnYWluc3Qgc2V0dGluZyBub24tZXhpc3RlbnQgcm9vdCBwYXRoIG9uIGEgdm0uXG4gKi9cblxudmFyIHdhcm5Ob25FeGlzdGVudDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5Ob25FeGlzdGVudCA9IGZ1bmN0aW9uIChwYXRoLCB2bSkge1xuICAgIHdhcm4oJ1lvdSBhcmUgc2V0dGluZyBhIG5vbi1leGlzdGVudCBwYXRoIFwiJyArIHBhdGgucmF3ICsgJ1wiICcgKyAnb24gYSB2bSBpbnN0YW5jZS4gQ29uc2lkZXIgcHJlLWluaXRpYWxpemluZyB0aGUgcHJvcGVydHkgJyArICd3aXRoIHRoZSBcImRhdGFcIiBvcHRpb24gZm9yIG1vcmUgcmVsaWFibGUgcmVhY3Rpdml0eSAnICsgJ2FuZCBiZXR0ZXIgcGVyZm9ybWFuY2UuJywgdm0pO1xuICB9O1xufVxuXG4vKipcbiAqIFNldCBvbiBhbiBvYmplY3QgZnJvbSBhIHBhdGhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBwYXRoXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHNldFBhdGgob2JqLCBwYXRoLCB2YWwpIHtcbiAgdmFyIG9yaWdpbmFsID0gb2JqO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IHBhcnNlKHBhdGgpO1xuICB9XG4gIGlmICghcGF0aCB8fCAhaXNPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdCwga2V5O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGgubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGFzdCA9IG9iajtcbiAgICBrZXkgPSBwYXRoW2ldO1xuICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnKicpIHtcbiAgICAgIGtleSA9IHBhcnNlRXhwcmVzc2lvbihrZXkuc2xpY2UoMSkpLmdldC5jYWxsKG9yaWdpbmFsLCBvcmlnaW5hbCk7XG4gICAgfVxuICAgIGlmIChpIDwgbCAtIDEpIHtcbiAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBsYXN0Ll9pc1Z1ZSkge1xuICAgICAgICAgIHdhcm5Ob25FeGlzdGVudChwYXRoLCBsYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBzZXQobGFzdCwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIG9iai4kc2V0KGtleSwgdmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9iai5faXNWdWUpIHtcbiAgICAgICAgICB3YXJuTm9uRXhpc3RlbnQocGF0aCwgb2JqKTtcbiAgICAgICAgfVxuICAgICAgICBzZXQob2JqLCBrZXksIHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgcGF0aCA9IE9iamVjdC5mcmVlemUoe1xuICBwYXJzZVBhdGg6IHBhcnNlUGF0aCxcbiAgZ2V0UGF0aDogZ2V0UGF0aCxcbiAgc2V0UGF0aDogc2V0UGF0aFxufSk7XG5cbnZhciBleHByZXNzaW9uQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG5cbnZhciBhbGxvd2VkS2V5d29yZHMgPSAnTWF0aCxEYXRlLHRoaXMsdHJ1ZSxmYWxzZSxudWxsLHVuZGVmaW5lZCxJbmZpbml0eSxOYU4sJyArICdpc05hTixpc0Zpbml0ZSxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSwnICsgJ2VuY29kZVVSSUNvbXBvbmVudCxwYXJzZUludCxwYXJzZUZsb2F0JztcbnZhciBhbGxvd2VkS2V5d29yZHNSRSA9IG5ldyBSZWdFeHAoJ14oJyArIGFsbG93ZWRLZXl3b3Jkcy5yZXBsYWNlKC8sL2csICdcXFxcYnwnKSArICdcXFxcYiknKTtcblxuLy8ga2V5d29yZHMgdGhhdCBkb24ndCBtYWtlIHNlbnNlIGluc2lkZSBleHByZXNzaW9uc1xudmFyIGltcHJvcGVyS2V5d29yZHMgPSAnYnJlYWssY2FzZSxjbGFzcyxjYXRjaCxjb25zdCxjb250aW51ZSxkZWJ1Z2dlcixkZWZhdWx0LCcgKyAnZGVsZXRlLGRvLGVsc2UsZXhwb3J0LGV4dGVuZHMsZmluYWxseSxmb3IsZnVuY3Rpb24saWYsJyArICdpbXBvcnQsaW4saW5zdGFuY2VvZixsZXQscmV0dXJuLHN1cGVyLHN3aXRjaCx0aHJvdyx0cnksJyArICd2YXIsd2hpbGUsd2l0aCx5aWVsZCxlbnVtLGF3YWl0LGltcGxlbWVudHMscGFja2FnZSwnICsgJ3Byb3RlY3RlZCxzdGF0aWMsaW50ZXJmYWNlLHByaXZhdGUscHVibGljJztcbnZhciBpbXByb3BlcktleXdvcmRzUkUgPSBuZXcgUmVnRXhwKCdeKCcgKyBpbXByb3BlcktleXdvcmRzLnJlcGxhY2UoLywvZywgJ1xcXFxifCcpICsgJ1xcXFxiKScpO1xuXG52YXIgd3NSRSA9IC9cXHMvZztcbnZhciBuZXdsaW5lUkUgPSAvXFxuL2c7XG52YXIgc2F2ZVJFID0gL1tcXHssXVxccypbXFx3XFwkX10rXFxzKjp8KCcoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgKXxuZXcgfHR5cGVvZiB8dm9pZCAvZztcbnZhciByZXN0b3JlUkUgPSAvXCIoXFxkKylcIi9nO1xudmFyIHBhdGhUZXN0UkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPydcXF18XFxbXCIuKj9cIlxcXXxcXFtcXGQrXFxdfFxcW1tBLVphLXpfJF1bXFx3JF0qXFxdKSokLztcbnZhciBpZGVudFJFID0gL1teXFx3JFxcLl0oPzpbQS1aYS16XyRdW1xcdyRdKikvZztcbnZhciBsaXRlcmFsVmFsdWVSRSQxID0gL14oPzp0cnVlfGZhbHNlfG51bGx8dW5kZWZpbmVkfEluZmluaXR5fE5hTikkLztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8qKlxuICogU2F2ZSAvIFJld3JpdGUgLyBSZXN0b3JlXG4gKlxuICogV2hlbiByZXdyaXRpbmcgcGF0aHMgZm91bmQgaW4gYW4gZXhwcmVzc2lvbiwgaXQgaXNcbiAqIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBsZXR0ZXIgc2VxdWVuY2VzIHRvIGJlIGZvdW5kIGluXG4gKiBzdHJpbmdzIGFuZCBPYmplY3QgbGl0ZXJhbCBwcm9wZXJ0eSBrZXlzLiBUaGVyZWZvcmUgd2VcbiAqIHJlbW92ZSBhbmQgc3RvcmUgdGhlc2UgcGFydHMgaW4gYSB0ZW1wb3JhcnkgYXJyYXksIGFuZFxuICogcmVzdG9yZSB0aGVtIGFmdGVyIHRoZSBwYXRoIHJld3JpdGUuXG4gKi9cblxudmFyIHNhdmVkID0gW107XG5cbi8qKlxuICogU2F2ZSByZXBsYWNlclxuICpcbiAqIFRoZSBzYXZlIHJlZ2V4IGNhbiBtYXRjaCB0d28gcG9zc2libGUgY2FzZXM6XG4gKiAxLiBBbiBvcGVuaW5nIG9iamVjdCBsaXRlcmFsXG4gKiAyLiBBIHN0cmluZ1xuICogSWYgbWF0Y2hlZCBhcyBhIHBsYWluIHN0cmluZywgd2UgbmVlZCB0byBlc2NhcGUgaXRzXG4gKiBuZXdsaW5lcywgc2luY2UgdGhlIHN0cmluZyBuZWVkcyB0byBiZSBwcmVzZXJ2ZWQgd2hlblxuICogZ2VuZXJhdGluZyB0aGUgZnVuY3Rpb24gYm9keS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gaXNTdHJpbmcgLSBzdHIgaWYgbWF0Y2hlZCBhcyBhIHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSAtIHBsYWNlaG9sZGVyIHdpdGggaW5kZXhcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKHN0ciwgaXNTdHJpbmcpIHtcbiAgdmFyIGkgPSBzYXZlZC5sZW5ndGg7XG4gIHNhdmVkW2ldID0gaXNTdHJpbmcgPyBzdHIucmVwbGFjZShuZXdsaW5lUkUsICdcXFxcbicpIDogc3RyO1xuICByZXR1cm4gJ1wiJyArIGkgKyAnXCInO1xufVxuXG4vKipcbiAqIFBhdGggcmV3cml0ZSByZXBsYWNlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiByZXdyaXRlKHJhdykge1xuICB2YXIgYyA9IHJhdy5jaGFyQXQoMCk7XG4gIHZhciBwYXRoID0gcmF3LnNsaWNlKDEpO1xuICBpZiAoYWxsb3dlZEtleXdvcmRzUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVybiByYXc7XG4gIH0gZWxzZSB7XG4gICAgcGF0aCA9IHBhdGguaW5kZXhPZignXCInKSA+IC0xID8gcGF0aC5yZXBsYWNlKHJlc3RvcmVSRSwgcmVzdG9yZSkgOiBwYXRoO1xuICAgIHJldHVybiBjICsgJ3Njb3BlLicgKyBwYXRoO1xuICB9XG59XG5cbi8qKlxuICogUmVzdG9yZSByZXBsYWNlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpIC0gbWF0Y2hlZCBzYXZlIGluZGV4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcmVzdG9yZShzdHIsIGkpIHtcbiAgcmV0dXJuIHNhdmVkW2ldO1xufVxuXG4vKipcbiAqIFJld3JpdGUgYW4gZXhwcmVzc2lvbiwgcHJlZml4aW5nIGFsbCBwYXRoIGFjY2Vzc29ycyB3aXRoXG4gKiBgc2NvcGUuYCBhbmQgZ2VuZXJhdGUgZ2V0dGVyL3NldHRlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUdldHRlcihleHApIHtcbiAgaWYgKGltcHJvcGVyS2V5d29yZHNSRS50ZXN0KGV4cCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0F2b2lkIHVzaW5nIHJlc2VydmVkIGtleXdvcmRzIGluIGV4cHJlc3Npb246ICcgKyBleHApO1xuICB9XG4gIC8vIHJlc2V0IHN0YXRlXG4gIHNhdmVkLmxlbmd0aCA9IDA7XG4gIC8vIHNhdmUgc3RyaW5ncyBhbmQgb2JqZWN0IGxpdGVyYWwga2V5c1xuICB2YXIgYm9keSA9IGV4cC5yZXBsYWNlKHNhdmVSRSwgc2F2ZSkucmVwbGFjZSh3c1JFLCAnJyk7XG4gIC8vIHJld3JpdGUgYWxsIHBhdGhzXG4gIC8vIHBhZCAxIHNwYWNlIGhlcmUgYmVjYXVzZSB0aGUgcmVnZXggbWF0Y2hlcyAxIGV4dHJhIGNoYXJcbiAgYm9keSA9ICgnICcgKyBib2R5KS5yZXBsYWNlKGlkZW50UkUsIHJld3JpdGUpLnJlcGxhY2UocmVzdG9yZVJFLCByZXN0b3JlKTtcbiAgcmV0dXJuIG1ha2VHZXR0ZXJGbihib2R5KTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGdldHRlciBmdW5jdGlvbi4gUmVxdWlyZXMgZXZhbC5cbiAqXG4gKiBXZSBpc29sYXRlIHRoZSB0cnkvY2F0Y2ggc28gaXQgZG9lc24ndCBhZmZlY3QgdGhlXG4gKiBvcHRpbWl6YXRpb24gb2YgdGhlIHBhcnNlIGZ1bmN0aW9uIHdoZW4gaXQgaXMgbm90IGNhbGxlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYm9keVxuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIG1ha2VHZXR0ZXJGbihib2R5KSB7XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMgKi9cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdzY29wZScsICdyZXR1cm4gJyArIGJvZHkgKyAnOycpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIGRlZmF1bHQgYnVpbGQgb2YgVnVlLmpzIGluIGFuIGVudmlyb25tZW50ICcgKyAnd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArICdVc2UgdGhlIENTUC1jb21wbGlhbnQgYnVpbGQgaW5zdGVhZDogJyArICdodHRwOi8vdnVlanMub3JnL2d1aWRlL2luc3RhbGxhdGlvbi5odG1sI0NTUC1jb21wbGlhbnQtYnVpbGQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oJ0ludmFsaWQgZXhwcmVzc2lvbi4gJyArICdHZW5lcmF0ZWQgZnVuY3Rpb24gYm9keTogJyArIGJvZHkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9vcDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlU2V0dGVyKGV4cCkge1xuICB2YXIgcGF0aCA9IHBhcnNlUGF0aChleHApO1xuICBpZiAocGF0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsIHZhbCkge1xuICAgICAgc2V0UGF0aChzY29wZSwgcGF0aCwgdmFsKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBzZXR0ZXIgZXhwcmVzc2lvbjogJyArIGV4cCk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBleHByZXNzaW9uIGludG8gcmUtd3JpdHRlbiBnZXR0ZXIvc2V0dGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG5lZWRTZXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihleHAsIG5lZWRTZXQpIHtcbiAgZXhwID0gZXhwLnRyaW0oKTtcbiAgLy8gdHJ5IGNhY2hlXG4gIHZhciBoaXQgPSBleHByZXNzaW9uQ2FjaGUuZ2V0KGV4cCk7XG4gIGlmIChoaXQpIHtcbiAgICBpZiAobmVlZFNldCAmJiAhaGl0LnNldCkge1xuICAgICAgaGl0LnNldCA9IGNvbXBpbGVTZXR0ZXIoaGl0LmV4cCk7XG4gICAgfVxuICAgIHJldHVybiBoaXQ7XG4gIH1cbiAgdmFyIHJlcyA9IHsgZXhwOiBleHAgfTtcbiAgcmVzLmdldCA9IGlzU2ltcGxlUGF0aChleHApICYmIGV4cC5pbmRleE9mKCdbJykgPCAwXG4gIC8vIG9wdGltaXplZCBzdXBlciBzaW1wbGUgZ2V0dGVyXG4gID8gbWFrZUdldHRlckZuKCdzY29wZS4nICsgZXhwKVxuICAvLyBkeW5hbWljIGdldHRlclxuICA6IGNvbXBpbGVHZXR0ZXIoZXhwKTtcbiAgaWYgKG5lZWRTZXQpIHtcbiAgICByZXMuc2V0ID0gY29tcGlsZVNldHRlcihleHApO1xuICB9XG4gIGV4cHJlc3Npb25DYWNoZS5wdXQoZXhwLCByZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGV4cHJlc3Npb24gaXMgYSBzaW1wbGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzU2ltcGxlUGF0aChleHApIHtcbiAgcmV0dXJuIHBhdGhUZXN0UkUudGVzdChleHApICYmXG4gIC8vIGRvbid0IHRyZWF0IGxpdGVyYWwgdmFsdWVzIGFzIHBhdGhzXG4gICFsaXRlcmFsVmFsdWVSRSQxLnRlc3QoZXhwKSAmJlxuICAvLyBNYXRoIGNvbnN0YW50cyBlLmcuIE1hdGguUEksIE1hdGguRSBldGMuXG4gIGV4cC5zbGljZSgwLCA1KSAhPT0gJ01hdGguJztcbn1cblxudmFyIGV4cHJlc3Npb24gPSBPYmplY3QuZnJlZXplKHtcbiAgcGFyc2VFeHByZXNzaW9uOiBwYXJzZUV4cHJlc3Npb24sXG4gIGlzU2ltcGxlUGF0aDogaXNTaW1wbGVQYXRoXG59KTtcblxuLy8gd2UgaGF2ZSB0d28gc2VwYXJhdGUgcXVldWVzOiBvbmUgZm9yIGRpcmVjdGl2ZSB1cGRhdGVzXG4vLyBhbmQgb25lIGZvciB1c2VyIHdhdGNoZXIgcmVnaXN0ZXJlZCB2aWEgJHdhdGNoKCkuXG4vLyB3ZSB3YW50IHRvIGd1YXJhbnRlZSBkaXJlY3RpdmUgdXBkYXRlcyB0byBiZSBjYWxsZWRcbi8vIGJlZm9yZSB1c2VyIHdhdGNoZXJzIHNvIHRoYXQgd2hlbiB1c2VyIHdhdGNoZXJzIGFyZVxuLy8gdHJpZ2dlcmVkLCB0aGUgRE9NIHdvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIGluIHVwZGF0ZWRcbi8vIHN0YXRlLlxuXG52YXIgcXVldWUgPSBbXTtcbnZhciB1c2VyUXVldWUgPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXNldCB0aGUgYmF0Y2hlcidzIHN0YXRlLlxuICovXG5cbmZ1bmN0aW9uIHJlc2V0QmF0Y2hlclN0YXRlKCkge1xuICBxdWV1ZS5sZW5ndGggPSAwO1xuICB1c2VyUXVldWUubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGNpcmN1bGFyID0ge307XG4gIHdhaXRpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuXG5mdW5jdGlvbiBmbHVzaEJhdGNoZXJRdWV1ZSgpIHtcbiAgdmFyIF9hZ2FpbiA9IHRydWU7XG5cbiAgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7XG4gICAgX2FnYWluID0gZmFsc2U7XG5cbiAgICBydW5CYXRjaGVyUXVldWUocXVldWUpO1xuICAgIHJ1bkJhdGNoZXJRdWV1ZSh1c2VyUXVldWUpO1xuICAgIC8vIHVzZXIgd2F0Y2hlcnMgdHJpZ2dlcmVkIG1vcmUgd2F0Y2hlcnMsXG4gICAgLy8ga2VlcCBmbHVzaGluZyB1bnRpbCBpdCBkZXBsZXRlc1xuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIF9hZ2FpbiA9IHRydWU7XG4gICAgICBjb250aW51ZSBfZnVuY3Rpb247XG4gICAgfVxuICAgIC8vIGRldiB0b29sIGhvb2tcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICAgIH1cbiAgICByZXNldEJhdGNoZXJTdGF0ZSgpO1xuICB9XG59XG5cbi8qKlxuICogUnVuIHRoZSB3YXRjaGVycyBpbiBhIHNpbmdsZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBxdWV1ZVxuICovXG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZXJRdWV1ZShxdWV1ZSkge1xuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBjb25maWcuX21heFVwZGF0ZUNvdW50KSB7XG4gICAgICAgIHdhcm4oJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCBmb3Igd2F0Y2hlciAnICsgJ3dpdGggZXhwcmVzc2lvbiBcIicgKyB3YXRjaGVyLmV4cHJlc3Npb24gKyAnXCInLCB3YXRjaGVyLnZtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKlxuICogQHBhcmFtIHtXYXRjaGVyfSB3YXRjaGVyXG4gKiAgIHByb3BlcnRpZXM6XG4gKiAgIC0ge051bWJlcn0gaWRcbiAqICAgLSB7RnVuY3Rpb259IHJ1blxuICovXG5cbmZ1bmN0aW9uIHB1c2hXYXRjaGVyKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIC8vIHB1c2ggd2F0Y2hlciBpbnRvIGFwcHJvcHJpYXRlIHF1ZXVlXG4gICAgdmFyIHEgPSB3YXRjaGVyLnVzZXIgPyB1c2VyUXVldWUgOiBxdWV1ZTtcbiAgICBoYXNbaWRdID0gcS5sZW5ndGg7XG4gICAgcS5wdXNoKHdhdGNoZXIpO1xuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaEJhdGNoZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gZXhwT3JGblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXl9IGZpbHRlcnNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB0d29XYXlcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBkZWVwXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gdXNlclxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHN5bmNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBsYXp5XG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwcmVQcm9jZXNzXVxuICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbcG9zdFByb2Nlc3NdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgLy8gbWl4IGluIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBleHRlbmQodGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGlzRm4gPSB0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJztcbiAgdGhpcy52bSA9IHZtO1xuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbjtcbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMucHJldkVycm9yID0gbnVsbDsgLy8gZm9yIGFzeW5jIGVycm9yIHN0YWNrc1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXIvc2V0dGVyXG4gIGlmIChpc0ZuKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgIHRoaXMuc2V0dGVyID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXMgPSBwYXJzZUV4cHJlc3Npb24oZXhwT3JGbiwgdGhpcy50d29XYXkpO1xuICAgIHRoaXMuZ2V0dGVyID0gcmVzLmdldDtcbiAgICB0aGlzLnNldHRlciA9IHJlcy5zZXQ7XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eSA/IHVuZGVmaW5lZCA6IHRoaXMuZ2V0KCk7XG4gIC8vIHN0YXRlIGZvciBhdm9pZGluZyBmYWxzZSB0cmlnZ2VycyBmb3IgZGVlcCBhbmQgQXJyYXlcbiAgLy8gd2F0Y2hlcnMgZHVyaW5nIHZtLl9kaWdlc3QoKVxuICB0aGlzLnF1ZXVlZCA9IHRoaXMuc2hhbGxvdyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYmVmb3JlR2V0KCk7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgdmFyIHZhbHVlO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbChzY29wZSwgc2NvcGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLndhcm5FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICB3YXJuKCdFcnJvciB3aGVuIGV2YWx1YXRpbmcgZXhwcmVzc2lvbiAnICsgJ1wiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIjogJyArIGUudG9TdHJpbmcoKSwgdGhpcy52bSk7XG4gICAgfVxuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBpZiAodGhpcy5wcmVQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnByZVByb2Nlc3ModmFsdWUpO1xuICB9XG4gIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICB2YWx1ZSA9IHNjb3BlLl9hcHBseUZpbHRlcnModmFsdWUsIG51bGwsIHRoaXMuZmlsdGVycywgZmFsc2UpO1xuICB9XG4gIGlmICh0aGlzLnBvc3RQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnBvc3RQcm9jZXNzKHZhbHVlKTtcbiAgfVxuICB0aGlzLmFmdGVyR2V0KCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHdpdGggdGhlIHNldHRlci5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgIHZhbHVlID0gc2NvcGUuX2FwcGx5RmlsdGVycyh2YWx1ZSwgdGhpcy52YWx1ZSwgdGhpcy5maWx0ZXJzLCB0cnVlKTtcbiAgfVxuICB0cnkge1xuICAgIHRoaXMuc2V0dGVyLmNhbGwoc2NvcGUsIHNjb3BlLCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcud2FybkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHdhcm4oJ0Vycm9yIHdoZW4gZXZhbHVhdGluZyBzZXR0ZXIgJyArICdcIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCI6ICcgKyBlLnRvU3RyaW5nKCksIHRoaXMudm0pO1xuICAgIH1cbiAgfVxuICAvLyB0d28td2F5IHN5bmMgZm9yIHYtZm9yIGFsaWFzXG4gIHZhciBmb3JDb250ZXh0ID0gc2NvcGUuJGZvckNvbnRleHQ7XG4gIGlmIChmb3JDb250ZXh0ICYmIGZvckNvbnRleHQuYWxpYXMgPT09IHRoaXMuZXhwcmVzc2lvbikge1xuICAgIGlmIChmb3JDb250ZXh0LmZpbHRlcnMpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0d28td2F5IGJpbmRpbmcgb24gJyArICdhIHYtZm9yIGFsaWFzICgnICsgdGhpcy5leHByZXNzaW9uICsgJyksIGFuZCB0aGUgJyArICd2LWZvciBoYXMgZmlsdGVycy4gVGhpcyB3aWxsIG5vdCB3b3JrIHByb3Blcmx5LiAnICsgJ0VpdGhlciByZW1vdmUgdGhlIGZpbHRlcnMgb3IgdXNlIGFuIGFycmF5IG9mICcgKyAnb2JqZWN0cyBhbmQgYmluZCB0byBvYmplY3QgcHJvcGVydGllcyBpbnN0ZWFkLicsIHRoaXMudm0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3JDb250ZXh0Ll93aXRoTG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2NvcGUuJGtleSkge1xuICAgICAgICAvLyBvcmlnaW5hbCBpcyBhbiBvYmplY3RcbiAgICAgICAgZm9yQ29udGV4dC5yYXdWYWx1ZVtzY29wZS4ka2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yQ29udGV4dC5yYXdWYWx1ZS4kc2V0KHNjb3BlLiRpbmRleCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIFByZXBhcmUgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5iZWZvcmVHZXQgPSBmdW5jdGlvbiAoKSB7XG4gIERlcC50YXJnZXQgPSB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RGVwfSBkZXBcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZnRlckdldCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldCA9IG51bGw7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWxsb3dcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoc2hhbGxvdykge1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jIHx8ICFjb25maWcuYXN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIHF1ZXVlZCwgb25seSBvdmVyd3JpdGUgc2hhbGxvdyB3aXRoIG5vbi1zaGFsbG93LFxuICAgIC8vIGJ1dCBub3QgdGhlIG90aGVyIHdheSBhcm91bmQuXG4gICAgdGhpcy5zaGFsbG93ID0gdGhpcy5xdWV1ZWQgPyBzaGFsbG93ID8gdGhpcy5zaGFsbG93IDogZmFsc2UgOiAhIXNoYWxsb3c7XG4gICAgdGhpcy5xdWV1ZWQgPSB0cnVlO1xuICAgIC8vIHJlY29yZCBiZWZvcmUtcHVzaCBlcnJvciBzdGFjayBpbiBkZWJ1ZyBtb2RlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLmRlYnVnKSB7XG4gICAgICB0aGlzLnByZXZFcnJvciA9IG5ldyBFcnJvcignW3Z1ZV0gYXN5bmMgc3RhY2sgdHJhY2UnKTtcbiAgICB9XG4gICAgcHVzaFdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmF0Y2hlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIGJhdGNoZXIuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAvLyBoYXZlIG11dGF0ZWQ7IGJ1dCBvbmx5IGRvIHNvIGlmIHRoaXMgaXMgYVxuICAgIC8vIG5vbi1zaGFsbG93IHVwZGF0ZSAoY2F1c2VkIGJ5IGEgdm0gZGlnZXN0KS5cbiAgICAoaXNPYmplY3QodmFsdWUpIHx8IHRoaXMuZGVlcCkgJiYgIXRoaXMuc2hhbGxvdykge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIC8vIGluIGRlYnVnICsgYXN5bmMgbW9kZSwgd2hlbiBhIHdhdGNoZXIgY2FsbGJhY2tzXG4gICAgICAvLyB0aHJvd3MsIHdlIGFsc28gdGhyb3cgdGhlIHNhdmVkIGJlZm9yZS1wdXNoIGVycm9yXG4gICAgICAvLyBzbyB0aGUgZnVsbCBjcm9zcy10aWNrIHN0YWNrIHRyYWNlIGlzIGF2YWlsYWJsZS5cbiAgICAgIHZhciBwcmV2RXJyb3IgPSB0aGlzLnByZXZFcnJvcjtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLmRlYnVnICYmIHByZXZFcnJvcikge1xuICAgICAgICB0aGlzLnByZXZFcnJvciA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBwcmV2RXJyb3I7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyBhdm9pZCBvdmVyd3JpdGluZyBhbm90aGVyIHdhdGNoZXIgdGhhdCBpcyBiZWluZ1xuICAvLyBjb2xsZWN0ZWQuXG4gIHZhciBjdXJyZW50ID0gRGVwLnRhcmdldDtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgRGVwLnRhcmdldCA9IGN1cnJlbnQ7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3ViY3JpYmVyIGxpc3QuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZCBvciBpcyBwZXJmb3JtaW5nIGEgdi1mb3JcbiAgICAvLyByZS1yZW5kZXIgKHRoZSB3YXRjaGVyIGxpc3QgaXMgdGhlbiBmaWx0ZXJlZCBieSB2LWZvcikuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkICYmICF0aGlzLnZtLl92Rm9yUmVtb3ZpbmcpIHtcbiAgICAgIHRoaXMudm0uX3dhdGNoZXJzLiRyZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMudm0gPSB0aGlzLmNiID0gdGhpcy52YWx1ZSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogUmVjcnVzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbCwgc2Vlbikge1xuICB2YXIgaSA9IHVuZGVmaW5lZCxcbiAgICAgIGtleXMgPSB1bmRlZmluZWQ7XG4gIGlmICghc2Vlbikge1xuICAgIHNlZW4gPSBzZWVuT2JqZWN0cztcbiAgICBzZWVuLmNsZWFyKCk7XG4gIH1cbiAgdmFyIGlzQSA9IGlzQXJyYXkodmFsKTtcbiAgdmFyIGlzTyA9IGlzT2JqZWN0KHZhbCk7XG4gIGlmICgoaXNBIHx8IGlzTykgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgaWYgKHZhbC5fX29iX18pIHtcbiAgICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChkZXBJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0EpIHtcbiAgICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2ldLCBzZWVuKTtcbiAgICB9IGVsc2UgaWYgKGlzTykge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB0cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdGV4dCQxID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdGhpcy5hdHRyID0gdGhpcy5lbC5ub2RlVHlwZSA9PT0gMyA/ICdkYXRhJyA6ICd0ZXh0Q29udGVudCc7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmVsW3RoaXMuYXR0cl0gPSBfdG9TdHJpbmcodmFsdWUpO1xuICB9XG59O1xuXG52YXIgdGVtcGxhdGVDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcbnZhciBpZFNlbGVjdG9yQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG5cbnZhciBtYXAgPSB7XG4gIGVmYXVsdDogWzAsICcnLCAnJ10sXG4gIGxlZ2VuZDogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gIHRyOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcbiAgY29sOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXVxufTtcblxubWFwLnRkID0gbWFwLnRoID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbm1hcC5vcHRpb24gPSBtYXAub3B0Z3JvdXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsICc8L3NlbGVjdD4nXTtcblxubWFwLnRoZWFkID0gbWFwLnRib2R5ID0gbWFwLmNvbGdyb3VwID0gbWFwLmNhcHRpb24gPSBtYXAudGZvb3QgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcblxubWFwLmcgPSBtYXAuZGVmcyA9IG1hcC5zeW1ib2wgPSBtYXAudXNlID0gbWFwLmltYWdlID0gbWFwLnRleHQgPSBtYXAuY2lyY2xlID0gbWFwLmVsbGlwc2UgPSBtYXAubGluZSA9IG1hcC5wYXRoID0gbWFwLnBvbHlnb24gPSBtYXAucG9seWxpbmUgPSBtYXAucmVjdCA9IFsxLCAnPHN2ZyAnICsgJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnICsgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcgKyAneG1sbnM6ZXY9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHNcIicgKyAndmVyc2lvbj1cIjEuMVwiPicsICc8L3N2Zz4nXTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBzdXBwb3J0ZWQgdGVtcGxhdGUgbm9kZSB3aXRoIGFcbiAqIERvY3VtZW50RnJhZ21lbnQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNSZWFsVGVtcGxhdGUobm9kZSkge1xuICByZXR1cm4gaXNUZW1wbGF0ZShub2RlKSAmJiBpc0ZyYWdtZW50KG5vZGUuY29udGVudCk7XG59XG5cbnZhciB0YWdSRSQxID0gLzwoW1xcdzotXSspLztcbnZhciBlbnRpdHlSRSA9IC8mIz9cXHcrPzsvO1xudmFyIGNvbW1lbnRSRSA9IC88IS0tLztcblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIHRlbXBsYXRlIHRvIGEgRG9jdW1lbnRGcmFnbWVudC5cbiAqIERldGVybWluZXMgY29ycmVjdCB3cmFwcGluZyBieSB0YWcgdHlwZXMuIFdyYXBwaW5nXG4gKiBzdHJhdGVneSBmb3VuZCBpbiBqUXVlcnkgJiBjb21wb25lbnQvZG9taWZ5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVN0cmluZ1xuICogQHBhcmFtIHtCb29sZWFufSByYXdcbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nVG9GcmFnbWVudCh0ZW1wbGF0ZVN0cmluZywgcmF3KSB7XG4gIC8vIHRyeSBhIGNhY2hlIGhpdCBmaXJzdFxuICB2YXIgY2FjaGVLZXkgPSByYXcgPyB0ZW1wbGF0ZVN0cmluZyA6IHRlbXBsYXRlU3RyaW5nLnRyaW0oKTtcbiAgdmFyIGhpdCA9IHRlbXBsYXRlQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKGhpdCkge1xuICAgIHJldHVybiBoaXQ7XG4gIH1cblxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgdmFyIHRhZ01hdGNoID0gdGVtcGxhdGVTdHJpbmcubWF0Y2godGFnUkUkMSk7XG4gIHZhciBlbnRpdHlNYXRjaCA9IGVudGl0eVJFLnRlc3QodGVtcGxhdGVTdHJpbmcpO1xuICB2YXIgY29tbWVudE1hdGNoID0gY29tbWVudFJFLnRlc3QodGVtcGxhdGVTdHJpbmcpO1xuXG4gIGlmICghdGFnTWF0Y2ggJiYgIWVudGl0eU1hdGNoICYmICFjb21tZW50TWF0Y2gpIHtcbiAgICAvLyB0ZXh0IG9ubHksIHJldHVybiBhIHNpbmdsZSB0ZXh0IG5vZGUuXG4gICAgZnJhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZW1wbGF0ZVN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSB0YWdNYXRjaCAmJiB0YWdNYXRjaFsxXTtcbiAgICB2YXIgd3JhcCA9IG1hcFt0YWddIHx8IG1hcC5lZmF1bHQ7XG4gICAgdmFyIGRlcHRoID0gd3JhcFswXTtcbiAgICB2YXIgcHJlZml4ID0gd3JhcFsxXTtcbiAgICB2YXIgc3VmZml4ID0gd3JhcFsyXTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgbm9kZS5pbm5lckhUTUwgPSBwcmVmaXggKyB0ZW1wbGF0ZVN0cmluZyArIHN1ZmZpeDtcbiAgICB3aGlsZSAoZGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cblxuICAgIHZhciBjaGlsZDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIHdoaWxlIChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3KSB7XG4gICAgdHJpbU5vZGUoZnJhZyk7XG4gIH1cbiAgdGVtcGxhdGVDYWNoZS5wdXQoY2FjaGVLZXksIGZyYWcpO1xuICByZXR1cm4gZnJhZztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdGVtcGxhdGUgbm9kZSB0byBhIERvY3VtZW50RnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIG5vZGVUb0ZyYWdtZW50KG5vZGUpIHtcbiAgLy8gaWYgaXRzIGEgdGVtcGxhdGUgdGFnIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBpdCxcbiAgLy8gaXRzIGNvbnRlbnQgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LiBIb3dldmVyLCBpT1MgU2FmYXJpIGhhc1xuICAvLyBidWcgd2hlbiB1c2luZyBkaXJlY3RseSBjbG9uZWQgdGVtcGxhdGUgY29udGVudCB3aXRoIHRvdWNoXG4gIC8vIGV2ZW50cyBhbmQgY2FuIGNhdXNlIGNyYXNoZXMgd2hlbiB0aGUgbm9kZXMgYXJlIHJlbW92ZWQgZnJvbSBET00sIHNvIHdlXG4gIC8vIGhhdmUgdG8gdHJlYXQgdGVtcGxhdGUgZWxlbWVudHMgYXMgc3RyaW5nIHRlbXBsYXRlcy4gKCMyODA1KVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzUmVhbFRlbXBsYXRlKG5vZGUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvRnJhZ21lbnQobm9kZS5pbm5lckhUTUwpO1xuICB9XG4gIC8vIHNjcmlwdCB0ZW1wbGF0ZVxuICBpZiAobm9kZS50YWdOYW1lID09PSAnU0NSSVBUJykge1xuICAgIHJldHVybiBzdHJpbmdUb0ZyYWdtZW50KG5vZGUudGV4dENvbnRlbnQpO1xuICB9XG4gIC8vIG5vcm1hbCBub2RlLCBjbG9uZSBpdCB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWxcbiAgdmFyIGNsb25lZE5vZGUgPSBjbG9uZU5vZGUobm9kZSk7XG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgY2hpbGQ7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gIHdoaWxlIChjaGlsZCA9IGNsb25lZE5vZGUuZmlyc3RDaGlsZCkge1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBmcmFnLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxuICB0cmltTm9kZShmcmFnKTtcbiAgcmV0dXJuIGZyYWc7XG59XG5cbi8vIFRlc3QgZm9yIHRoZSBwcmVzZW5jZSBvZiB0aGUgU2FmYXJpIHRlbXBsYXRlIGNsb25pbmcgYnVnXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93dWcuY2dpP2lkPTEzNzc1NVxudmFyIGhhc0Jyb2tlblRlbXBsYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGluQnJvd3Nlcikge1xuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYS5pbm5lckhUTUwgPSAnPHRlbXBsYXRlPjE8L3RlbXBsYXRlPic7XG4gICAgcmV0dXJuICFhLmNsb25lTm9kZSh0cnVlKS5maXJzdENoaWxkLmlubmVySFRNTDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8vIFRlc3QgZm9yIElFMTAvMTEgdGV4dGFyZWEgcGxhY2Vob2xkZXIgY2xvbmUgYnVnXG52YXIgaGFzVGV4dGFyZWFDbG9uZUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpbkJyb3dzZXIpIHtcbiAgICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdC5wbGFjZWhvbGRlciA9ICd0JztcbiAgICByZXR1cm4gdC5jbG9uZU5vZGUodHJ1ZSkudmFsdWUgPT09ICd0JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogMS4gRGVhbCB3aXRoIFNhZmFyaSBjbG9uaW5nIG5lc3RlZCA8dGVtcGxhdGU+IGJ1ZyBieVxuICogICAgbWFudWFsbHkgY2xvbmluZyBhbGwgdGVtcGxhdGUgaW5zdGFuY2VzLlxuICogMi4gRGVhbCB3aXRoIElFMTAvMTEgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnIGJ5IHNldHRpbmdcbiAqICAgIHRoZSBjb3JyZWN0IHZhbHVlIGFmdGVyIGNsb25pbmcuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IG5vZGVcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBjbG9uZU5vZGUobm9kZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFub2RlLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUoKTtcbiAgfVxuICB2YXIgcmVzID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7XG4gIHZhciBpLCBvcmlnaW5hbCwgY2xvbmVkO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGhhc0Jyb2tlblRlbXBsYXRlKSB7XG4gICAgdmFyIHRlbXBDbG9uZSA9IHJlcztcbiAgICBpZiAoaXNSZWFsVGVtcGxhdGUobm9kZSkpIHtcbiAgICAgIG5vZGUgPSBub2RlLmNvbnRlbnQ7XG4gICAgICB0ZW1wQ2xvbmUgPSByZXMuY29udGVudDtcbiAgICB9XG4gICAgb3JpZ2luYWwgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RlbXBsYXRlJyk7XG4gICAgaWYgKG9yaWdpbmFsLmxlbmd0aCkge1xuICAgICAgY2xvbmVkID0gdGVtcENsb25lLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RlbXBsYXRlJyk7XG4gICAgICBpID0gY2xvbmVkLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY2xvbmVkW2ldLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGNsb25lTm9kZShvcmlnaW5hbFtpXSksIGNsb25lZFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaGFzVGV4dGFyZWFDbG9uZUJ1Zykge1xuICAgIGlmIChub2RlLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIHJlcy52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yaWdpbmFsID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpO1xuICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCkge1xuICAgICAgICBjbG9uZWQgPSByZXMucXVlcnlTZWxlY3RvckFsbCgndGV4dGFyZWEnKTtcbiAgICAgICAgaSA9IGNsb25lZC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjbG9uZWRbaV0udmFsdWUgPSBvcmlnaW5hbFtpXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlIG9wdGlvbiBhbmQgbm9ybWFsaXplcyBpdCBpbnRvIGFcbiAqIGEgRG9jdW1lbnRGcmFnbWVudCB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgcGFydGlhbCBvciBhXG4gKiBpbnN0YW5jZSB0ZW1wbGF0ZS5cbiAqXG4gKiBAcGFyYW0geyp9IHRlbXBsYXRlXG4gKiAgICAgICAgUG9zc2libGUgdmFsdWVzIGluY2x1ZGU6XG4gKiAgICAgICAgLSBEb2N1bWVudEZyYWdtZW50IG9iamVjdFxuICogICAgICAgIC0gTm9kZSBvYmplY3Qgb2YgdHlwZSBUZW1wbGF0ZVxuICogICAgICAgIC0gaWQgc2VsZWN0b3I6ICcjc29tZS10ZW1wbGF0ZS1pZCdcbiAqICAgICAgICAtIHRlbXBsYXRlIHN0cmluZzogJzxkaXY+PHNwYW4+e3ttc2d9fTwvc3Bhbj48L2Rpdj4nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZENsb25lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJhd1xuICogICAgICAgIGlubGluZSBIVE1MIGludGVycG9sYXRpb24uIERvIG5vdCBjaGVjayBmb3IgaWRcbiAqICAgICAgICBzZWxlY3RvciBhbmQga2VlcCB3aGl0ZXNwYWNlIGluIHRoZSBzdHJpbmcuXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCBzaG91bGRDbG9uZSwgcmF3KSB7XG4gIHZhciBub2RlLCBmcmFnO1xuXG4gIC8vIGlmIHRoZSB0ZW1wbGF0ZSBpcyBhbHJlYWR5IGEgZG9jdW1lbnQgZnJhZ21lbnQsXG4gIC8vIGRvIG5vdGhpbmdcbiAgaWYgKGlzRnJhZ21lbnQodGVtcGxhdGUpKSB7XG4gICAgdHJpbU5vZGUodGVtcGxhdGUpO1xuICAgIHJldHVybiBzaG91bGRDbG9uZSA/IGNsb25lTm9kZSh0ZW1wbGF0ZSkgOiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gaWQgc2VsZWN0b3JcbiAgICBpZiAoIXJhdyAmJiB0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgLy8gaWQgc2VsZWN0b3IgY2FuIGJlIGNhY2hlZCB0b29cbiAgICAgIGZyYWcgPSBpZFNlbGVjdG9yQ2FjaGUuZ2V0KHRlbXBsYXRlKTtcbiAgICAgIGlmICghZnJhZykge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGVtcGxhdGUuc2xpY2UoMSkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIGZyYWcgPSBub2RlVG9GcmFnbWVudChub2RlKTtcbiAgICAgICAgICAvLyBzYXZlIHNlbGVjdG9yIHRvIGNhY2hlXG4gICAgICAgICAgaWRTZWxlY3RvckNhY2hlLnB1dCh0ZW1wbGF0ZSwgZnJhZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9ybWFsIHN0cmluZyB0ZW1wbGF0ZVxuICAgICAgZnJhZyA9IHN0cmluZ1RvRnJhZ21lbnQodGVtcGxhdGUsIHJhdyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgLy8gYSBkaXJlY3Qgbm9kZVxuICAgIGZyYWcgPSBub2RlVG9GcmFnbWVudCh0ZW1wbGF0ZSk7XG4gIH1cblxuICByZXR1cm4gZnJhZyAmJiBzaG91bGRDbG9uZSA/IGNsb25lTm9kZShmcmFnKSA6IGZyYWc7XG59XG5cbnZhciB0ZW1wbGF0ZSA9IE9iamVjdC5mcmVlemUoe1xuICBjbG9uZU5vZGU6IGNsb25lTm9kZSxcbiAgcGFyc2VUZW1wbGF0ZTogcGFyc2VUZW1wbGF0ZVxufSk7XG5cbnZhciBodG1sID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gYSBjb21tZW50IG5vZGUgbWVhbnMgdGhpcyBpcyBhIGJpbmRpbmcgZm9yXG4gICAgLy8ge3t7IGlubGluZSB1bmVzY2FwZWQgaHRtbCB9fX1cbiAgICBpZiAodGhpcy5lbC5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgLy8gaG9sZCBub2Rlc1xuICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgd2l0aCBwcm9wZXIgYW5jaG9yXG4gICAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1odG1sJyk7XG4gICAgICByZXBsYWNlKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB2YWx1ZSA9IF90b1N0cmluZyh2YWx1ZSk7XG4gICAgaWYgKHRoaXMubm9kZXMpIHtcbiAgICAgIHRoaXMuc3dhcCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIHN3YXA6IGZ1bmN0aW9uIHN3YXAodmFsdWUpIHtcbiAgICAvLyByZW1vdmUgb2xkIG5vZGVzXG4gICAgdmFyIGkgPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICByZW1vdmUodGhpcy5ub2Rlc1tpXSk7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgbmV3IHZhbHVlIHRvIGEgZnJhZ21lbnRcbiAgICAvLyBkbyBub3QgYXR0ZW1wdCB0byByZXRyaWV2ZSBmcm9tIGlkIHNlbGVjdG9yXG4gICAgdmFyIGZyYWcgPSBwYXJzZVRlbXBsYXRlKHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAvLyBzYXZlIGEgcmVmZXJlbmNlIHRvIHRoZXNlIG5vZGVzIHNvIHdlIGNhbiByZW1vdmUgbGF0ZXJcbiAgICB0aGlzLm5vZGVzID0gdG9BcnJheShmcmFnLmNoaWxkTm9kZXMpO1xuICAgIGJlZm9yZShmcmFnLCB0aGlzLmFuY2hvcik7XG4gIH1cbn07XG5cbi8qKlxuICogQWJzdHJhY3Rpb24gZm9yIGEgcGFydGlhbGx5LWNvbXBpbGVkIGZyYWdtZW50LlxuICogQ2FuIG9wdGlvbmFsbHkgY29tcGlsZSBjb250ZW50IHdpdGggYSBjaGlsZCBzY29wZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rZXJcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnXG4gKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdXG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICogQHBhcmFtIHtGcmFnbWVudH0gW3BhcmVudEZyYWddXG4gKi9cbmZ1bmN0aW9uIEZyYWdtZW50KGxpbmtlciwgdm0sIGZyYWcsIGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5jaGlsZEZyYWdzID0gW107XG4gIHRoaXMudm0gPSB2bTtcbiAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gIHRoaXMucGFyZW50RnJhZyA9IHBhcmVudEZyYWc7XG4gIGlmIChwYXJlbnRGcmFnKSB7XG4gICAgcGFyZW50RnJhZy5jaGlsZEZyYWdzLnB1c2godGhpcyk7XG4gIH1cbiAgdGhpcy51bmxpbmsgPSBsaW5rZXIodm0sIGZyYWcsIGhvc3QsIHNjb3BlLCB0aGlzKTtcbiAgdmFyIHNpbmdsZSA9IHRoaXMuc2luZ2xlID0gZnJhZy5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJlxuICAvLyBkbyBub3QgZ28gc2luZ2xlIG1vZGUgaWYgdGhlIG9ubHkgbm9kZSBpcyBhbiBhbmNob3JcbiAgIWZyYWcuY2hpbGROb2Rlc1swXS5fX3ZfYW5jaG9yO1xuICBpZiAoc2luZ2xlKSB7XG4gICAgdGhpcy5ub2RlID0gZnJhZy5jaGlsZE5vZGVzWzBdO1xuICAgIHRoaXMuYmVmb3JlID0gc2luZ2xlQmVmb3JlO1xuICAgIHRoaXMucmVtb3ZlID0gc2luZ2xlUmVtb3ZlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubm9kZSA9IGNyZWF0ZUFuY2hvcignZnJhZ21lbnQtc3RhcnQnKTtcbiAgICB0aGlzLmVuZCA9IGNyZWF0ZUFuY2hvcignZnJhZ21lbnQtZW5kJyk7XG4gICAgdGhpcy5mcmFnID0gZnJhZztcbiAgICBwcmVwZW5kKHRoaXMubm9kZSwgZnJhZyk7XG4gICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmVuZCk7XG4gICAgdGhpcy5iZWZvcmUgPSBtdWx0aUJlZm9yZTtcbiAgICB0aGlzLnJlbW92ZSA9IG11bHRpUmVtb3ZlO1xuICB9XG4gIHRoaXMubm9kZS5fX3ZfZnJhZyA9IHRoaXM7XG59XG5cbi8qKlxuICogQ2FsbCBhdHRhY2gvZGV0YWNoIGZvciBhbGwgY29tcG9uZW50cyBjb250YWluZWQgd2l0aGluXG4gKiB0aGlzIGZyYWdtZW50LiBBbHNvIGRvIHNvIHJlY3Vyc2l2ZWx5IGZvciBhbGwgY2hpbGRcbiAqIGZyYWdtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmNhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgdmFyIGksIGw7XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5jaGlsZEZyYWdzW2ldLmNhbGxIb29rKGhvb2spO1xuICB9XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGhvb2sodGhpcy5jaGlsZHJlbltpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZUJlZm9yZSh0YXJnZXQsIHdpdGhUcmFuc2l0aW9uKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSB0cnVlO1xuICB2YXIgbWV0aG9kID0gd2l0aFRyYW5zaXRpb24gIT09IGZhbHNlID8gYmVmb3JlV2l0aFRyYW5zaXRpb24gOiBiZWZvcmU7XG4gIG1ldGhvZCh0aGlzLm5vZGUsIHRhcmdldCwgdGhpcy52bSk7XG4gIGlmIChpbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGZyYWdtZW50LCBzaW5nbGUgbm9kZSB2ZXJzaW9uXG4gKi9cblxuZnVuY3Rpb24gc2luZ2xlUmVtb3ZlKCkge1xuICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gIHZhciBzaG91bGRDYWxsUmVtb3ZlID0gaW5Eb2ModGhpcy5ub2RlKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xuICByZW1vdmVXaXRoVHJhbnNpdGlvbih0aGlzLm5vZGUsIHRoaXMudm0sIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2hvdWxkQ2FsbFJlbW92ZSkge1xuICAgICAgc2VsZi5jYWxsSG9vayhkZXRhY2gpO1xuICAgIH1cbiAgICBzZWxmLmRlc3Ryb3koKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIG11bHRpQmVmb3JlKHRhcmdldCwgd2l0aFRyYW5zaXRpb24pIHtcbiAgdGhpcy5pbnNlcnRlZCA9IHRydWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHZhciBtZXRob2QgPSB3aXRoVHJhbnNpdGlvbiAhPT0gZmFsc2UgPyBiZWZvcmVXaXRoVHJhbnNpdGlvbiA6IGJlZm9yZTtcbiAgbWFwTm9kZVJhbmdlKHRoaXMubm9kZSwgdGhpcy5lbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbWV0aG9kKG5vZGUsIHRhcmdldCwgdm0pO1xuICB9KTtcbiAgaWYgKGluRG9jKHRoaXMubm9kZSkpIHtcbiAgICB0aGlzLmNhbGxIb29rKGF0dGFjaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqL1xuXG5mdW5jdGlvbiBtdWx0aVJlbW92ZSgpIHtcbiAgdGhpcy5pbnNlcnRlZCA9IGZhbHNlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzaG91bGRDYWxsUmVtb3ZlID0gaW5Eb2ModGhpcy5ub2RlKTtcbiAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgcmVtb3ZlTm9kZVJhbmdlKHRoaXMubm9kZSwgdGhpcy5lbmQsIHRoaXMudm0sIHRoaXMuZnJhZywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzaG91bGRDYWxsUmVtb3ZlKSB7XG4gICAgICBzZWxmLmNhbGxIb29rKGRldGFjaCk7XG4gICAgfVxuICAgIHNlbGYuZGVzdHJveSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcmVwYXJlIHRoZSBmcmFnbWVudCBmb3IgcmVtb3ZhbC5cbiAqL1xuXG5GcmFnbWVudC5wcm90b3R5cGUuYmVmb3JlUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSwgbDtcbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBjYWxsIHRoZSBzYW1lIG1ldGhvZCByZWN1cnNpdmVseSBvbiBjaGlsZFxuICAgIC8vIGZyYWdtZW50cywgZGVwdGgtZmlyc3RcbiAgICB0aGlzLmNoaWxkRnJhZ3NbaV0uYmVmb3JlUmVtb3ZlKGZhbHNlKTtcbiAgfVxuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBDYWxsIGRlc3Ryb3kgZm9yIGFsbCBjb250YWluZWQgaW5zdGFuY2VzLFxuICAgIC8vIHdpdGggcmVtb3ZlOmZhbHNlIGFuZCBkZWZlcjp0cnVlLlxuICAgIC8vIERlZmVyIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG9cbiAgICAvLyBrZWVwIHRoZSBjaGlsZHJlbiB0byBjYWxsIGRldGFjaCBob29rc1xuICAgIC8vIG9uIHRoZW0uXG4gICAgdGhpcy5jaGlsZHJlbltpXS4kZGVzdHJveShmYWxzZSwgdHJ1ZSk7XG4gIH1cbiAgdmFyIGRpcnMgPSB0aGlzLnVubGluay5kaXJzO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBkaXNhYmxlIHRoZSB3YXRjaGVycyBvbiBhbGwgdGhlIGRpcmVjdGl2ZXNcbiAgICAvLyBzbyB0aGF0IHRoZSByZW5kZXJlZCBjb250ZW50IHN0YXlzIHRoZSBzYW1lXG4gICAgLy8gZHVyaW5nIHJlbW92YWwuXG4gICAgZGlyc1tpXS5fd2F0Y2hlciAmJiBkaXJzW2ldLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgZnJhZ21lbnQuXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhcmVudEZyYWcpIHtcbiAgICB0aGlzLnBhcmVudEZyYWcuY2hpbGRGcmFncy4kcmVtb3ZlKHRoaXMpO1xuICB9XG4gIHRoaXMubm9kZS5fX3ZfZnJhZyA9IG51bGw7XG4gIHRoaXMudW5saW5rKCk7XG59O1xuXG4vKipcbiAqIENhbGwgYXR0YWNoIGhvb2sgZm9yIGEgVnVlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICovXG5cbmZ1bmN0aW9uIGF0dGFjaChjaGlsZCkge1xuICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkICYmIGluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICBjaGlsZC5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsIGRldGFjaCBob29rIGZvciBhIFZ1ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBkZXRhY2goY2hpbGQpIHtcbiAgaWYgKGNoaWxkLl9pc0F0dGFjaGVkICYmICFpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgY2hpbGQuX2NhbGxIb29rKCdkZXRhY2hlZCcpO1xuICB9XG59XG5cbnZhciBsaW5rZXJDYWNoZSA9IG5ldyBDYWNoZSg1MDAwKTtcblxuLyoqXG4gKiBBIGZhY3RvcnkgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGFcbiAqIGZyYWdtZW50LiBDYWNoZXMgdGhlIGNvbXBpbGVkIGxpbmtlciBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKi9cbmZ1bmN0aW9uIEZyYWdtZW50RmFjdG9yeSh2bSwgZWwpIHtcbiAgdGhpcy52bSA9IHZtO1xuICB2YXIgdGVtcGxhdGU7XG4gIHZhciBpc1N0cmluZyA9IHR5cGVvZiBlbCA9PT0gJ3N0cmluZyc7XG4gIGlmIChpc1N0cmluZyB8fCBpc1RlbXBsYXRlKGVsKSAmJiAhZWwuaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICB0ZW1wbGF0ZSA9IHBhcnNlVGVtcGxhdGUoZWwsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKGVsKTtcbiAgfVxuICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIC8vIGxpbmtlciBjYW4gYmUgY2FjaGVkLCBidXQgb25seSBmb3IgY29tcG9uZW50c1xuICB2YXIgbGlua2VyO1xuICB2YXIgY2lkID0gdm0uY29uc3RydWN0b3IuY2lkO1xuICBpZiAoY2lkID4gMCkge1xuICAgIHZhciBjYWNoZUlkID0gY2lkICsgKGlzU3RyaW5nID8gZWwgOiBnZXRPdXRlckhUTUwoZWwpKTtcbiAgICBsaW5rZXIgPSBsaW5rZXJDYWNoZS5nZXQoY2FjaGVJZCk7XG4gICAgaWYgKCFsaW5rZXIpIHtcbiAgICAgIGxpbmtlciA9IGNvbXBpbGUodGVtcGxhdGUsIHZtLiRvcHRpb25zLCB0cnVlKTtcbiAgICAgIGxpbmtlckNhY2hlLnB1dChjYWNoZUlkLCBsaW5rZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsaW5rZXIgPSBjb21waWxlKHRlbXBsYXRlLCB2bS4kb3B0aW9ucywgdHJ1ZSk7XG4gIH1cbiAgdGhpcy5saW5rZXIgPSBsaW5rZXI7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZnJhZ21lbnQgaW5zdGFuY2Ugd2l0aCBnaXZlbiBob3N0IGFuZCBzY29wZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gaG9zdFxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBwYXJlbnRGcmFnXG4gKi9cblxuRnJhZ21lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpIHtcbiAgdmFyIGZyYWcgPSBjbG9uZU5vZGUodGhpcy50ZW1wbGF0ZSk7XG4gIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5saW5rZXIsIHRoaXMudm0sIGZyYWcsIGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKTtcbn07XG5cbnZhciBPTiA9IDcwMDtcbnZhciBNT0RFTCA9IDgwMDtcbnZhciBCSU5EID0gODUwO1xudmFyIFRSQU5TSVRJT04gPSAxMTAwO1xudmFyIEVMID0gMTUwMDtcbnZhciBDT01QT05FTlQgPSAxNTAwO1xudmFyIFBBUlRJQUwgPSAxNzUwO1xudmFyIElGID0gMjEwMDtcbnZhciBGT1IgPSAyMjAwO1xudmFyIFNMT1QgPSAyMzAwO1xuXG52YXIgdWlkJDMgPSAwO1xuXG52YXIgdkZvciA9IHtcblxuICBwcmlvcml0eTogRk9SLFxuICB0ZXJtaW5hbDogdHJ1ZSxcblxuICBwYXJhbXM6IFsndHJhY2stYnknLCAnc3RhZ2dlcicsICdlbnRlci1zdGFnZ2VyJywgJ2xlYXZlLXN0YWdnZXInXSxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIHN1cHBvcnQgXCJpdGVtIGluL29mIGl0ZW1zXCIgc3ludGF4XG4gICAgdmFyIGluTWF0Y2ggPSB0aGlzLmV4cHJlc3Npb24ubWF0Y2goLyguKikgKD86aW58b2YpICguKikvKTtcbiAgICBpZiAoaW5NYXRjaCkge1xuICAgICAgdmFyIGl0TWF0Y2ggPSBpbk1hdGNoWzFdLm1hdGNoKC9cXCgoLiopLCguKilcXCkvKTtcbiAgICAgIGlmIChpdE1hdGNoKSB7XG4gICAgICAgIHRoaXMuaXRlcmF0b3IgPSBpdE1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGl0TWF0Y2hbMl0udHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5leHByZXNzaW9uID0gaW5NYXRjaFsyXTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYWxpYXMpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCB2LWZvciBleHByZXNzaW9uIFwiJyArIHRoaXMuZGVzY3JpcHRvci5yYXcgKyAnXCI6ICcgKyAnYWxpYXMgaXMgcmVxdWlyZWQuJywgdGhpcy52bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdWlkIGFzIGEgY2FjaGUgaWRlbnRpZmllclxuICAgIHRoaXMuaWQgPSAnX192LWZvcl9fJyArICsrdWlkJDM7XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGFuIG9wdGlvbiBsaXN0LFxuICAgIC8vIHNvIHRoYXQgd2Uga25vdyBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgPHNlbGVjdD4nc1xuICAgIC8vIHYtbW9kZWwgd2hlbiB0aGUgb3B0aW9uIGxpc3QgaGFzIGNoYW5nZWQuXG4gICAgLy8gYmVjYXVzZSB2LW1vZGVsIGhhcyBhIGxvd2VyIHByaW9yaXR5IHRoYW4gdi1mb3IsXG4gICAgLy8gdGhlIHYtbW9kZWwgaXMgbm90IGJvdW5kIGhlcmUgeWV0LCBzbyB3ZSBoYXZlIHRvXG4gICAgLy8gcmV0cml2ZSBpdCBpbiB0aGUgYWN0dWFsIHVwZGF0ZU1vZGVsKCkgZnVuY3Rpb24uXG4gICAgdmFyIHRhZyA9IHRoaXMuZWwudGFnTmFtZTtcbiAgICB0aGlzLmlzT3B0aW9uID0gKHRhZyA9PT0gJ09QVElPTicgfHwgdGFnID09PSAnT1BUR1JPVVAnKSAmJiB0aGlzLmVsLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCc7XG5cbiAgICAvLyBzZXR1cCBhbmNob3Igbm9kZXNcbiAgICB0aGlzLnN0YXJ0ID0gY3JlYXRlQW5jaG9yKCd2LWZvci1zdGFydCcpO1xuICAgIHRoaXMuZW5kID0gY3JlYXRlQW5jaG9yKCd2LWZvci1lbmQnKTtcbiAgICByZXBsYWNlKHRoaXMuZWwsIHRoaXMuZW5kKTtcbiAgICBiZWZvcmUodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuXG4gICAgLy8gY2FjaGVcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIGZyYWdtZW50IGZhY3RvcnlcbiAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHRoaXMuZWwpO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGRhdGEpIHtcbiAgICB0aGlzLmRpZmYoZGF0YSk7XG4gICAgdGhpcy51cGRhdGVSZWYoKTtcbiAgICB0aGlzLnVwZGF0ZU1vZGVsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpZmYsIGJhc2VkIG9uIG5ldyBkYXRhIGFuZCBvbGQgZGF0YSwgZGV0ZXJtaW5lIHRoZVxuICAgKiBtaW5pbXVtIGFtb3VudCBvZiBET00gbWFuaXB1bGF0aW9ucyBuZWVkZWQgdG8gbWFrZSB0aGVcbiAgICogRE9NIHJlZmxlY3QgdGhlIG5ldyBkYXRhIEFycmF5LlxuICAgKlxuICAgKiBUaGUgYWxnb3JpdGhtIGRpZmZzIHRoZSBuZXcgZGF0YSBBcnJheSBieSBzdG9yaW5nIGFcbiAgICogaGlkZGVuIHJlZmVyZW5jZSB0byBhbiBvd25lciB2bSBpbnN0YW5jZSBvbiBwcmV2aW91c2x5XG4gICAqIHNlZW4gZGF0YS4gVGhpcyBhbGxvd3MgdXMgdG8gYWNoaWV2ZSBPKG4pIHdoaWNoIGlzXG4gICAqIGJldHRlciB0aGFuIGEgbGV2ZW5zaHRlaW4gZGlzdGFuY2UgYmFzZWQgYWxnb3JpdGhtLFxuICAgKiB3aGljaCBpcyBPKG0gKiBuKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YVxuICAgKi9cblxuICBkaWZmOiBmdW5jdGlvbiBkaWZmKGRhdGEpIHtcbiAgICAvLyBjaGVjayBpZiB0aGUgQXJyYXkgd2FzIGNvbnZlcnRlZCBmcm9tIGFuIE9iamVjdFxuICAgIHZhciBpdGVtID0gZGF0YVswXTtcbiAgICB2YXIgY29udmVydGVkRnJvbU9iamVjdCA9IHRoaXMuZnJvbU9iamVjdCA9IGlzT2JqZWN0KGl0ZW0pICYmIGhhc093bihpdGVtLCAnJGtleScpICYmIGhhc093bihpdGVtLCAnJHZhbHVlJyk7XG5cbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIG9sZEZyYWdzID0gdGhpcy5mcmFncztcbiAgICB2YXIgZnJhZ3MgPSB0aGlzLmZyYWdzID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICB2YXIgYWxpYXMgPSB0aGlzLmFsaWFzO1xuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3I7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG4gICAgdmFyIGluRG9jdW1lbnQgPSBpbkRvYyhzdGFydCk7XG4gICAgdmFyIGluaXQgPSAhb2xkRnJhZ3M7XG4gICAgdmFyIGksIGwsIGZyYWcsIGtleSwgdmFsdWUsIHByaW1pdGl2ZTtcblxuICAgIC8vIEZpcnN0IHBhc3MsIGdvIHRocm91Z2ggdGhlIG5ldyBBcnJheSBhbmQgZmlsbCB1cFxuICAgIC8vIHRoZSBuZXcgZnJhZ3MgYXJyYXkuIElmIGEgcGllY2Ugb2YgZGF0YSBoYXMgYSBjYWNoZWRcbiAgICAvLyBpbnN0YW5jZSBmb3IgaXQsIHdlIHJldXNlIGl0LiBPdGhlcndpc2UgYnVpbGQgYSBuZXdcbiAgICAvLyBpbnN0YW5jZS5cbiAgICBmb3IgKGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBkYXRhW2ldO1xuICAgICAga2V5ID0gY29udmVydGVkRnJvbU9iamVjdCA/IGl0ZW0uJGtleSA6IG51bGw7XG4gICAgICB2YWx1ZSA9IGNvbnZlcnRlZEZyb21PYmplY3QgPyBpdGVtLiR2YWx1ZSA6IGl0ZW07XG4gICAgICBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgICAgZnJhZyA9ICFpbml0ICYmIHRoaXMuZ2V0Q2FjaGVkRnJhZyh2YWx1ZSwgaSwga2V5KTtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIC8vIHJldXNhYmxlIGZyYWdtZW50XG4gICAgICAgIGZyYWcucmV1c2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gdXBkYXRlICRpbmRleFxuICAgICAgICBmcmFnLnNjb3BlLiRpbmRleCA9IGk7XG4gICAgICAgIC8vIHVwZGF0ZSAka2V5XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlLiRrZXkgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGl0ZXJhdG9yXG4gICAgICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICAgIGZyYWcuc2NvcGVbaXRlcmF0b3JdID0ga2V5ICE9PSBudWxsID8ga2V5IDogaTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgZGF0YSBmb3IgdHJhY2stYnksIG9iamVjdCByZXBlYXQgJlxuICAgICAgICAvLyBwcmltaXRpdmUgdmFsdWVzLlxuICAgICAgICBpZiAodHJhY2tCeUtleSB8fCBjb252ZXJ0ZWRGcm9tT2JqZWN0IHx8IHByaW1pdGl2ZSkge1xuICAgICAgICAgIHdpdGhvdXRDb252ZXJzaW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZyYWcuc2NvcGVbYWxpYXNdID0gdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5ldyBpc250YW5jZVxuICAgICAgICBmcmFnID0gdGhpcy5jcmVhdGUodmFsdWUsIGFsaWFzLCBpLCBrZXkpO1xuICAgICAgICBmcmFnLmZyZXNoID0gIWluaXQ7XG4gICAgICB9XG4gICAgICBmcmFnc1tpXSA9IGZyYWc7XG4gICAgICBpZiAoaW5pdCkge1xuICAgICAgICBmcmFnLmJlZm9yZShlbmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdlJ3JlIGRvbmUgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICBpZiAoaW5pdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNlY29uZCBwYXNzLCBnbyB0aHJvdWdoIHRoZSBvbGQgZnJhZ21lbnRzIGFuZFxuICAgIC8vIGRlc3Ryb3kgdGhvc2Ugd2hvIGFyZSBub3QgcmV1c2VkIChhbmQgcmVtb3ZlIHRoZW1cbiAgICAvLyBmcm9tIGNhY2hlKVxuICAgIHZhciByZW1vdmFsSW5kZXggPSAwO1xuICAgIHZhciB0b3RhbFJlbW92ZWQgPSBvbGRGcmFncy5sZW5ndGggLSBmcmFncy5sZW5ndGg7XG4gICAgLy8gd2hlbiByZW1vdmluZyBhIGxhcmdlIG51bWJlciBvZiBmcmFnbWVudHMsIHdhdGNoZXIgcmVtb3ZhbFxuICAgIC8vIHR1cm5zIG91dCB0byBiZSBhIHBlcmYgYm90dGxlbmVjaywgc28gd2UgYmF0Y2ggdGhlIHdhdGNoZXJcbiAgICAvLyByZW1vdmFscyBpbnRvIGEgc2luZ2xlIGZpbHRlciBjYWxsIVxuICAgIHRoaXMudm0uX3ZGb3JSZW1vdmluZyA9IHRydWU7XG4gICAgZm9yIChpID0gMCwgbCA9IG9sZEZyYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZnJhZyA9IG9sZEZyYWdzW2ldO1xuICAgICAgaWYgKCFmcmFnLnJldXNlZCkge1xuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKGZyYWcsIHJlbW92YWxJbmRleCsrLCB0b3RhbFJlbW92ZWQsIGluRG9jdW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnZtLl92Rm9yUmVtb3ZpbmcgPSBmYWxzZTtcbiAgICBpZiAocmVtb3ZhbEluZGV4KSB7XG4gICAgICB0aGlzLnZtLl93YXRjaGVycyA9IHRoaXMudm0uX3dhdGNoZXJzLmZpbHRlcihmdW5jdGlvbiAodykge1xuICAgICAgICByZXR1cm4gdy5hY3RpdmU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbCBwYXNzLCBtb3ZlL2luc2VydCBuZXcgZnJhZ21lbnRzIGludG8gdGhlXG4gICAgLy8gcmlnaHQgcGxhY2UuXG4gICAgdmFyIHRhcmdldFByZXYsIHByZXZFbCwgY3VycmVudFByZXY7XG4gICAgdmFyIGluc2VydGlvbkluZGV4ID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gZnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmcmFnID0gZnJhZ3NbaV07XG4gICAgICAvLyB0aGlzIGlzIHRoZSBmcmFnIHRoYXQgd2Ugc2hvdWxkIGJlIGFmdGVyXG4gICAgICB0YXJnZXRQcmV2ID0gZnJhZ3NbaSAtIDFdO1xuICAgICAgcHJldkVsID0gdGFyZ2V0UHJldiA/IHRhcmdldFByZXYuc3RhZ2dlckNiID8gdGFyZ2V0UHJldi5zdGFnZ2VyQW5jaG9yIDogdGFyZ2V0UHJldi5lbmQgfHwgdGFyZ2V0UHJldi5ub2RlIDogc3RhcnQ7XG4gICAgICBpZiAoZnJhZy5yZXVzZWQgJiYgIWZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICAgIGN1cnJlbnRQcmV2ID0gZmluZFByZXZGcmFnKGZyYWcsIHN0YXJ0LCB0aGlzLmlkKTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcmV2ICE9PSB0YXJnZXRQcmV2ICYmICghY3VycmVudFByZXYgfHxcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uIGZvciBtb3ZpbmcgYSBzaW5nbGUgaXRlbS5cbiAgICAgICAgLy8gdGhhbmtzIHRvIHN1Z2dlc3Rpb25zIGJ5IEBsaXZvcmFzIGluICMxODA3XG4gICAgICAgIGZpbmRQcmV2RnJhZyhjdXJyZW50UHJldiwgc3RhcnQsIHRoaXMuaWQpICE9PSB0YXJnZXRQcmV2KSkge1xuICAgICAgICAgIHRoaXMubW92ZShmcmFnLCBwcmV2RWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgaW5zdGFuY2UsIG9yIHN0aWxsIGluIHN0YWdnZXIuXG4gICAgICAgIC8vIGluc2VydCB3aXRoIHVwZGF0ZWQgc3RhZ2dlciBpbmRleC5cbiAgICAgICAgdGhpcy5pbnNlcnQoZnJhZywgaW5zZXJ0aW9uSW5kZXgrKywgcHJldkVsLCBpbkRvY3VtZW50KTtcbiAgICAgIH1cbiAgICAgIGZyYWcucmV1c2VkID0gZnJhZy5mcmVzaCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhc1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICAgKi9cblxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgYWxpYXMsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgaG9zdCA9IHRoaXMuX2hvc3Q7XG4gICAgLy8gY3JlYXRlIGl0ZXJhdGlvbiBzY29wZVxuICAgIHZhciBwYXJlbnRTY29wZSA9IHRoaXMuX3Njb3BlIHx8IHRoaXMudm07XG4gICAgdmFyIHNjb3BlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZSk7XG4gICAgLy8gcmVmIGhvbGRlciBmb3IgdGhlIHNjb3BlXG4gICAgc2NvcGUuJHJlZnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlLiRyZWZzKTtcbiAgICBzY29wZS4kZWxzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZS4kZWxzKTtcbiAgICAvLyBtYWtlIHN1cmUgcG9pbnQgJHBhcmVudCB0byBwYXJlbnQgc2NvcGVcbiAgICBzY29wZS4kcGFyZW50ID0gcGFyZW50U2NvcGU7XG4gICAgLy8gZm9yIHR3by13YXkgYmluZGluZyBvbiBhbGlhc1xuICAgIHNjb3BlLiRmb3JDb250ZXh0ID0gdGhpcztcbiAgICAvLyBkZWZpbmUgc2NvcGUgcHJvcGVydGllc1xuICAgIC8vIGltcG9ydGFudDogZGVmaW5lIHRoZSBzY29wZSBhbGlhcyB3aXRob3V0IGZvcmNlZCBjb252ZXJzaW9uXG4gICAgLy8gc28gdGhhdCBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmVzIHJlbWFpbiBub24tcmVhY3RpdmUuXG4gICAgd2l0aG91dENvbnZlcnNpb24oZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsIGFsaWFzLCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsICckaW5kZXgnLCBpbmRleCk7XG4gICAgaWYgKGtleSkge1xuICAgICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsICcka2V5Jywga2V5KTtcbiAgICB9IGVsc2UgaWYgKHNjb3BlLiRrZXkpIHtcbiAgICAgIC8vIGF2b2lkIGFjY2lkZW50YWwgZmFsbGJhY2tcbiAgICAgIGRlZihzY29wZSwgJyRrZXknLCBudWxsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXRlcmF0b3IpIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCB0aGlzLml0ZXJhdG9yLCBrZXkgIT09IG51bGwgPyBrZXkgOiBpbmRleCk7XG4gICAgfVxuICAgIHZhciBmcmFnID0gdGhpcy5mYWN0b3J5LmNyZWF0ZShob3N0LCBzY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgZnJhZy5mb3JJZCA9IHRoaXMuaWQ7XG4gICAgdGhpcy5jYWNoZUZyYWcodmFsdWUsIGZyYWcsIGluZGV4LCBrZXkpO1xuICAgIHJldHVybiBmcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHYtcmVmIG9uIG93bmVyIHZtLlxuICAgKi9cblxuICB1cGRhdGVSZWY6IGZ1bmN0aW9uIHVwZGF0ZVJlZigpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5kZXNjcmlwdG9yLnJlZjtcbiAgICBpZiAoIXJlZikgcmV0dXJuO1xuICAgIHZhciBoYXNoID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRyZWZzO1xuICAgIHZhciByZWZzO1xuICAgIGlmICghdGhpcy5mcm9tT2JqZWN0KSB7XG4gICAgICByZWZzID0gdGhpcy5mcmFncy5tYXAoZmluZFZtRnJvbUZyYWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZzID0ge307XG4gICAgICB0aGlzLmZyYWdzLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgcmVmc1tmcmFnLnNjb3BlLiRrZXldID0gZmluZFZtRnJvbUZyYWcoZnJhZyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaGFzaFtyZWZdID0gcmVmcztcbiAgfSxcblxuICAvKipcbiAgICogRm9yIG9wdGlvbiBsaXN0cywgdXBkYXRlIHRoZSBjb250YWluaW5nIHYtbW9kZWwgb25cbiAgICogcGFyZW50IDxzZWxlY3Q+LlxuICAgKi9cblxuICB1cGRhdGVNb2RlbDogZnVuY3Rpb24gdXBkYXRlTW9kZWwoKSB7XG4gICAgaWYgKHRoaXMuaXNPcHRpb24pIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnN0YXJ0LnBhcmVudE5vZGU7XG4gICAgICB2YXIgbW9kZWwgPSBwYXJlbnQgJiYgcGFyZW50Ll9fdl9tb2RlbDtcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBtb2RlbC5mb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQuIEhhbmRsZXMgc3RhZ2dlcmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOb2RlfSBwcmV2RWxcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbkRvY3VtZW50XG4gICAqL1xuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KGZyYWcsIGluZGV4LCBwcmV2RWwsIGluRG9jdW1lbnQpIHtcbiAgICBpZiAoZnJhZy5zdGFnZ2VyQ2IpIHtcbiAgICAgIGZyYWcuc3RhZ2dlckNiLmNhbmNlbCgpO1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgc3RhZ2dlckFtb3VudCA9IHRoaXMuZ2V0U3RhZ2dlcihmcmFnLCBpbmRleCwgbnVsbCwgJ2VudGVyJyk7XG4gICAgaWYgKGluRG9jdW1lbnQgJiYgc3RhZ2dlckFtb3VudCkge1xuICAgICAgLy8gY3JlYXRlIGFuIGFuY2hvciBhbmQgaW5zZXJ0IGl0IHN5bmNocm9ub3VzbHksXG4gICAgICAvLyBzbyB0aGF0IHdlIGNhbiByZXNvbHZlIHRoZSBjb3JyZWN0IG9yZGVyIHdpdGhvdXRcbiAgICAgIC8vIHdvcnJ5aW5nIGFib3V0IHNvbWUgZWxlbWVudHMgbm90IGluc2VydGVkIHlldFxuICAgICAgdmFyIGFuY2hvciA9IGZyYWcuc3RhZ2dlckFuY2hvcjtcbiAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgIGFuY2hvciA9IGZyYWcuc3RhZ2dlckFuY2hvciA9IGNyZWF0ZUFuY2hvcignc3RhZ2dlci1hbmNob3InKTtcbiAgICAgICAgYW5jaG9yLl9fdl9mcmFnID0gZnJhZztcbiAgICAgIH1cbiAgICAgIGFmdGVyKGFuY2hvciwgcHJldkVsKTtcbiAgICAgIHZhciBvcCA9IGZyYWcuc3RhZ2dlckNiID0gY2FuY2VsbGFibGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgICAgIGZyYWcuYmVmb3JlKGFuY2hvcik7XG4gICAgICAgIHJlbW92ZShhbmNob3IpO1xuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KG9wLCBzdGFnZ2VyQW1vdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhcmdldCA9IHByZXZFbC5uZXh0U2libGluZztcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgLy8gcmVzZXQgZW5kIGFuY2hvciBwb3NpdGlvbiBpbiBjYXNlIHRoZSBwb3NpdGlvbiB3YXMgbWVzc2VkIHVwXG4gICAgICAgIC8vIGJ5IGFuIGV4dGVybmFsIGRyYWctbi1kcm9wIGxpYnJhcnkuXG4gICAgICAgIGFmdGVyKHRoaXMuZW5kLCBwcmV2RWwpO1xuICAgICAgICB0YXJnZXQgPSB0aGlzLmVuZDtcbiAgICAgIH1cbiAgICAgIGZyYWcuYmVmb3JlKHRhcmdldCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmcmFnbWVudC4gSGFuZGxlcyBzdGFnZ2VyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gdG90YWxcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbkRvY3VtZW50XG4gICAqL1xuXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGZyYWcsIGluZGV4LCB0b3RhbCwgaW5Eb2N1bWVudCkge1xuICAgIGlmIChmcmFnLnN0YWdnZXJDYikge1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IuY2FuY2VsKCk7XG4gICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgICAvLyBpdCdzIG5vdCBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgZnJhZyB0byBiZSByZW1vdmVkXG4gICAgICAvLyB0d2ljZSwgc28gaWYgd2UgaGF2ZSBhIHBlbmRpbmcgc3RhZ2dlciBjYWxsYmFjayxcbiAgICAgIC8vIGl0IG1lYW5zIHRoaXMgZnJhZyBpcyBxdWV1ZWQgZm9yIGVudGVyIGJ1dCByZW1vdmVkXG4gICAgICAvLyBiZWZvcmUgaXRzIHRyYW5zaXRpb24gc3RhcnRlZC4gU2luY2UgaXQgaXMgYWxyZWFkeVxuICAgICAgLy8gZGVzdHJveWVkLCB3ZSBjYW4ganVzdCBsZWF2ZSBpdCBpbiBkZXRhY2hlZCBzdGF0ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0YWdnZXJBbW91bnQgPSB0aGlzLmdldFN0YWdnZXIoZnJhZywgaW5kZXgsIHRvdGFsLCAnbGVhdmUnKTtcbiAgICBpZiAoaW5Eb2N1bWVudCAmJiBzdGFnZ2VyQW1vdW50KSB7XG4gICAgICB2YXIgb3AgPSBmcmFnLnN0YWdnZXJDYiA9IGNhbmNlbGxhYmxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgICAgICBmcmFnLnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KG9wLCBzdGFnZ2VyQW1vdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZy5yZW1vdmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmUgYSBmcmFnbWVudCB0byBhIG5ldyBwb3NpdGlvbi5cbiAgICogRm9yY2Ugbm8gdHJhbnNpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge05vZGV9IHByZXZFbFxuICAgKi9cblxuICBtb3ZlOiBmdW5jdGlvbiBtb3ZlKGZyYWcsIHByZXZFbCkge1xuICAgIC8vIGZpeCBhIGNvbW1vbiBpc3N1ZSB3aXRoIFNvcnRhYmxlOlxuICAgIC8vIGlmIHByZXZFbCBkb2Vzbid0IGhhdmUgbmV4dFNpYmxpbmcsIHRoaXMgbWVhbnMgaXQnc1xuICAgIC8vIGJlZW4gZHJhZ2dlZCBhZnRlciB0aGUgZW5kIGFuY2hvci4gSnVzdCByZS1wb3NpdGlvblxuICAgIC8vIHRoZSBlbmQgYW5jaG9yIHRvIHRoZSBlbmQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXByZXZFbC5uZXh0U2libGluZykge1xuICAgICAgdGhpcy5lbmQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmVuZCk7XG4gICAgfVxuICAgIGZyYWcuYmVmb3JlKHByZXZFbC5uZXh0U2libGluZywgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWNoZSBhIGZyYWdtZW50IHVzaW5nIHRyYWNrLWJ5IG9yIHRoZSBvYmplY3Qga2V5LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICAgKi9cblxuICBjYWNoZUZyYWc6IGZ1bmN0aW9uIGNhY2hlRnJhZyh2YWx1ZSwgZnJhZywgaW5kZXgsIGtleSkge1xuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgIHZhciBpZDtcbiAgICBpZiAoa2V5IHx8IHRyYWNrQnlLZXkgfHwgcHJpbWl0aXZlKSB7XG4gICAgICBpZCA9IGdldFRyYWNrQnlLZXkoaW5kZXgsIGtleSwgdmFsdWUsIHRyYWNrQnlLZXkpO1xuICAgICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgICAgY2FjaGVbaWRdID0gZnJhZztcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tCeUtleSAhPT0gJyRpbmRleCcpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHRoaXMuaWQ7XG4gICAgICBpZiAoaGFzT3duKHZhbHVlLCBpZCkpIHtcbiAgICAgICAgaWYgKHZhbHVlW2lkXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlW2lkXSA9IGZyYWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpKSB7XG4gICAgICAgIGRlZih2YWx1ZSwgaWQsIGZyYWcpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ0Zyb3plbiB2LWZvciBvYmplY3RzIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IHRyYWNrZWQsIG1ha2Ugc3VyZSB0byAnICsgJ3Byb3ZpZGUgYSB0cmFjay1ieSBrZXkuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZyYWcucmF3ID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIGNhY2hlZCBmcmFnbWVudCBmcm9tIHRoZSB2YWx1ZS9pbmRleC9rZXlcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAgICovXG5cbiAgZ2V0Q2FjaGVkRnJhZzogZnVuY3Rpb24gZ2V0Q2FjaGVkRnJhZyh2YWx1ZSwgaW5kZXgsIGtleSkge1xuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB2YXIgZnJhZztcbiAgICBpZiAoa2V5IHx8IHRyYWNrQnlLZXkgfHwgcHJpbWl0aXZlKSB7XG4gICAgICB2YXIgaWQgPSBnZXRUcmFja0J5S2V5KGluZGV4LCBrZXksIHZhbHVlLCB0cmFja0J5S2V5KTtcbiAgICAgIGZyYWcgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZyA9IHZhbHVlW3RoaXMuaWRdO1xuICAgIH1cbiAgICBpZiAoZnJhZyAmJiAoZnJhZy5yZXVzZWQgfHwgZnJhZy5mcmVzaCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGZyYWdtZW50IGZyb20gY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICovXG5cbiAgZGVsZXRlQ2FjaGVkRnJhZzogZnVuY3Rpb24gZGVsZXRlQ2FjaGVkRnJhZyhmcmFnKSB7XG4gICAgdmFyIHZhbHVlID0gZnJhZy5yYXc7XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBzY29wZSA9IGZyYWcuc2NvcGU7XG4gICAgdmFyIGluZGV4ID0gc2NvcGUuJGluZGV4O1xuICAgIC8vIGZpeCAjOTQ4OiBhdm9pZCBhY2NpZGVudGFsbHkgZmFsbCB0aHJvdWdoIHRvXG4gICAgLy8gYSBwYXJlbnQgcmVwZWF0ZXIgd2hpY2ggaGFwcGVucyB0byBoYXZlICRrZXkuXG4gICAgdmFyIGtleSA9IGhhc093bihzY29wZSwgJyRrZXknKSAmJiBzY29wZS4ka2V5O1xuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgIGlmICh0cmFja0J5S2V5IHx8IGtleSB8fCBwcmltaXRpdmUpIHtcbiAgICAgIHZhciBpZCA9IGdldFRyYWNrQnlLZXkoaW5kZXgsIGtleSwgdmFsdWUsIHRyYWNrQnlLZXkpO1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVt0aGlzLmlkXSA9IG51bGw7XG4gICAgICBmcmFnLnJhdyA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YWdnZXIgYW1vdW50IGZvciBhbiBpbnNlcnRpb24vcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqL1xuXG4gIGdldFN0YWdnZXI6IGZ1bmN0aW9uIGdldFN0YWdnZXIoZnJhZywgaW5kZXgsIHRvdGFsLCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgKyAnU3RhZ2dlcic7XG4gICAgdmFyIHRyYW5zID0gZnJhZy5ub2RlLl9fdl90cmFucztcbiAgICB2YXIgaG9va3MgPSB0cmFucyAmJiB0cmFucy5ob29rcztcbiAgICB2YXIgaG9vayA9IGhvb2tzICYmIChob29rc1t0eXBlXSB8fCBob29rcy5zdGFnZ2VyKTtcbiAgICByZXR1cm4gaG9vayA/IGhvb2suY2FsbChmcmFnLCBpbmRleCwgdG90YWwpIDogaW5kZXggKiBwYXJzZUludCh0aGlzLnBhcmFtc1t0eXBlXSB8fCB0aGlzLnBhcmFtcy5zdGFnZ2VyLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByZS1wcm9jZXNzIHRoZSB2YWx1ZSBiZWZvcmUgcGlwaW5nIGl0IHRocm91Z2ggdGhlXG4gICAqIGZpbHRlcnMuIFRoaXMgaXMgcGFzc2VkIHRvIGFuZCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIuXG4gICAqL1xuXG4gIF9wcmVQcm9jZXNzOiBmdW5jdGlvbiBfcHJlUHJvY2Vzcyh2YWx1ZSkge1xuICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdHlwZSwgc3RvcmUgdGhlIHVuLWZpbHRlcmVkIHJhdyB2YWx1ZS5cbiAgICB0aGlzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQb3N0LXByb2Nlc3MgdGhlIHZhbHVlIGFmdGVyIGl0IGhhcyBiZWVuIHBpcGVkIHRocm91Z2hcbiAgICogdGhlIGZpbHRlcnMuIFRoaXMgaXMgcGFzc2VkIHRvIGFuZCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIuXG4gICAqXG4gICAqIEl0IGlzIG5lY2Vzc2FyeSBmb3IgdGhpcyB0byBiZSBjYWxsZWQgZHVyaW5nIHRoZVxuICAgKiB3YXRjaGVyJ3MgZGVwZW5kZW5jeSBjb2xsZWN0aW9uIHBoYXNlIGJlY2F1c2Ugd2Ugd2FudFxuICAgKiB0aGUgdi1mb3IgdG8gdXBkYXRlIHdoZW4gdGhlIHNvdXJjZSBPYmplY3QgaXMgbXV0YXRlZC5cbiAgICovXG5cbiAgX3Bvc3RQcm9jZXNzOiBmdW5jdGlvbiBfcG9zdFByb2Nlc3ModmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAvLyBjb252ZXJ0IHBsYWluIG9iamVjdCB0byBhcnJheS5cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkoaSk7XG4gICAgICB2YXIga2V5O1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXNbaV0gPSB7XG4gICAgICAgICAgJGtleToga2V5LFxuICAgICAgICAgICR2YWx1ZTogdmFsdWVba2V5XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHJhbmdlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSB8fCBbXTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgaWYgKHRoaXMuZGVzY3JpcHRvci5yZWYpIHtcbiAgICAgICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kcmVmc1t0aGlzLmRlc2NyaXB0b3IucmVmXSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdzKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuZnJhZ3MubGVuZ3RoO1xuICAgICAgdmFyIGZyYWc7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLmZyYWdzW2ldO1xuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZyk7XG4gICAgICAgIGZyYWcuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gZmluZCB0aGUgcHJldmlvdXMgZWxlbWVudCB0aGF0IGlzIGEgZnJhZ21lbnRcbiAqIGFuY2hvci4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBhIGRlc3Ryb3llZCBmcmFnJ3NcbiAqIGVsZW1lbnQgY291bGQgc3RpbGwgYmUgbGluZ2VyaW5nIGluIHRoZSBET00gYmVmb3JlIGl0c1xuICogbGVhdmluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLCBidXQgaXRzIGluc2VydGVkIGZsYWdcbiAqIHNob3VsZCBoYXZlIGJlZW4gc2V0IHRvIGZhbHNlIHNvIHdlIGNhbiBza2lwIHRoZW0uXG4gKlxuICogSWYgdGhpcyBpcyBhIGJsb2NrIHJlcGVhdCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2Ugb25seVxuICogcmV0dXJuIGZyYWcgdGhhdCBpcyBib3VuZCB0byB0aGlzIHYtZm9yLiAoc2VlICM5MjkpXG4gKlxuICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtDb21tZW50fFRleHR9IGFuY2hvclxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kUHJldkZyYWcoZnJhZywgYW5jaG9yLCBpZCkge1xuICB2YXIgZWwgPSBmcmFnLm5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFlbCkgcmV0dXJuO1xuICBmcmFnID0gZWwuX192X2ZyYWc7XG4gIHdoaWxlICgoIWZyYWcgfHwgZnJhZy5mb3JJZCAhPT0gaWQgfHwgIWZyYWcuaW5zZXJ0ZWQpICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgZnJhZyA9IGVsLl9fdl9mcmFnO1xuICB9XG4gIHJldHVybiBmcmFnO1xufVxuXG4vKipcbiAqIEZpbmQgYSB2bSBmcm9tIGEgZnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICogQHJldHVybiB7VnVlfHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kVm1Gcm9tRnJhZyhmcmFnKSB7XG4gIHZhciBub2RlID0gZnJhZy5ub2RlO1xuICAvLyBoYW5kbGUgbXVsdGktbm9kZSBmcmFnXG4gIGlmIChmcmFnLmVuZCkge1xuICAgIHdoaWxlICghbm9kZS5fX3Z1ZV9fICYmIG5vZGUgIT09IGZyYWcuZW5kICYmIG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZS5fX3Z1ZV9fO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJhbmdlIGFycmF5IGZyb20gZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiByYW5nZShuKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoTWF0aC5mbG9vcihuKSk7XG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmV0W2ldID0gaTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgdHJhY2sgYnkga2V5IGZvciBhbiBpdGVtLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IFt0cmFja0J5S2V5XVxuICovXG5cbmZ1bmN0aW9uIGdldFRyYWNrQnlLZXkoaW5kZXgsIGtleSwgdmFsdWUsIHRyYWNrQnlLZXkpIHtcbiAgcmV0dXJuIHRyYWNrQnlLZXkgPyB0cmFja0J5S2V5ID09PSAnJGluZGV4JyA/IGluZGV4IDogdHJhY2tCeUtleS5jaGFyQXQoMCkubWF0Y2goL1xcdy8pID8gZ2V0UGF0aCh2YWx1ZSwgdHJhY2tCeUtleSkgOiB2YWx1ZVt0cmFja0J5S2V5XSA6IGtleSB8fCB2YWx1ZTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdkZvci53YXJuRHVwbGljYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgd2FybignRHVwbGljYXRlIHZhbHVlIGZvdW5kIGluIHYtZm9yPVwiJyArIHRoaXMuZGVzY3JpcHRvci5yYXcgKyAnXCI6ICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnLiBVc2UgdHJhY2stYnk9XCIkaW5kZXhcIiBpZiAnICsgJ3lvdSBhcmUgZXhwZWN0aW5nIGR1cGxpY2F0ZSB2YWx1ZXMuJywgdGhpcy52bSk7XG4gIH07XG59XG5cbnZhciB2SWYgPSB7XG5cbiAgcHJpb3JpdHk6IElGLFxuICB0ZXJtaW5hbDogdHJ1ZSxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgaWYgKCFlbC5fX3Z1ZV9fKSB7XG4gICAgICAvLyBjaGVjayBlbHNlIGJsb2NrXG4gICAgICB2YXIgbmV4dCA9IGVsLm5leHRFbGVtZW50U2libGluZztcbiAgICAgIGlmIChuZXh0ICYmIGdldEF0dHIobmV4dCwgJ3YtZWxzZScpICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZShuZXh0KTtcbiAgICAgICAgdGhpcy5lbHNlRWwgPSBuZXh0O1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgbWFpbiBibG9ja1xuICAgICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtaWYnKTtcbiAgICAgIHJlcGxhY2UoZWwsIHRoaXMuYW5jaG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LWlmPVwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiBjYW5ub3QgYmUgJyArICd1c2VkIG9uIGFuIGluc3RhbmNlIHJvb3QgZWxlbWVudC4nLCB0aGlzLnZtKTtcbiAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmZyYWcpIHtcbiAgICAgICAgdGhpcy5pbnNlcnQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoKSB7XG4gICAgaWYgKHRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIHRoaXMuZWxzZUZyYWcucmVtb3ZlKCk7XG4gICAgICB0aGlzLmVsc2VGcmFnID0gbnVsbDtcbiAgICB9XG4gICAgLy8gbGF6eSBpbml0IGZhY3RvcnlcbiAgICBpZiAoIXRoaXMuZmFjdG9yeSkge1xuICAgICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnID0gdGhpcy5mYWN0b3J5LmNyZWF0ZSh0aGlzLl9ob3N0LCB0aGlzLl9zY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgdGhpcy5mcmFnLmJlZm9yZSh0aGlzLmFuY2hvcik7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgdGhpcy5mcmFnLnJlbW92ZSgpO1xuICAgICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWxzZUVsICYmICF0aGlzLmVsc2VGcmFnKSB7XG4gICAgICBpZiAoIXRoaXMuZWxzZUZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5lbHNlRmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy5lbHNlRWwuX2NvbnRleHQgfHwgdGhpcy52bSwgdGhpcy5lbHNlRWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbHNlRnJhZyA9IHRoaXMuZWxzZUZhY3RvcnkuY3JlYXRlKHRoaXMuX2hvc3QsIHRoaXMuX3Njb3BlLCB0aGlzLl9mcmFnKTtcbiAgICAgIHRoaXMuZWxzZUZyYWcuYmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgdGhpcy5mcmFnLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIHRoaXMuZWxzZUZyYWcuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHNob3cgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBjaGVjayBlbHNlIGJsb2NrXG4gICAgdmFyIG5leHQgPSB0aGlzLmVsLm5leHRFbGVtZW50U2libGluZztcbiAgICBpZiAobmV4dCAmJiBnZXRBdHRyKG5leHQsICd2LWVsc2UnKSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5lbHNlRWwgPSBuZXh0O1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuYXBwbHkodGhpcy5lbCwgdmFsdWUpO1xuICAgIGlmICh0aGlzLmVsc2VFbCkge1xuICAgICAgdGhpcy5hcHBseSh0aGlzLmVsc2VFbCwgIXZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KGVsLCB2YWx1ZSkge1xuICAgIGlmIChpbkRvYyhlbCkpIHtcbiAgICAgIGFwcGx5VHJhbnNpdGlvbihlbCwgdmFsdWUgPyAxIDogLTEsIHRvZ2dsZSwgdGhpcy52bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvZ2dsZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyAnJyA6ICdub25lJztcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0ZXh0JDIgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgaXNSYW5nZSA9IGVsLnR5cGUgPT09ICdyYW5nZSc7XG4gICAgdmFyIGxhenkgPSB0aGlzLnBhcmFtcy5sYXp5O1xuICAgIHZhciBudW1iZXIgPSB0aGlzLnBhcmFtcy5udW1iZXI7XG4gICAgdmFyIGRlYm91bmNlID0gdGhpcy5wYXJhbXMuZGVib3VuY2U7XG5cbiAgICAvLyBoYW5kbGUgY29tcG9zaXRpb24gZXZlbnRzLlxuICAgIC8vICAgaHR0cDovL2Jsb2cuZXZhbnlvdS5tZS8yMDE0LzAxLzAzL2NvbXBvc2l0aW9uLWV2ZW50L1xuICAgIC8vIHNraXAgdGhpcyBmb3IgQW5kcm9pZCBiZWNhdXNlIGl0IGhhbmRsZXMgY29tcG9zaXRpb25cbiAgICAvLyBldmVudHMgcXVpdGUgZGlmZmVyZW50bHkuIEFuZHJvaWQgZG9lc24ndCB0cmlnZ2VyXG4gICAgLy8gY29tcG9zaXRpb24gZXZlbnRzIGZvciBsYW5ndWFnZSBpbnB1dCBtZXRob2RzIGUuZy5cbiAgICAvLyBDaGluZXNlLCBidXQgaW5zdGVhZCB0cmlnZ2VycyB0aGVtIGZvciBzcGVsbGluZ1xuICAgIC8vIHN1Z2dlc3Rpb25zLi4uIChzZWUgRGlzY3Vzc2lvbi8jMTYyKVxuICAgIHZhciBjb21wb3NpbmcgPSBmYWxzZTtcbiAgICBpZiAoIWlzQW5kcm9pZCAmJiAhaXNSYW5nZSkge1xuICAgICAgdGhpcy5vbignY29tcG9zaXRpb25zdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcG9zaW5nID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignY29tcG9zaXRpb25lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICAvLyBpbiBJRTExIHRoZSBcImNvbXBvc2l0aW9uZW5kXCIgZXZlbnQgZmlyZXMgQUZURVJcbiAgICAgICAgLy8gdGhlIFwiaW5wdXRcIiBldmVudCwgc28gdGhlIGlucHV0IGhhbmRsZXIgaXMgYmxvY2tlZFxuICAgICAgICAvLyBhdCB0aGUgZW5kLi4uIGhhdmUgdG8gY2FsbCBpdCBoZXJlLlxuICAgICAgICAvL1xuICAgICAgICAvLyAjMTMyNzogaW4gbGF6eSBtb2RlIHRoaXMgaXMgdW5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgICAgc2VsZi5saXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IG1lc3Npbmcgd2l0aCB0aGUgaW5wdXQgd2hlbiB1c2VyIGlzIHR5cGluZyxcbiAgICAvLyBhbmQgZm9yY2UgdXBkYXRlIG9uIGJsdXIuXG4gICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgaWYgKCFpc1JhbmdlICYmICFsYXp5KSB7XG4gICAgICB0aGlzLm9uKCdmb2N1cycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignYmx1cicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIC8vIGRvIG5vdCBzeW5jIHZhbHVlIGFmdGVyIGZyYWdtZW50IHJlbW92YWwgKCMyMDE3KVxuICAgICAgICBpZiAoIXNlbGYuX2ZyYWcgfHwgc2VsZi5fZnJhZy5pbnNlcnRlZCkge1xuICAgICAgICAgIHNlbGYucmF3TGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTm93IGF0dGFjaCB0aGUgbWFpbiBsaXN0ZW5lclxuICAgIHRoaXMubGlzdGVuZXIgPSB0aGlzLnJhd0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNvbXBvc2luZyB8fCAhc2VsZi5fYm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHZhbCA9IG51bWJlciB8fCBpc1JhbmdlID8gdG9OdW1iZXIoZWwudmFsdWUpIDogZWwudmFsdWU7XG4gICAgICBzZWxmLnNldCh2YWwpO1xuICAgICAgLy8gZm9yY2UgdXBkYXRlIG9uIG5leHQgdGljayB0byBhdm9pZCBsb2NrICYgc2FtZSB2YWx1ZVxuICAgICAgLy8gYWxzbyBvbmx5IHVwZGF0ZSB3aGVuIHVzZXIgaXMgbm90IHR5cGluZ1xuICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5fYm91bmQgJiYgIXNlbGYuZm9jdXNlZCkge1xuICAgICAgICAgIHNlbGYudXBkYXRlKHNlbGYuX3dhdGNoZXIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gYXBwbHkgZGVib3VuY2VcbiAgICBpZiAoZGVib3VuY2UpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIgPSBfZGVib3VuY2UodGhpcy5saXN0ZW5lciwgZGVib3VuY2UpO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgalF1ZXJ5IGV2ZW50cywgc2luY2UgalF1ZXJ5LnRyaWdnZXIoKSBkb2Vzbid0XG4gICAgLy8gdHJpZ2dlciBuYXRpdmUgZXZlbnRzIGluIHNvbWUgY2FzZXMgYW5kIHNvbWUgcGx1Z2luc1xuICAgIC8vIHJlbHkgb24gJC50cmlnZ2VyKClcbiAgICAvL1xuICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIGlmIGEgbGlzdGVuZXIgaXMgYXR0YWNoZWQgdXNpbmdcbiAgICAvLyBqUXVlcnksIGl0IGlzIGFsc28gcmVtb3ZlZCB3aXRoIGpRdWVyeSwgdGhhdCdzIHdoeVxuICAgIC8vIHdlIGRvIHRoZSBjaGVjayBmb3IgZWFjaCBkaXJlY3RpdmUgaW5zdGFuY2UgYW5kXG4gICAgLy8gc3RvcmUgdGhhdCBjaGVjayByZXN1bHQgb24gaXRzZWxmLiBUaGlzIGFsc28gYWxsb3dzXG4gICAgLy8gZWFzaWVyIHRlc3QgY292ZXJhZ2UgY29udHJvbCBieSB1bnNldHRpbmcgdGhlIGdsb2JhbFxuICAgIC8vIGpRdWVyeSB2YXJpYWJsZSBpbiB0ZXN0cy5cbiAgICB0aGlzLmhhc2pRdWVyeSA9IHR5cGVvZiBqUXVlcnkgPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKHRoaXMuaGFzalF1ZXJ5KSB7XG4gICAgICB2YXIgbWV0aG9kID0galF1ZXJ5LmZuLm9uID8gJ29uJyA6ICdiaW5kJztcbiAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnY2hhbmdlJywgdGhpcy5yYXdMaXN0ZW5lcik7XG4gICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdpbnB1dCcsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLnJhd0xpc3RlbmVyKTtcbiAgICAgIGlmICghbGF6eSkge1xuICAgICAgICB0aGlzLm9uKCdpbnB1dCcsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElFOSBkb2Vzbid0IGZpcmUgaW5wdXQgZXZlbnQgb24gYmFja3NwYWNlL2RlbC9jdXRcbiAgICBpZiAoIWxhenkgJiYgaXNJRTkpIHtcbiAgICAgIHRoaXMub24oJ2N1dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dFRpY2soc2VsZi5saXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2tleXVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gNDYgfHwgZS5rZXlDb2RlID09PSA4KSB7XG4gICAgICAgICAgc2VsZi5saXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZSBpZiBwcmVzZW50XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSB8fCBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmIGVsLnZhbHVlLnRyaW0oKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIC8vICMzMDI5IG9ubHkgdXBkYXRlIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuIFRoaXMgcHJldmVudFxuICAgIC8vIGJyb3dzZXJzIGZyb20gb3ZlcndyaXRpbmcgdmFsdWVzIGxpa2Ugc2VsZWN0aW9uU3RhcnRcbiAgICB2YWx1ZSA9IF90b1N0cmluZyh2YWx1ZSk7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLmVsLnZhbHVlKSB0aGlzLmVsLnZhbHVlID0gdmFsdWU7XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBpZiAodGhpcy5oYXNqUXVlcnkpIHtcbiAgICAgIHZhciBtZXRob2QgPSBqUXVlcnkuZm4ub2ZmID8gJ29mZicgOiAndW5iaW5kJztcbiAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2lucHV0JywgdGhpcy5saXN0ZW5lcik7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcmFkaW8gPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB2YWx1ZSBvdmVyd3JpdGUgdmlhIHYtYmluZDp2YWx1ZVxuICAgICAgaWYgKGVsLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHZhbCA9IGVsLnZhbHVlO1xuICAgICAgaWYgKHNlbGYucGFyYW1zLm51bWJlcikge1xuICAgICAgICB2YWwgPSB0b051bWJlcih2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuc2V0KHNlbGYuZ2V0VmFsdWUoKSk7XG4gICAgfTtcbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcblxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gIH1cbn07XG5cbnZhciBzZWxlY3QgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICAvLyBtZXRob2QgdG8gZm9yY2UgdXBkYXRlIERPTSB1c2luZyBsYXRlc3QgdmFsdWUuXG4gICAgdGhpcy5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLl93YXRjaGVyKSB7XG4gICAgICAgIHNlbGYudXBkYXRlKHNlbGYuX3dhdGNoZXIuZ2V0KCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGEgbXVsdGlwbGUgc2VsZWN0XG4gICAgdmFyIG11bHRpcGxlID0gdGhpcy5tdWx0aXBsZSA9IGVsLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKTtcblxuICAgIC8vIGF0dGFjaCBsaXN0ZW5lclxuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShlbCwgbXVsdGlwbGUpO1xuICAgICAgdmFsdWUgPSBzZWxmLnBhcmFtcy5udW1iZXIgPyBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh0b051bWJlcikgOiB0b051bWJlcih2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgIHNlbGYuc2V0KHZhbHVlKTtcbiAgICB9O1xuICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuXG4gICAgLy8gaWYgaGFzIGluaXRpYWwgdmFsdWUsIHNldCBhZnRlckJpbmRcbiAgICB2YXIgaW5pdFZhbHVlID0gZ2V0VmFsdWUoZWwsIG11bHRpcGxlLCB0cnVlKTtcbiAgICBpZiAobXVsdGlwbGUgJiYgaW5pdFZhbHVlLmxlbmd0aCB8fCAhbXVsdGlwbGUgJiYgaW5pdFZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgfVxuXG4gICAgLy8gQWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBGaXJlZm94IHJlc2V0c1xuICAgIC8vIHNlbGVjdGVkSW5kZXggd2l0aCB2YWx1ZSAtMSB0byAwIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAvLyBpcyBhcHBlbmRlZCB0byBhIG5ldyBwYXJlbnQsIHRoZXJlZm9yZSB3ZSBoYXZlIHRvXG4gICAgLy8gZm9yY2UgYSBET00gdXBkYXRlIHdoZW5ldmVyIHRoYXQgaGFwcGVucy4uLlxuICAgIHRoaXMudm0uJG9uKCdob29rOmF0dGFjaGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgbmV4dFRpY2soX3RoaXMuZm9yY2VVcGRhdGUpO1xuICAgIH0pO1xuICAgIGlmICghaW5Eb2MoZWwpKSB7XG4gICAgICBuZXh0VGljayh0aGlzLmZvcmNlVXBkYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICB2YXIgbXVsdGkgPSB0aGlzLm11bHRpcGxlICYmIGlzQXJyYXkodmFsdWUpO1xuICAgIHZhciBvcHRpb25zID0gZWwub3B0aW9ucztcbiAgICB2YXIgaSA9IG9wdGlvbnMubGVuZ3RoO1xuICAgIHZhciBvcCwgdmFsO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIG9wID0gb3B0aW9uc1tpXTtcbiAgICAgIHZhbCA9IG9wLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSA/IG9wLl92YWx1ZSA6IG9wLnZhbHVlO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gICAgICBvcC5zZWxlY3RlZCA9IG11bHRpID8gaW5kZXhPZiQxKHZhbHVlLCB2YWwpID4gLTEgOiBsb29zZUVxdWFsKHZhbHVlLCB2YWwpO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aGlzLnZtLiRvZmYoJ2hvb2s6YXR0YWNoZWQnLCB0aGlzLmZvcmNlVXBkYXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgc2VsZWN0IHZhbHVlXG4gKlxuICogQHBhcmFtIHtTZWxlY3RFbGVtZW50fSBlbFxuICogQHBhcmFtIHtCb29sZWFufSBtdWx0aVxuICogQHBhcmFtIHtCb29sZWFufSBpbml0XG4gKiBAcmV0dXJuIHtBcnJheXwqfVxuICovXG5cbmZ1bmN0aW9uIGdldFZhbHVlKGVsLCBtdWx0aSwgaW5pdCkge1xuICB2YXIgcmVzID0gbXVsdGkgPyBbXSA6IG51bGw7XG4gIHZhciBvcCwgdmFsLCBzZWxlY3RlZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wID0gZWwub3B0aW9uc1tpXTtcbiAgICBzZWxlY3RlZCA9IGluaXQgPyBvcC5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJykgOiBvcC5zZWxlY3RlZDtcbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgIHZhbCA9IG9wLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSA/IG9wLl92YWx1ZSA6IG9wLnZhbHVlO1xuICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgIHJlcy5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIE5hdGl2ZSBBcnJheS5pbmRleE9mIHVzZXMgc3RyaWN0IGVxdWFsLCBidXQgaW4gdGhpc1xuICogY2FzZSB3ZSBuZWVkIHRvIG1hdGNoIHN0cmluZy9udW1iZXJzIHdpdGggY3VzdG9tIGVxdWFsLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBpbmRleE9mJDEoYXJyLCB2YWwpIHtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgY2hlY2tib3ggPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZWwuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpID8gZWwuX3ZhbHVlIDogc2VsZi5wYXJhbXMubnVtYmVyID8gdG9OdW1iZXIoZWwudmFsdWUpIDogZWwudmFsdWU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldEJvb2xlYW5WYWx1ZSgpIHtcbiAgICAgIHZhciB2YWwgPSBlbC5jaGVja2VkO1xuICAgICAgaWYgKHZhbCAmJiBlbC5oYXNPd25Qcm9wZXJ0eSgnX3RydWVWYWx1ZScpKSB7XG4gICAgICAgIHJldHVybiBlbC5fdHJ1ZVZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ19mYWxzZVZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl9mYWxzZVZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1vZGVsID0gc2VsZi5fd2F0Y2hlci52YWx1ZTtcbiAgICAgIGlmIChpc0FycmF5KG1vZGVsKSkge1xuICAgICAgICB2YXIgdmFsID0gc2VsZi5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAoZWwuY2hlY2tlZCkge1xuICAgICAgICAgIGlmIChpbmRleE9mKG1vZGVsLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgbW9kZWwucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbC4kcmVtb3ZlKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2V0KGdldEJvb2xlYW5WYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBpbmRleE9mKHZhbHVlLCB0aGlzLmdldFZhbHVlKCkpID4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbC5oYXNPd25Qcm9wZXJ0eSgnX3RydWVWYWx1ZScpKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBlbC5fdHJ1ZVZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhhbmRsZXJzID0ge1xuICB0ZXh0OiB0ZXh0JDIsXG4gIHJhZGlvOiByYWRpbyxcbiAgc2VsZWN0OiBzZWxlY3QsXG4gIGNoZWNrYm94OiBjaGVja2JveFxufTtcblxudmFyIG1vZGVsID0ge1xuXG4gIHByaW9yaXR5OiBNT0RFTCxcbiAgdHdvV2F5OiB0cnVlLFxuICBoYW5kbGVyczogaGFuZGxlcnMsXG4gIHBhcmFtczogWydsYXp5JywgJ251bWJlcicsICdkZWJvdW5jZSddLFxuXG4gIC8qKlxuICAgKiBQb3NzaWJsZSBlbGVtZW50czpcbiAgICogICA8c2VsZWN0PlxuICAgKiAgIDx0ZXh0YXJlYT5cbiAgICogICA8aW5wdXQgdHlwZT1cIipcIj5cbiAgICogICAgIC0gdGV4dFxuICAgKiAgICAgLSBjaGVja2JveFxuICAgKiAgICAgLSByYWRpb1xuICAgKiAgICAgLSBudW1iZXJcbiAgICovXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBmcmllbmRseSB3YXJuaW5nLi4uXG4gICAgdGhpcy5jaGVja0ZpbHRlcnMoKTtcbiAgICBpZiAodGhpcy5oYXNSZWFkICYmICF0aGlzLmhhc1dyaXRlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgYSByZWFkLW9ubHkgZmlsdGVyIHdpdGggJyArICd2LW1vZGVsPVwiJyArIHRoaXMuZGVzY3JpcHRvci5yYXcgKyAnXCIuICcgKyAnWW91IG1pZ2h0IHdhbnQgdG8gdXNlIGEgdHdvLXdheSBmaWx0ZXIgdG8gZW5zdXJlIGNvcnJlY3QgYmVoYXZpb3IuJywgdGhpcy52bSk7XG4gICAgfVxuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIHRhZyA9IGVsLnRhZ05hbWU7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKHRhZyA9PT0gJ0lOUFVUJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzW2VsLnR5cGVdIHx8IGhhbmRsZXJzLnRleHQ7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdTRUxFQ1QnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnMuc2VsZWN0O1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnMudGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LW1vZGVsIGRvZXMgbm90IHN1cHBvcnQgZWxlbWVudCB0eXBlOiAnICsgdGFnLCB0aGlzLnZtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWwuX192X21vZGVsID0gdGhpcztcbiAgICBoYW5kbGVyLmJpbmQuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnVwZGF0ZSA9IGhhbmRsZXIudXBkYXRlO1xuICAgIHRoaXMuX3VuYmluZCA9IGhhbmRsZXIudW5iaW5kO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayByZWFkL3dyaXRlIGZpbHRlciBzdGF0cy5cbiAgICovXG5cbiAgY2hlY2tGaWx0ZXJzOiBmdW5jdGlvbiBjaGVja0ZpbHRlcnMoKSB7XG4gICAgdmFyIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnM7XG4gICAgaWYgKCFmaWx0ZXJzKSByZXR1cm47XG4gICAgdmFyIGkgPSBmaWx0ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgZmlsdGVyID0gcmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICdmaWx0ZXJzJywgZmlsdGVyc1tpXS5uYW1lKTtcbiAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IGZpbHRlci5yZWFkKSB7XG4gICAgICAgIHRoaXMuaGFzUmVhZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyLndyaXRlKSB7XG4gICAgICAgIHRoaXMuaGFzV3JpdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLmVsLl9fdl9tb2RlbCA9IG51bGw7XG4gICAgdGhpcy5fdW5iaW5kICYmIHRoaXMuX3VuYmluZCgpO1xuICB9XG59O1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl0sXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDBcbn07XG5cbmZ1bmN0aW9uIGtleUZpbHRlcihoYW5kbGVyLCBrZXlzKSB7XG4gIHZhciBjb2RlcyA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBrZXkuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoY2hhckNvZGUgPiA0NyAmJiBjaGFyQ29kZSA8IDU4KSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgfVxuICAgIGlmIChrZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICBjaGFyQ29kZSA9IGtleS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoY2hhckNvZGUgPiA2NCAmJiBjaGFyQ29kZSA8IDkxKSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleUNvZGVzW2tleV07XG4gIH0pO1xuICBjb2RlcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgY29kZXMpO1xuICByZXR1cm4gZnVuY3Rpb24ga2V5SGFuZGxlcihlKSB7XG4gICAgaWYgKGNvZGVzLmluZGV4T2YoZS5rZXlDb2RlKSA+IC0xKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RvcEZpbHRlcihoYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdG9wSGFuZGxlcihlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50RmlsdGVyKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRIYW5kbGVyKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZkZpbHRlcihoYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZWxmSGFuZGxlcihlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgb24kMSA9IHtcblxuICBwcmlvcml0eTogT04sXG4gIGFjY2VwdFN0YXRlbWVudDogdHJ1ZSxcbiAga2V5Q29kZXM6IGtleUNvZGVzLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gZGVhbCB3aXRoIGlmcmFtZXNcbiAgICBpZiAodGhpcy5lbC50YWdOYW1lID09PSAnSUZSQU1FJyAmJiB0aGlzLmFyZyAhPT0gJ2xvYWQnKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLmlmcmFtZUJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uKHNlbGYuZWwuY29udGVudFdpbmRvdywgc2VsZi5hcmcsIHNlbGYuaGFuZGxlciwgc2VsZi5tb2RpZmllcnMuY2FwdHVyZSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbignbG9hZCcsIHRoaXMuaWZyYW1lQmluZCk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGhhbmRsZXIpIHtcbiAgICAvLyBzdHViIGEgbm9vcCBmb3Igdi1vbiB3aXRoIG5vIHZhbHVlLFxuICAgIC8vIGUuZy4gQG1vdXNlZG93bi5wcmV2ZW50XG4gICAgaWYgKCF0aGlzLmRlc2NyaXB0b3IucmF3KSB7XG4gICAgICBoYW5kbGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ3Ytb246JyArIHRoaXMuYXJnICsgJz1cIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCIgZXhwZWN0cyBhIGZ1bmN0aW9uIHZhbHVlLCAnICsgJ2dvdCAnICsgaGFuZGxlciwgdGhpcy52bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgbW9kaWZpZXJzXG4gICAgaWYgKHRoaXMubW9kaWZpZXJzLnN0b3ApIHtcbiAgICAgIGhhbmRsZXIgPSBzdG9wRmlsdGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RpZmllcnMucHJldmVudCkge1xuICAgICAgaGFuZGxlciA9IHByZXZlbnRGaWx0ZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGlmaWVycy5zZWxmKSB7XG4gICAgICBoYW5kbGVyID0gc2VsZkZpbHRlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgLy8ga2V5IGZpbHRlclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5tb2RpZmllcnMpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ICE9PSAnc3RvcCcgJiYga2V5ICE9PSAncHJldmVudCcgJiYga2V5ICE9PSAnc2VsZicgJiYga2V5ICE9PSAnY2FwdHVyZSc7XG4gICAgfSk7XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBoYW5kbGVyID0ga2V5RmlsdGVyKGhhbmRsZXIsIGtleXMpO1xuICAgIH1cblxuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXG4gICAgaWYgKHRoaXMuaWZyYW1lQmluZCkge1xuICAgICAgdGhpcy5pZnJhbWVCaW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uKHRoaXMuZWwsIHRoaXMuYXJnLCB0aGlzLmhhbmRsZXIsIHRoaXMubW9kaWZpZXJzLmNhcHR1cmUpO1xuICAgIH1cbiAgfSxcblxuICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5pZnJhbWVCaW5kID8gdGhpcy5lbC5jb250ZW50V2luZG93IDogdGhpcy5lbDtcbiAgICBpZiAodGhpcy5oYW5kbGVyKSB7XG4gICAgICBvZmYoZWwsIHRoaXMuYXJnLCB0aGlzLmhhbmRsZXIpO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlcyA9IFsnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW1zLSddO1xudmFyIGNhbWVsUHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcbnZhciBpbXBvcnRhbnRSRSA9IC8haW1wb3J0YW50Oz8kLztcbnZhciBwcm9wQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG52YXIgdGVzdEVsID0gbnVsbDtcblxudmFyIHN0eWxlID0ge1xuXG4gIGRlZXA6IHRydWUsXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5lbC5zdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUucmVkdWNlKGV4dGVuZCwge30pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUgfHwge30pO1xuICAgIH1cbiAgfSxcblxuICBoYW5kbGVPYmplY3Q6IGZ1bmN0aW9uIGhhbmRsZU9iamVjdCh2YWx1ZSkge1xuICAgIC8vIGNhY2hlIG9iamVjdCBzdHlsZXMgc28gdGhhdCBvbmx5IGNoYW5nZWQgcHJvcHNcbiAgICAvLyBhcmUgYWN0dWFsbHkgdXBkYXRlZC5cbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlIHx8ICh0aGlzLmNhY2hlID0ge30pO1xuICAgIHZhciBuYW1lLCB2YWw7XG4gICAgZm9yIChuYW1lIGluIGNhY2hlKSB7XG4gICAgICBpZiAoIShuYW1lIGluIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZShuYW1lLCBudWxsKTtcbiAgICAgICAgZGVsZXRlIGNhY2hlW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgIHZhbCA9IHZhbHVlW25hbWVdO1xuICAgICAgaWYgKHZhbCAhPT0gY2FjaGVbbmFtZV0pIHtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSB2YWw7XG4gICAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKG5hbWUsIHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZVNpbmdsZTogZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHByb3AsIHZhbHVlKSB7XG4gICAgcHJvcCA9IG5vcm1hbGl6ZShwcm9wKTtcbiAgICBpZiAoIXByb3ApIHJldHVybjsgLy8gdW5zdXBwb3J0ZWQgcHJvcFxuICAgIC8vIGNhc3QgcG9zc2libGUgbnVtYmVycy9ib29sZWFucyBpbnRvIHN0cmluZ3NcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgdmFsdWUgKz0gJyc7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB2YXIgaXNJbXBvcnRhbnQgPSBpbXBvcnRhbnRSRS50ZXN0KHZhbHVlKSA/ICdpbXBvcnRhbnQnIDogJyc7XG4gICAgICBpZiAoaXNJbXBvcnRhbnQpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignSXRcXCdzIHByb2JhYmx5IGEgYmFkIGlkZWEgdG8gdXNlICFpbXBvcnRhbnQgd2l0aCBpbmxpbmUgcnVsZXMuICcgKyAnVGhpcyBmZWF0dXJlIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFZ1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKS50cmltKCk7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcC5rZWJhYiwgdmFsdWUsIGlzSW1wb3J0YW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWwuc3R5bGVbcHJvcC5jYW1lbF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5zdHlsZVtwcm9wLmNhbWVsXSA9ICcnO1xuICAgIH1cbiAgfVxuXG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIENTUyBwcm9wZXJ0eSBuYW1lLlxuICogLSBjYWNoZSByZXN1bHRcbiAqIC0gYXV0byBwcmVmaXhcbiAqIC0gY2FtZWxDYXNlIC0+IGRhc2gtY2FzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplKHByb3ApIHtcbiAgaWYgKHByb3BDYWNoZVtwcm9wXSkge1xuICAgIHJldHVybiBwcm9wQ2FjaGVbcHJvcF07XG4gIH1cbiAgdmFyIHJlcyA9IHByZWZpeChwcm9wKTtcbiAgcHJvcENhY2hlW3Byb3BdID0gcHJvcENhY2hlW3Jlc10gPSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQXV0byBkZXRlY3QgdGhlIGFwcHJvcHJpYXRlIHByZWZpeCBmb3IgYSBDU1MgcHJvcGVydHkuXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvNTIzNjkyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBwcmVmaXgocHJvcCkge1xuICBwcm9wID0gaHlwaGVuYXRlKHByb3ApO1xuICB2YXIgY2FtZWwgPSBjYW1lbGl6ZShwcm9wKTtcbiAgdmFyIHVwcGVyID0gY2FtZWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1lbC5zbGljZSgxKTtcbiAgaWYgKCF0ZXN0RWwpIHtcbiAgICB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgfVxuICB2YXIgaSA9IHByZWZpeGVzLmxlbmd0aDtcbiAgdmFyIHByZWZpeGVkO1xuICBpZiAoY2FtZWwgIT09ICdmaWx0ZXInICYmIGNhbWVsIGluIHRlc3RFbC5zdHlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBrZWJhYjogcHJvcCxcbiAgICAgIGNhbWVsOiBjYW1lbFxuICAgIH07XG4gIH1cbiAgd2hpbGUgKGktLSkge1xuICAgIHByZWZpeGVkID0gY2FtZWxQcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtlYmFiOiBwcmVmaXhlc1tpXSArIHByb3AsXG4gICAgICAgIGNhbWVsOiBwcmVmaXhlZFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuLy8geGxpbmtcbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xudmFyIHhsaW5rUkUgPSAvXnhsaW5rOi87XG5cbi8vIGNoZWNrIGZvciBhdHRyaWJ1dGVzIHRoYXQgcHJvaGliaXQgaW50ZXJwb2xhdGlvbnNcbnZhciBkaXNhbGxvd2VkSW50ZXJwQXR0clJFID0gL152LXxeOnxeQHxeKD86aXN8dHJhbnNpdGlvbnx0cmFuc2l0aW9uLW1vZGV8ZGVib3VuY2V8dHJhY2stYnl8c3RhZ2dlcnxlbnRlci1zdGFnZ2VyfGxlYXZlLXN0YWdnZXIpJC87XG4vLyB0aGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBhbHNvIHNldCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXNcbi8vIGJlY2F1c2UgdGhleSBvbmx5IGFmZmVjdCB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgZWxlbWVudFxudmFyIGF0dHJXaXRoUHJvcHNSRSA9IC9eKD86dmFsdWV8Y2hlY2tlZHxzZWxlY3RlZHxtdXRlZCkkLztcbi8vIHRoZXNlIGF0dHJpYnV0ZXMgZXhwZWN0IGVudW1yYXRlZCB2YWx1ZXMgb2YgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiXG4vLyBidXQgYXJlIG5vdCBib29sZWFuIGF0dHJpYnV0ZXNcbnZhciBlbnVtZXJhdGVkQXR0clJFID0gL14oPzpkcmFnZ2FibGV8Y29udGVudGVkaXRhYmxlfHNwZWxsY2hlY2spJC87XG5cbi8vIHRoZXNlIGF0dHJpYnV0ZXMgc2hvdWxkIHNldCBhIGhpZGRlbiBwcm9wZXJ0eSBmb3Jcbi8vIGJpbmRpbmcgdi1tb2RlbCB0byBvYmplY3QgdmFsdWVzXG52YXIgbW9kZWxQcm9wcyA9IHtcbiAgdmFsdWU6ICdfdmFsdWUnLFxuICAndHJ1ZS12YWx1ZSc6ICdfdHJ1ZVZhbHVlJyxcbiAgJ2ZhbHNlLXZhbHVlJzogJ19mYWxzZVZhbHVlJ1xufTtcblxudmFyIGJpbmQkMSA9IHtcblxuICBwcmlvcml0eTogQklORCxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBhdHRyID0gdGhpcy5hcmc7XG4gICAgdmFyIHRhZyA9IHRoaXMuZWwudGFnTmFtZTtcbiAgICAvLyBzaG91bGQgYmUgZGVlcCB3YXRjaCBvbiBvYmplY3QgbW9kZVxuICAgIGlmICghYXR0cikge1xuICAgICAgdGhpcy5kZWVwID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIGludGVycG9sYXRpb24gYmluZGluZ3NcbiAgICB2YXIgZGVzY3JpcHRvciA9IHRoaXMuZGVzY3JpcHRvcjtcbiAgICB2YXIgdG9rZW5zID0gZGVzY3JpcHRvci5pbnRlcnA7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgLy8gaGFuZGxlIGludGVycG9sYXRpb25zIHdpdGggb25lLXRpbWUgdG9rZW5zXG4gICAgICBpZiAoZGVzY3JpcHRvci5oYXNPbmVUaW1lKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHRva2Vuc1RvRXhwKHRva2VucywgdGhpcy5fc2NvcGUgfHwgdGhpcy52bSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgYWxsb3cgYmluZGluZyBvbiBuYXRpdmUgYXR0cmlidXRlc1xuICAgICAgaWYgKGRpc2FsbG93ZWRJbnRlcnBBdHRyUkUudGVzdChhdHRyKSB8fCBhdHRyID09PSAnbmFtZScgJiYgKHRhZyA9PT0gJ1BBUlRJQUwnIHx8IHRhZyA9PT0gJ1NMT1QnKSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oYXR0ciArICc9XCInICsgZGVzY3JpcHRvci5yYXcgKyAnXCI6ICcgKyAnYXR0cmlidXRlIGludGVycG9sYXRpb24gaXMgbm90IGFsbG93ZWQgaW4gVnVlLmpzICcgKyAnZGlyZWN0aXZlcyBhbmQgc3BlY2lhbCBhdHRyaWJ1dGVzLicsIHRoaXMudm0pO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmF3ID0gYXR0ciArICc9XCInICsgZGVzY3JpcHRvci5yYXcgKyAnXCI6ICc7XG4gICAgICAgIC8vIHdhcm4gc3JjXG4gICAgICAgIGlmIChhdHRyID09PSAnc3JjJykge1xuICAgICAgICAgIHdhcm4ocmF3ICsgJ2ludGVycG9sYXRpb24gaW4gXCJzcmNcIiBhdHRyaWJ1dGUgd2lsbCBjYXVzZSAnICsgJ2EgNDA0IHJlcXVlc3QuIFVzZSB2LWJpbmQ6c3JjIGluc3RlYWQuJywgdGhpcy52bSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3YXJuIHN0eWxlXG4gICAgICAgIGlmIChhdHRyID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgd2FybihyYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInN0eWxlXCIgYXR0cmlidXRlIHdpbGwgY2F1c2UgJyArICd0aGUgYXR0cmlidXRlIHRvIGJlIGRpc2NhcmRlZCBpbiBJbnRlcm5ldCBFeHBsb3Jlci4gJyArICdVc2Ugdi1iaW5kOnN0eWxlIGluc3RlYWQuJywgdGhpcy52bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhdHRyID0gdGhpcy5hcmc7XG4gICAgaWYgKHRoaXMuYXJnKSB7XG4gICAgICB0aGlzLmhhbmRsZVNpbmdsZShhdHRyLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlIHx8IHt9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gc2hhcmUgb2JqZWN0IGhhbmRsZXIgd2l0aCB2LWJpbmQ6Y2xhc3NcbiAgaGFuZGxlT2JqZWN0OiBzdHlsZS5oYW5kbGVPYmplY3QsXG5cbiAgaGFuZGxlU2luZ2xlOiBmdW5jdGlvbiBoYW5kbGVTaW5nbGUoYXR0ciwgdmFsdWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBpbnRlcnAgPSB0aGlzLmRlc2NyaXB0b3IuaW50ZXJwO1xuICAgIGlmICh0aGlzLm1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgYXR0ciA9IGNhbWVsaXplKGF0dHIpO1xuICAgIH1cbiAgICBpZiAoIWludGVycCAmJiBhdHRyV2l0aFByb3BzUkUudGVzdChhdHRyKSAmJiBhdHRyIGluIGVsKSB7XG4gICAgICB2YXIgYXR0clZhbHVlID0gYXR0ciA9PT0gJ3ZhbHVlJyA/IHZhbHVlID09IG51bGwgLy8gSUU5IHdpbGwgc2V0IGlucHV0LnZhbHVlIHRvIFwibnVsbFwiIGZvciBudWxsLi4uXG4gICAgICA/ICcnIDogdmFsdWUgOiB2YWx1ZTtcblxuICAgICAgaWYgKGVsW2F0dHJdICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgZWxbYXR0cl0gPSBhdHRyVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBtb2RlbCBwcm9wc1xuICAgIHZhciBtb2RlbFByb3AgPSBtb2RlbFByb3BzW2F0dHJdO1xuICAgIGlmICghaW50ZXJwICYmIG1vZGVsUHJvcCkge1xuICAgICAgZWxbbW9kZWxQcm9wXSA9IHZhbHVlO1xuICAgICAgLy8gdXBkYXRlIHYtbW9kZWwgaWYgcHJlc2VudFxuICAgICAgdmFyIG1vZGVsID0gZWwuX192X21vZGVsO1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIG1vZGVsLmxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGRvIG5vdCBzZXQgdmFsdWUgYXR0cmlidXRlIGZvciB0ZXh0YXJlYVxuICAgIGlmIChhdHRyID09PSAndmFsdWUnICYmIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZVxuICAgIGlmIChlbnVtZXJhdGVkQXR0clJFLnRlc3QoYXR0cikpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChhdHRyID09PSAnY2xhc3MnKSB7XG4gICAgICAgIC8vIGhhbmRsZSBlZGdlIGNhc2UgIzE5NjA6XG4gICAgICAgIC8vIGNsYXNzIGludGVycG9sYXRpb24gc2hvdWxkIG5vdCBvdmVyd3JpdGUgVnVlIHRyYW5zaXRpb24gY2xhc3NcbiAgICAgICAgaWYgKGVsLl9fdl90cmFucykge1xuICAgICAgICAgIHZhbHVlICs9ICcgJyArIGVsLl9fdl90cmFucy5pZCArICctdHJhbnNpdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q2xhc3MoZWwsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoeGxpbmtSRS50ZXN0KGF0dHIpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGF0dHIsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGVsID0ge1xuXG4gIHByaW9yaXR5OiBFTCxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpcy5hcmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlkID0gdGhpcy5pZCA9IGNhbWVsaXplKHRoaXMuYXJnKTtcbiAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kZWxzO1xuICAgIGlmIChoYXNPd24ocmVmcywgaWQpKSB7XG4gICAgICByZWZzW2lkXSA9IHRoaXMuZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHJlZnMsIGlkLCB0aGlzLmVsKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdmFyIHJlZnMgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJGVscztcbiAgICBpZiAocmVmc1t0aGlzLmlkXSA9PT0gdGhpcy5lbCkge1xuICAgICAgcmVmc1t0aGlzLmlkXSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcmVmID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1yZWY6JyArIHRoaXMuYXJnICsgJyBtdXN0IGJlIHVzZWQgb24gYSBjaGlsZCAnICsgJ2NvbXBvbmVudC4gRm91bmQgb24gPCcgKyB0aGlzLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICc+LicsIHRoaXMudm0pO1xuICB9XG59O1xuXG52YXIgY2xvYWsgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB0aGlzLnZtLiRvbmNlKCdwcmUtaG9vazpjb21waWxlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndi1jbG9haycpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBtdXN0IGV4cG9ydCBwbGFpbiBvYmplY3RcbnZhciBkaXJlY3RpdmVzID0ge1xuICB0ZXh0OiB0ZXh0JDEsXG4gIGh0bWw6IGh0bWwsXG4gICdmb3InOiB2Rm9yLFxuICAnaWYnOiB2SWYsXG4gIHNob3c6IHNob3csXG4gIG1vZGVsOiBtb2RlbCxcbiAgb246IG9uJDEsXG4gIGJpbmQ6IGJpbmQkMSxcbiAgZWw6IGVsLFxuICByZWY6IHJlZixcbiAgY2xvYWs6IGNsb2FrXG59O1xuXG52YXIgdkNsYXNzID0ge1xuXG4gIGRlZXA6IHRydWUsXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuc2V0Q2xhc3ModmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrLykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENsYXNzKG5vcm1hbGl6ZSQxKHZhbHVlKSk7XG4gICAgfVxuICB9LFxuXG4gIHNldENsYXNzOiBmdW5jdGlvbiBzZXRDbGFzcyh2YWx1ZSkge1xuICAgIHRoaXMuY2xlYW51cCh2YWx1ZSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB2YWwgPSB2YWx1ZVtpXTtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgYXBwbHkodGhpcy5lbCwgdmFsLCBhZGRDbGFzcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJldktleXMgPSB2YWx1ZTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiBjbGVhbnVwKHZhbHVlKSB7XG4gICAgdmFyIHByZXZLZXlzID0gdGhpcy5wcmV2S2V5cztcbiAgICBpZiAoIXByZXZLZXlzKSByZXR1cm47XG4gICAgdmFyIGkgPSBwcmV2S2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGtleSA9IHByZXZLZXlzW2ldO1xuICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgIGFwcGx5KHRoaXMuZWwsIGtleSwgcmVtb3ZlQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzIChwb3RlbnRpYWxseSBjb250YWluaW5nIG9iamVjdHMpXG4gKiBpbnRvIGFycmF5IG9mIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXk8U3RyaW5nfE9iamVjdD59IHZhbHVlXG4gKiBAcmV0dXJuIHtBcnJheTxTdHJpbmc+fVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSQxKHZhbHVlKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBfa2V5ID0gdmFsdWVbaV07XG4gICAgICBpZiAoX2tleSkge1xuICAgICAgICBpZiAodHlwZW9mIF9rZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmVzLnB1c2goX2tleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgayBpbiBfa2V5KSB7XG4gICAgICAgICAgICBpZiAoX2tleVtrXSkgcmVzLnB1c2goayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW2tleV0pIHJlcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBhIGNsYXNzL2NsYXNzZXMgb24gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGNsYXNzIG5hbWUuIFRoaXMgbWF5IG9yIG1heSBub3RcbiAqICAgICAgICAgICAgICAgICAgICAgY29udGFpbiBhIHNwYWNlIGNoYXJhY3RlciwgaW4gc3VjaCBhXG4gKiAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2UnbGwgZGVhbCB3aXRoIG11bHRpcGxlIGNsYXNzXG4gKiAgICAgICAgICAgICAgICAgICAgIG5hbWVzIGF0IG9uY2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbmZ1bmN0aW9uIGFwcGx5KGVsLCBrZXksIGZuKSB7XG4gIGtleSA9IGtleS50cmltKCk7XG4gIGlmIChrZXkuaW5kZXhPZignICcpID09PSAtMSkge1xuICAgIGZuKGVsLCBrZXkpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBUaGUga2V5IGNvbnRhaW5zIG9uZSBvciBtb3JlIHNwYWNlIGNoYXJhY3RlcnMuXG4gIC8vIFNpbmNlIGEgY2xhc3MgbmFtZSBkb2Vzbid0IGFjY2VwdCBzdWNoIGNoYXJhY3RlcnMsIHdlXG4gIC8vIHRyZWF0IGl0IGFzIG11bHRpcGxlIGNsYXNzZXMuXG4gIHZhciBrZXlzID0ga2V5LnNwbGl0KC9cXHMrLyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmbihlbCwga2V5c1tpXSk7XG4gIH1cbn1cblxudmFyIGNvbXBvbmVudCA9IHtcblxuICBwcmlvcml0eTogQ09NUE9ORU5ULFxuXG4gIHBhcmFtczogWydrZWVwLWFsaXZlJywgJ3RyYW5zaXRpb24tbW9kZScsICdpbmxpbmUtdGVtcGxhdGUnXSxcblxuICAvKipcbiAgICogU2V0dXAuIFR3byBwb3NzaWJsZSB1c2FnZXM6XG4gICAqXG4gICAqIC0gc3RhdGljOlxuICAgKiAgIDxjb21wPiBvciA8ZGl2IHYtY29tcG9uZW50PVwiY29tcFwiPlxuICAgKlxuICAgKiAtIGR5bmFtaWM6XG4gICAqICAgPGNvbXBvbmVudCA6aXM9XCJ2aWV3XCI+XG4gICAqL1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgaWYgKCF0aGlzLmVsLl9fdnVlX18pIHtcbiAgICAgIC8vIGtlZXAtYWxpdmUgY2FjaGVcbiAgICAgIHRoaXMua2VlcEFsaXZlID0gdGhpcy5wYXJhbXMua2VlcEFsaXZlO1xuICAgICAgaWYgKHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZVxuICAgICAgaWYgKHRoaXMucGFyYW1zLmlubGluZVRlbXBsYXRlKSB7XG4gICAgICAgIC8vIGV4dHJhY3QgaW5saW5lIHRlbXBsYXRlIGFzIGEgRG9jdW1lbnRGcmFnbWVudFxuICAgICAgICB0aGlzLmlubGluZVRlbXBsYXRlID0gZXh0cmFjdENvbnRlbnQodGhpcy5lbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICAvLyBjb21wb25lbnQgcmVzb2x1dGlvbiByZWxhdGVkIHN0YXRlXG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9IHRoaXMuQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIC8vIHRyYW5zaXRpb24gcmVsYXRlZCBzdGF0ZVxuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHMgPSAwO1xuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbENiID0gbnVsbDtcbiAgICAgIC8vIGNyZWF0ZSBhIHJlZiBhbmNob3JcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWNvbXBvbmVudCcpO1xuICAgICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gICAgICAvLyByZW1vdmUgaXMgYXR0cmlidXRlLlxuICAgICAgLy8gdGhpcyBpcyByZW1vdmVkIGR1cmluZyBjb21waWxhdGlvbiwgYnV0IGJlY2F1c2UgY29tcGlsYXRpb24gaXNcbiAgICAgIC8vIGNhY2hlZCwgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVzZWQgZWxzZXdoZXJlIHRoaXMgYXR0cmlidXRlXG4gICAgICAvLyB3aWxsIHJlbWFpbiBhdCBsaW5rIHRpbWUuXG4gICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnaXMnKTtcbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCc6aXMnKTtcbiAgICAgIC8vIHJlbW92ZSByZWYsIHNhbWUgYXMgYWJvdmVcbiAgICAgIGlmICh0aGlzLmRlc2NyaXB0b3IucmVmKSB7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCd2LXJlZjonICsgaHlwaGVuYXRlKHRoaXMuZGVzY3JpcHRvci5yZWYpKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0YXRpYywgYnVpbGQgcmlnaHQgbm93LlxuICAgICAgaWYgKHRoaXMubGl0ZXJhbCkge1xuICAgICAgICB0aGlzLnNldENvbXBvbmVudCh0aGlzLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ2Nhbm5vdCBtb3VudCBjb21wb25lbnQgXCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiICcgKyAnb24gYWxyZWFkeSBtb3VudGVkIGVsZW1lbnQ6ICcgKyB0aGlzLmVsKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFB1YmxpYyB1cGRhdGUsIGNhbGxlZCBieSB0aGUgd2F0Y2hlciBpbiB0aGUgZHluYW1pY1xuICAgKiBsaXRlcmFsIHNjZW5hcmlvLCBlLmcuIDxjb21wb25lbnQgOmlzPVwidmlld1wiPlxuICAgKi9cblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghdGhpcy5saXRlcmFsKSB7XG4gICAgICB0aGlzLnNldENvbXBvbmVudCh2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTd2l0Y2ggZHluYW1pYyBjb21wb25lbnRzLiBNYXkgcmVzb2x2ZSB0aGUgY29tcG9uZW50XG4gICAqIGFzeW5jaHJvbm91c2x5LCBhbmQgcGVyZm9ybSB0cmFuc2l0aW9uIGJhc2VkIG9uXG4gICAqIHNwZWNpZmllZCB0cmFuc2l0aW9uIG1vZGUuIEFjY2VwdHMgYSBmZXcgYWRkaXRpb25hbFxuICAgKiBhcmd1bWVudHMgc3BlY2lmaWNhbGx5IGZvciB2dWUtcm91dGVyLlxuICAgKlxuICAgKiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIGZ1bGwgdHJhbnNpdGlvbiBpc1xuICAgKiBmaW5pc2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiBzZXRDb21wb25lbnQodmFsdWUsIGNiKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlUGVuZGluZygpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIC8vIGp1c3QgcmVtb3ZlIGN1cnJlbnRcbiAgICAgIHRoaXMudW5idWlsZCh0cnVlKTtcbiAgICAgIHRoaXMucmVtb3ZlKHRoaXMuY2hpbGRWTSwgY2IpO1xuICAgICAgdGhpcy5jaGlsZFZNID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5yZXNvbHZlQ29tcG9uZW50KHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYubW91bnRDb21wb25lbnQoY2IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IgdG8gdXNlIHdoZW4gY3JlYXRpbmdcbiAgICogdGhlIGNoaWxkIHZtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gdmFsdWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgcmVzb2x2ZUNvbXBvbmVudDogZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudCh2YWx1ZSwgY2IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gICAgICBzZWxmLkNvbXBvbmVudE5hbWUgPSBDb21wb25lbnQub3B0aW9ucy5uYW1lIHx8ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBudWxsKTtcbiAgICAgIHNlbGYuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgICAgY2IoKTtcbiAgICB9KTtcbiAgICB0aGlzLnZtLl9yZXNvbHZlQ29tcG9uZW50KHZhbHVlLCB0aGlzLnBlbmRpbmdDb21wb25lbnRDYik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSB1c2luZyB0aGUgY3VycmVudCBjb25zdHJ1Y3RvciBhbmRcbiAgICogcmVwbGFjZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuIFRoaXMgbWV0aG9kIGRvZXNuJ3QgY2FyZVxuICAgKiB3aGV0aGVyIHRoZSBuZXcgY29tcG9uZW50IGFuZCB0aGUgb2xkIG9uZSBhcmUgYWN0dWFsbHlcbiAgICogdGhlIHNhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIG1vdW50Q29tcG9uZW50KGNiKSB7XG4gICAgLy8gYWN0dWFsIG1vdW50XG4gICAgdGhpcy51bmJ1aWxkKHRydWUpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWN0aXZhdGVIb29rcyA9IHRoaXMuQ29tcG9uZW50Lm9wdGlvbnMuYWN0aXZhdGU7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGVkKCk7XG4gICAgdmFyIG5ld0NvbXBvbmVudCA9IHRoaXMuYnVpbGQoKTtcbiAgICBpZiAoYWN0aXZhdGVIb29rcyAmJiAhY2FjaGVkKSB7XG4gICAgICB0aGlzLndhaXRpbmdGb3IgPSBuZXdDb21wb25lbnQ7XG4gICAgICBjYWxsQWN0aXZhdGVIb29rcyhhY3RpdmF0ZUhvb2tzLCBuZXdDb21wb25lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYud2FpdGluZ0ZvciAhPT0gbmV3Q29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYud2FpdGluZ0ZvciA9IG51bGw7XG4gICAgICAgIHNlbGYudHJhbnNpdGlvbihuZXdDb21wb25lbnQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGUgcmVmIGZvciBrZXB0LWFsaXZlIGNvbXBvbmVudFxuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICBuZXdDb21wb25lbnQuX3VwZGF0ZVJlZigpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2l0aW9uKG5ld0NvbXBvbmVudCwgY2IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogV2hlbiB0aGUgY29tcG9uZW50IGNoYW5nZXMgb3IgdW5iaW5kcyBiZWZvcmUgYW4gYXN5bmNcbiAgICogY29uc3RydWN0b3IgaXMgcmVzb2x2ZWQsIHdlIG5lZWQgdG8gaW52YWxpZGF0ZSBpdHNcbiAgICogcGVuZGluZyBjYWxsYmFjay5cbiAgICovXG5cbiAgaW52YWxpZGF0ZVBlbmRpbmc6IGZ1bmN0aW9uIGludmFsaWRhdGVQZW5kaW5nKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdDb21wb25lbnRDYikge1xuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IuY2FuY2VsKCk7XG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZS9pbnNlcnQgYSBuZXcgY2hpbGQgdm0uXG4gICAqIElmIGtlZXAgYWxpdmUgYW5kIGhhcyBjYWNoZWQgaW5zdGFuY2UsIGluc2VydCB0aGF0XG4gICAqIGluc3RhbmNlOyBvdGhlcndpc2UgYnVpbGQgYSBuZXcgb25lIGFuZCBjYWNoZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRyYU9wdGlvbnNdXG4gICAqIEByZXR1cm4ge1Z1ZX0gLSB0aGUgY3JlYXRlZCBpbnN0YW5jZVxuICAgKi9cblxuICBidWlsZDogZnVuY3Rpb24gYnVpbGQoZXh0cmFPcHRpb25zKSB7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGVkKCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuQ29tcG9uZW50KSB7XG4gICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBuYW1lOiB0aGlzLkNvbXBvbmVudE5hbWUsXG4gICAgICAgIGVsOiBjbG9uZU5vZGUodGhpcy5lbCksXG4gICAgICAgIHRlbXBsYXRlOiB0aGlzLmlubGluZVRlbXBsYXRlLFxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gYWRkIHRoZSBjaGlsZCB3aXRoIGNvcnJlY3QgcGFyZW50XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGl0cyBwYXJlbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIHRoZSB0cmFuc2NsdXNpb24gaG9zdC5cbiAgICAgICAgcGFyZW50OiB0aGlzLl9ob3N0IHx8IHRoaXMudm0sXG4gICAgICAgIC8vIGlmIG5vIGlubGluZS10ZW1wbGF0ZSwgdGhlbiB0aGUgY29tcGlsZWRcbiAgICAgICAgLy8gbGlua2VyIGNhbiBiZSBjYWNoZWQgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICAgICAgX2xpbmtlckNhY2hhYmxlOiAhdGhpcy5pbmxpbmVUZW1wbGF0ZSxcbiAgICAgICAgX3JlZjogdGhpcy5kZXNjcmlwdG9yLnJlZixcbiAgICAgICAgX2FzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgICBfaXNSb3V0ZXJWaWV3OiB0aGlzLl9pc1JvdXRlclZpZXcsXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGNvbnRleHRcbiAgICAgICAgLy8gd2lsbCBiZSB0aGUgY29tbW9uIHBhcmVudCB2bSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICAgIC8vIGFuZCBpdHMgaG9zdC5cbiAgICAgICAgX2NvbnRleHQ6IHRoaXMudm0sXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgaW5zaWRlIGFuIGlubGluZSB2LWZvciwgdGhlIHNjb3BlXG4gICAgICAgIC8vIHdpbGwgYmUgdGhlIGludGVybWVkaWF0ZSBzY29wZSBjcmVhdGVkIGZvciB0aGlzXG4gICAgICAgIC8vIHJlcGVhdCBmcmFnbWVudC4gdGhpcyBpcyB1c2VkIGZvciBsaW5raW5nIHByb3BzXG4gICAgICAgIC8vIGFuZCBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICAgICAgX3Njb3BlOiB0aGlzLl9zY29wZSxcbiAgICAgICAgLy8gcGFzcyBpbiB0aGUgb3duZXIgZnJhZ21lbnQgb2YgdGhpcyBjb21wb25lbnQuXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IHNvIHRoYXQgdGhlIGZyYWdtZW50IGNhbiBrZWVwXG4gICAgICAgIC8vIHRyYWNrIG9mIGl0cyBjb250YWluZWQgY29tcG9uZW50cyBpbiBvcmRlciB0b1xuICAgICAgICAvLyBjYWxsIGF0dGFjaC9kZXRhY2ggaG9va3MgZm9yIHRoZW0uXG4gICAgICAgIF9mcmFnOiB0aGlzLl9mcmFnXG4gICAgICB9O1xuICAgICAgLy8gZXh0cmEgb3B0aW9uc1xuICAgICAgLy8gaW4gMS4wLjAgdGhpcyBpcyB1c2VkIGJ5IHZ1ZS1yb3V0ZXIgb25seVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChvcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuQ29tcG9uZW50KG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVbdGhpcy5Db21wb25lbnQuY2lkXSA9IGNoaWxkO1xuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsLmhhc0F0dHJpYnV0ZSgndHJhbnNpdGlvbicpICYmIGNoaWxkLl9pc0ZyYWdtZW50KSB7XG4gICAgICAgIHdhcm4oJ1RyYW5zaXRpb25zIHdpbGwgbm90IHdvcmsgb24gYSBmcmFnbWVudCBpbnN0YW5jZS4gJyArICdUZW1wbGF0ZTogJyArIGNoaWxkLiRvcHRpb25zLnRlbXBsYXRlLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcnkgdG8gZ2V0IGEgY2FjaGVkIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybiB7VnVlfHVuZGVmaW5lZH1cbiAgICovXG5cbiAgZ2V0Q2FjaGVkOiBmdW5jdGlvbiBnZXRDYWNoZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMua2VlcEFsaXZlICYmIHRoaXMuY2FjaGVbdGhpcy5Db21wb25lbnQuY2lkXTtcbiAgfSxcblxuICAvKipcbiAgICogVGVhcmRvd24gdGhlIGN1cnJlbnQgY2hpbGQsIGJ1dCBkZWZlcnMgY2xlYW51cCBzb1xuICAgKiB0aGF0IHdlIGNhbiBzZXBhcmF0ZSB0aGUgZGVzdHJveSBhbmQgcmVtb3ZhbCBzdGVwcy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBkZWZlclxuICAgKi9cblxuICB1bmJ1aWxkOiBmdW5jdGlvbiB1bmJ1aWxkKGRlZmVyKSB7XG4gICAgaWYgKHRoaXMud2FpdGluZ0Zvcikge1xuICAgICAgaWYgKCF0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLndhaXRpbmdGb3IuJGRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FpdGluZ0ZvciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRWTTtcbiAgICBpZiAoIWNoaWxkIHx8IHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHJlZlxuICAgICAgICBjaGlsZC5faW5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBjaGlsZC5fdXBkYXRlUmVmKHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB0aGUgc29sZSBwdXJwb3NlIG9mIGBkZWZlckNsZWFudXBgIGlzIHNvIHRoYXQgd2UgY2FuXG4gICAgLy8gXCJkZWFjdGl2YXRlXCIgdGhlIHZtIHJpZ2h0IG5vdyBhbmQgcGVyZm9ybSBET00gcmVtb3ZhbFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLiRkZXN0cm95KGZhbHNlLCBkZWZlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjdXJyZW50IGRlc3Ryb3llZCBjaGlsZCBhbmQgbWFudWFsbHkgZG9cbiAgICogdGhlIGNsZWFudXAgYWZ0ZXIgcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY2hpbGQsIGNiKSB7XG4gICAgdmFyIGtlZXBBbGl2ZSA9IHRoaXMua2VlcEFsaXZlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgLy8gd2UgbWF5IGhhdmUgYSBjb21wb25lbnQgc3dpdGNoIHdoZW4gYSBwcmV2aW91c1xuICAgICAgLy8gY29tcG9uZW50IGlzIHN0aWxsIGJlaW5nIHRyYW5zaXRpb25lZCBvdXQuXG4gICAgICAvLyB3ZSB3YW50IHRvIHRyaWdnZXIgb25seSBvbmUgbGFzdGVzdCBpbnNlcnRpb24gY2JcbiAgICAgIC8vIHdoZW4gdGhlIGV4aXN0aW5nIHRyYW5zaXRpb24gZmluaXNoZXMuICgjMTExOSlcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzKys7XG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBjYjtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGNoaWxkLiRyZW1vdmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFscy0tO1xuICAgICAgICBpZiAoIWtlZXBBbGl2ZSkgY2hpbGQuX2NsZWFudXAoKTtcbiAgICAgICAgaWYgKCFzZWxmLnBlbmRpbmdSZW1vdmFscyAmJiBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IpIHtcbiAgICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IoKTtcbiAgICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWN0dWFsbHkgc3dhcCB0aGUgY29tcG9uZW50cywgZGVwZW5kaW5nIG9uIHRoZVxuICAgKiB0cmFuc2l0aW9uIG1vZGUuIERlZmF1bHRzIHRvIHNpbXVsdGFuZW91cy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHRyYW5zaXRpb246IGZ1bmN0aW9uIHRyYW5zaXRpb24odGFyZ2V0LCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hpbGRWTTtcbiAgICAvLyBmb3IgZGV2dG9vbCBpbnNwZWN0aW9uXG4gICAgaWYgKGN1cnJlbnQpIGN1cnJlbnQuX2luYWN0aXZlID0gdHJ1ZTtcbiAgICB0YXJnZXQuX2luYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jaGlsZFZNID0gdGFyZ2V0O1xuICAgIHN3aXRjaCAoc2VsZi5wYXJhbXMudHJhbnNpdGlvbk1vZGUpIHtcbiAgICAgIGNhc2UgJ2luLW91dCc6XG4gICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5yZW1vdmUoY3VycmVudCwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvdXQtaW4nOlxuICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LiRiZWZvcmUoc2VsZi5hbmNob3IsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2VsZi5yZW1vdmUoY3VycmVudCk7XG4gICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBjYik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbmJpbmQuXG4gICAqL1xuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKTtcbiAgICAvLyBEbyBub3QgZGVmZXIgY2xlYW51cCB3aGVuIHVuYmluZGluZ1xuICAgIHRoaXMudW5idWlsZCgpO1xuICAgIC8vIGRlc3Ryb3kgYWxsIGtlZXAtYWxpdmUgY2FjaGVkIGluc3RhbmNlc1xuICAgIGlmICh0aGlzLmNhY2hlKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0uJGRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUgPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGFjdGl2YXRlIGhvb2tzIGluIG9yZGVyIChhc3luY2hyb25vdXMpXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaG9va3NcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVIb29rcyhob29rcywgdm0sIGNiKSB7XG4gIHZhciB0b3RhbCA9IGhvb2tzLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIGhvb2tzWzBdLmNhbGwodm0sIG5leHQpO1xuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmICgrK2NhbGxlZCA+PSB0b3RhbCkge1xuICAgICAgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va3NbY2FsbGVkXS5jYWxsKHZtLCBuZXh0KTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BCaW5kaW5nTW9kZXMgPSBjb25maWcuX3Byb3BCaW5kaW5nTW9kZXM7XG52YXIgZW1wdHkgPSB7fTtcblxuLy8gcmVnZXhlc1xudmFyIGlkZW50UkUkMSA9IC9eWyRfYS16QS1aXStbXFx3JF0qJC87XG52YXIgc2V0dGFibGVQYXRoUkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKFxcLltBLVphLXpfJF1bXFx3JF0qfFxcW1teXFxbXFxdXStcXF0pKiQvO1xuXG4vKipcbiAqIENvbXBpbGUgcHJvcHMgb24gYSByb290IGVsZW1lbnQgYW5kIHJldHVyblxuICogYSBwcm9wcyBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtBcnJheX0gcHJvcE9wdGlvbnNcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHJldHVybiB7RnVuY3Rpb259IHByb3BzTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVByb3BzKGVsLCBwcm9wT3B0aW9ucywgdm0pIHtcbiAgdmFyIHByb3BzID0gW107XG4gIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHByb3BPcHRpb25zKTtcbiAgdmFyIGkgPSBuYW1lcy5sZW5ndGg7XG4gIHZhciBvcHRpb25zLCBuYW1lLCBhdHRyLCB2YWx1ZSwgcGF0aCwgcGFyc2VkLCBwcm9wO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgIG9wdGlvbnMgPSBwcm9wT3B0aW9uc1tuYW1lXSB8fCBlbXB0eTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICckZGF0YScpIHtcbiAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgJGRhdGEgYXMgcHJvcC4nLCB2bSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBwcm9wcyBjb3VsZCBjb250YWluIGRhc2hlcywgd2hpY2ggd2lsbCBiZVxuICAgIC8vIGludGVycHJldGVkIGFzIG1pbnVzIGNhbGN1bGF0aW9ucyBieSB0aGUgcGFyc2VyXG4gICAgLy8gc28gd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUgcGF0aCBoZXJlXG4gICAgcGF0aCA9IGNhbWVsaXplKG5hbWUpO1xuICAgIGlmICghaWRlbnRSRSQxLnRlc3QocGF0aCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBwcm9wIGtleTogXCInICsgbmFtZSArICdcIi4gUHJvcCBrZXlzICcgKyAnbXVzdCBiZSB2YWxpZCBpZGVudGlmaWVycy4nLCB2bSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwcm9wID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgbW9kZTogcHJvcEJpbmRpbmdNb2Rlcy5PTkVfV0FZLFxuICAgICAgcmF3OiBudWxsXG4gICAgfTtcblxuICAgIGF0dHIgPSBoeXBoZW5hdGUobmFtZSk7XG4gICAgLy8gZmlyc3QgY2hlY2sgZHluYW1pYyB2ZXJzaW9uXG4gICAgaWYgKCh2YWx1ZSA9IGdldEJpbmRBdHRyKGVsLCBhdHRyKSkgPT09IG51bGwpIHtcbiAgICAgIGlmICgodmFsdWUgPSBnZXRCaW5kQXR0cihlbCwgYXR0ciArICcuc3luYycpKSAhPT0gbnVsbCkge1xuICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVk7XG4gICAgICB9IGVsc2UgaWYgKCh2YWx1ZSA9IGdldEJpbmRBdHRyKGVsLCBhdHRyICsgJy5vbmNlJykpICE9PSBudWxsKSB7XG4gICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuT05FX1RJTUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gaGFzIGR5bmFtaWMgYmluZGluZyFcbiAgICAgIHByb3AucmF3ID0gdmFsdWU7XG4gICAgICBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZSh2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IHBhcnNlZC5leHByZXNzaW9uO1xuICAgICAgcHJvcC5maWx0ZXJzID0gcGFyc2VkLmZpbHRlcnM7XG4gICAgICAvLyBjaGVjayBiaW5kaW5nIHR5cGVcbiAgICAgIGlmIChpc0xpdGVyYWwodmFsdWUpICYmICFwYXJzZWQuZmlsdGVycykge1xuICAgICAgICAvLyBmb3IgZXhwcmVzc2lvbnMgY29udGFpbmluZyBsaXRlcmFsIG51bWJlcnMgYW5kXG4gICAgICAgIC8vIGJvb2xlYW5zLCB0aGVyZSdzIG5vIG5lZWQgdG8gc2V0dXAgYSBwcm9wIGJpbmRpbmcsXG4gICAgICAgIC8vIHNvIHdlIGNhbiBvcHRpbWl6ZSB0aGVtIGFzIGEgb25lLXRpbWUgc2V0LlxuICAgICAgICBwcm9wLm9wdGltaXplZExpdGVyYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5keW5hbWljID0gdHJ1ZTtcbiAgICAgICAgLy8gY2hlY2sgbm9uLXNldHRhYmxlIHBhdGggZm9yIHR3by13YXkgYmluZGluZ3NcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgcHJvcC5tb2RlID09PSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVkgJiYgIXNldHRhYmxlUGF0aFJFLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5PTkVfV0FZO1xuICAgICAgICAgIHdhcm4oJ0Nhbm5vdCBiaW5kIHR3by13YXkgcHJvcCB3aXRoIG5vbi1zZXR0YWJsZSAnICsgJ3BhcmVudCBwYXRoOiAnICsgdmFsdWUsIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcC5wYXJlbnRQYXRoID0gdmFsdWU7XG5cbiAgICAgIC8vIHdhcm4gcmVxdWlyZWQgdHdvLXdheVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy50d29XYXkgJiYgcHJvcC5tb2RlICE9PSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVkpIHtcbiAgICAgICAgd2FybignUHJvcCBcIicgKyBuYW1lICsgJ1wiIGV4cGVjdHMgYSB0d28td2F5IGJpbmRpbmcgdHlwZS4nLCB2bSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgodmFsdWUgPSBnZXRBdHRyKGVsLCBhdHRyKSkgIT09IG51bGwpIHtcbiAgICAgIC8vIGhhcyBsaXRlcmFsIGJpbmRpbmchXG4gICAgICBwcm9wLnJhdyA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gY2hlY2sgcG9zc2libGUgY2FtZWxDYXNlIHByb3AgdXNhZ2VcbiAgICAgIHZhciBsb3dlckNhc2VOYW1lID0gcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSAvW0EtWlxcLV0vLnRlc3QobmFtZSkgJiYgKGVsLmdldEF0dHJpYnV0ZShsb3dlckNhc2VOYW1lKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJzonICsgbG93ZXJDYXNlTmFtZSkgfHwgZWwuZ2V0QXR0cmlidXRlKCd2LWJpbmQ6JyArIGxvd2VyQ2FzZU5hbWUpIHx8IGVsLmdldEF0dHJpYnV0ZSgnOicgKyBsb3dlckNhc2VOYW1lICsgJy5vbmNlJykgfHwgZWwuZ2V0QXR0cmlidXRlKCd2LWJpbmQ6JyArIGxvd2VyQ2FzZU5hbWUgKyAnLm9uY2UnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJzonICsgbG93ZXJDYXNlTmFtZSArICcuc3luYycpIHx8IGVsLmdldEF0dHJpYnV0ZSgndi1iaW5kOicgKyBsb3dlckNhc2VOYW1lICsgJy5zeW5jJykpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm4oJ1Bvc3NpYmxlIHVzYWdlIGVycm9yIGZvciBwcm9wIGAnICsgbG93ZXJDYXNlTmFtZSArICdgIC0gJyArICdkaWQgeW91IG1lYW4gYCcgKyBhdHRyICsgJ2A/IEhUTUwgaXMgY2FzZS1pbnNlbnNpdGl2ZSwgcmVtZW1iZXIgdG8gdXNlICcgKyAna2ViYWItY2FzZSBmb3IgcHJvcHMgaW4gdGVtcGxhdGVzLicsIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlZCkge1xuICAgICAgICAvLyB3YXJuIG1pc3NpbmcgcmVxdWlyZWRcbiAgICAgICAgd2FybignTWlzc2luZyByZXF1aXJlZCBwcm9wOiAnICsgbmFtZSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwdXNoIHByb3BcbiAgICBwcm9wcy5wdXNoKHByb3ApO1xuICB9XG4gIHJldHVybiBtYWtlUHJvcHNMaW5rRm4ocHJvcHMpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIHByb3BzIHRvIGEgdm0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBwcm9wc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VQcm9wc0xpbmtGbihwcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gcHJvcHNMaW5rRm4odm0sIHNjb3BlKSB7XG4gICAgLy8gc3RvcmUgcmVzb2x2ZWQgcHJvcHMgaW5mb1xuICAgIHZtLl9wcm9wcyA9IHt9O1xuICAgIHZhciBpbmxpbmVQcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzRGF0YTtcbiAgICB2YXIgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB2YXIgcHJvcCwgcGF0aCwgb3B0aW9ucywgdmFsdWUsIHJhdztcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBwcm9wID0gcHJvcHNbaV07XG4gICAgICByYXcgPSBwcm9wLnJhdztcbiAgICAgIHBhdGggPSBwcm9wLnBhdGg7XG4gICAgICBvcHRpb25zID0gcHJvcC5vcHRpb25zO1xuICAgICAgdm0uX3Byb3BzW3BhdGhdID0gcHJvcDtcbiAgICAgIGlmIChpbmxpbmVQcm9wcyAmJiBoYXNPd24oaW5saW5lUHJvcHMsIHBhdGgpKSB7XG4gICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCBpbmxpbmVQcm9wc1twYXRoXSk7XG4gICAgICB9aWYgKHJhdyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBpbml0aWFsaXplIGFic2VudCBwcm9wXG4gICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wLmR5bmFtaWMpIHtcbiAgICAgICAgLy8gZHluYW1pYyBwcm9wXG4gICAgICAgIGlmIChwcm9wLm1vZGUgPT09IHByb3BCaW5kaW5nTW9kZXMuT05FX1RJTUUpIHtcbiAgICAgICAgICAvLyBvbmUgdGltZSBiaW5kaW5nXG4gICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0uX2NvbnRleHQgfHwgdm0pLiRnZXQocHJvcC5wYXJlbnRQYXRoKTtcbiAgICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2bS5fY29udGV4dCkge1xuICAgICAgICAgICAgLy8gZHluYW1pYyBiaW5kaW5nXG4gICAgICAgICAgICB2bS5fYmluZERpcih7XG4gICAgICAgICAgICAgIG5hbWU6ICdwcm9wJyxcbiAgICAgICAgICAgICAgZGVmOiBwcm9wRGVmLFxuICAgICAgICAgICAgICBwcm9wOiBwcm9wXG4gICAgICAgICAgICB9LCBudWxsLCBudWxsLCBzY29wZSk7IC8vIGVsLCBob3N0LCBzY29wZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2VcbiAgICAgICAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZtLiRnZXQocHJvcC5wYXJlbnRQYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvcC5vcHRpbWl6ZWRMaXRlcmFsKSB7XG4gICAgICAgIC8vIG9wdGltaXplZCBsaXRlcmFsLCBjYXN0IGl0IGFuZCBqdXN0IHNldCBvbmNlXG4gICAgICAgIHZhciBzdHJpcHBlZCA9IHN0cmlwUXVvdGVzKHJhdyk7XG4gICAgICAgIHZhbHVlID0gc3RyaXBwZWQgPT09IHJhdyA/IHRvQm9vbGVhbih0b051bWJlcihyYXcpKSA6IHN0cmlwcGVkO1xuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RyaW5nIGxpdGVyYWwsIGJ1dCB3ZSBuZWVkIHRvIGNhdGVyIGZvclxuICAgICAgICAvLyBCb29sZWFuIHByb3BzIHdpdGggbm8gdmFsdWUsIG9yIHdpdGggc2FtZVxuICAgICAgICAvLyBsaXRlcmFsIHZhbHVlIChlLmcuIGRpc2FibGVkPVwiZGlzYWJsZWRcIilcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtbG9hZGVyL2lzc3Vlcy8xODJcbiAgICAgICAgdmFsdWUgPSBvcHRpb25zLnR5cGUgPT09IEJvb2xlYW4gJiYgKHJhdyA9PT0gJycgfHwgcmF3ID09PSBoeXBoZW5hdGUocHJvcC5uYW1lKSkgPyB0cnVlIDogcmF3O1xuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgcHJvcCB3aXRoIGEgcmF3VmFsdWUsIGFwcGx5aW5nIG5lY2Vzc2FyeSBjb2Vyc2lvbnMsXG4gKiBkZWZhdWx0IHZhbHVlcyAmIGFzc2VydGlvbnMgYW5kIGNhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIHdpdGhcbiAqIHByb2Nlc3NlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHJhd1ZhbHVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbmZ1bmN0aW9uIHByb2Nlc3NQcm9wVmFsdWUodm0sIHByb3AsIHJhd1ZhbHVlLCBmbikge1xuICB2YXIgaXNTaW1wbGUgPSBwcm9wLmR5bmFtaWMgJiYgaXNTaW1wbGVQYXRoKHByb3AucGFyZW50UGF0aCk7XG4gIHZhciB2YWx1ZSA9IHJhd1ZhbHVlO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCk7XG4gIH1cbiAgdmFsdWUgPSBjb2VyY2VQcm9wKHByb3AsIHZhbHVlLCB2bSk7XG4gIHZhciBjb2VyY2VkID0gdmFsdWUgIT09IHJhd1ZhbHVlO1xuICBpZiAoIWFzc2VydFByb3AocHJvcCwgdmFsdWUsIHZtKSkge1xuICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1NpbXBsZSAmJiAhY29lcmNlZCkge1xuICAgIHdpdGhvdXRDb252ZXJzaW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuKHZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmbih2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wJ3MgaW5pdGlhbCB2YWx1ZSBvbiBhIHZtIGFuZCBpdHMgZGF0YSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSkge1xuICBwcm9jZXNzUHJvcFZhbHVlKHZtLCBwcm9wLCB2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sIHByb3AucGF0aCwgdmFsdWUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgYSBwcm9wJ3MgdmFsdWUgb24gYSB2bS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gdXBkYXRlUHJvcCh2bSwgcHJvcCwgdmFsdWUpIHtcbiAgcHJvY2Vzc1Byb3BWYWx1ZSh2bSwgcHJvcCwgdmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZtW3Byb3AucGF0aF0gPSB2YWx1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3ApIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICB2YXIgb3B0aW9ucyA9IHByb3Aub3B0aW9ucztcbiAgaWYgKCFoYXNPd24ob3B0aW9ucywgJ2RlZmF1bHQnKSkge1xuICAgIC8vIGFic2VudCBib29sZWFuIHZhbHVlIGRlZmF1bHRzIHRvIGZhbHNlXG4gICAgcmV0dXJuIG9wdGlvbnMudHlwZSA9PT0gQm9vbGVhbiA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9XG4gIHZhciBkZWYgPSBvcHRpb25zWydkZWZhdWx0J107XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKGlzT2JqZWN0KGRlZikpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBwcm9wLm5hbWUgKyAnXCI6ICcgKyAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJywgdm0pO1xuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMudHlwZSAhPT0gRnVuY3Rpb24gPyBkZWYuY2FsbCh2bSkgOiBkZWY7XG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRQcm9wKHByb3AsIHZhbHVlLCB2bSkge1xuICBpZiAoIXByb3Aub3B0aW9ucy5yZXF1aXJlZCAmJiAoIC8vIG5vbi1yZXF1aXJlZFxuICBwcm9wLnJhdyA9PT0gbnVsbCB8fCAvLyBhYnNjZW50XG4gIHZhbHVlID09IG51bGwpIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB2YXIgb3B0aW9ucyA9IHByb3Aub3B0aW9ucztcbiAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybignSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBwcm9wLm5hbWUgKyAnXCIuJyArICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGZvcm1hdFR5cGUpLmpvaW4oJywgJykgKyAnLCBnb3QgJyArIGZvcm1hdFZhbHVlKHZhbHVlKSArICcuJywgdm0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IG9wdGlvbnMudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgcHJvcC5uYW1lICsgJ1wiLicsIHZtKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRm9yY2UgcGFyc2luZyB2YWx1ZSB3aXRoIGNvZXJjZSBvcHRpb24uXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuZnVuY3Rpb24gY29lcmNlUHJvcChwcm9wLCB2YWx1ZSwgdm0pIHtcbiAgdmFyIGNvZXJjZSA9IHByb3Aub3B0aW9ucy5jb2VyY2U7XG4gIGlmICghY29lcmNlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgY29lcmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNvZXJjZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIGNvZXJjZSBmb3IgcHJvcCBcIicgKyBwcm9wLm5hbWUgKyAnXCI6IGV4cGVjdGVkIGZ1bmN0aW9uLCBnb3QgJyArIHR5cGVvZiBjb2VyY2UgKyAnLicsIHZtKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHR5cGUgb2YgYSB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHR5cGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZTtcbiAgaWYgKHR5cGUgPT09IFN0cmluZykge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdzdHJpbmcnO1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTnVtYmVyKSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ251bWJlcic7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBCb29sZWFuKSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nO1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gRnVuY3Rpb24pIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnZnVuY3Rpb24nO1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gT2JqZWN0KSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ29iamVjdCc7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBBcnJheSkge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdhcnJheSc7XG4gICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9O1xufVxuXG4vKipcbiAqIEZvcm1hdCB0eXBlIGZvciBvdXRwdXRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZSA/IHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnNsaWNlKDEpIDogJ2N1c3RvbSB0eXBlJztcbn1cblxuLyoqXG4gKiBGb3JtYXQgdmFsdWVcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG59XG5cbnZhciBiaW5kaW5nTW9kZXMgPSBjb25maWcuX3Byb3BCaW5kaW5nTW9kZXM7XG5cbnZhciBwcm9wRGVmID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy52bTtcbiAgICB2YXIgcGFyZW50ID0gY2hpbGQuX2NvbnRleHQ7XG4gICAgLy8gcGFzc2VkIGluIGZyb20gY29tcGlsZXIgZGlyZWN0bHlcbiAgICB2YXIgcHJvcCA9IHRoaXMuZGVzY3JpcHRvci5wcm9wO1xuICAgIHZhciBjaGlsZEtleSA9IHByb3AucGF0aDtcbiAgICB2YXIgcGFyZW50S2V5ID0gcHJvcC5wYXJlbnRQYXRoO1xuICAgIHZhciB0d29XYXkgPSBwcm9wLm1vZGUgPT09IGJpbmRpbmdNb2Rlcy5UV09fV0FZO1xuXG4gICAgdmFyIHBhcmVudFdhdGNoZXIgPSB0aGlzLnBhcmVudFdhdGNoZXIgPSBuZXcgV2F0Y2hlcihwYXJlbnQsIHBhcmVudEtleSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdXBkYXRlUHJvcChjaGlsZCwgcHJvcCwgdmFsKTtcbiAgICB9LCB7XG4gICAgICB0d29XYXk6IHR3b1dheSxcbiAgICAgIGZpbHRlcnM6IHByb3AuZmlsdGVycyxcbiAgICAgIC8vIGltcG9ydGFudDogcHJvcHMgbmVlZCB0byBiZSBvYnNlcnZlZCBvbiB0aGVcbiAgICAgIC8vIHYtZm9yIHNjb3BlIGlmIHByZXNlbnRcbiAgICAgIHNjb3BlOiB0aGlzLl9zY29wZVxuICAgIH0pO1xuXG4gICAgLy8gc2V0IHRoZSBjaGlsZCBpbml0aWFsIHZhbHVlLlxuICAgIGluaXRQcm9wKGNoaWxkLCBwcm9wLCBwYXJlbnRXYXRjaGVyLnZhbHVlKTtcblxuICAgIC8vIHNldHVwIHR3by13YXkgYmluZGluZ1xuICAgIGlmICh0d29XYXkpIHtcbiAgICAgIC8vIGltcG9ydGFudDogZGVmZXIgdGhlIGNoaWxkIHdhdGNoZXIgY3JlYXRpb24gdW50aWxcbiAgICAgIC8vIHRoZSBjcmVhdGVkIGhvb2sgKGFmdGVyIGRhdGEgb2JzZXJ2YXRpb24pXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBjaGlsZC4kb25jZSgncHJlLWhvb2s6Y3JlYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5jaGlsZFdhdGNoZXIgPSBuZXcgV2F0Y2hlcihjaGlsZCwgY2hpbGRLZXksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICBwYXJlbnRXYXRjaGVyLnNldCh2YWwpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgLy8gZW5zdXJlIHN5bmMgdXB3YXJkIGJlZm9yZSBwYXJlbnQgc3luYyBkb3duLlxuICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGluIGNhc2VzIGUuZy4gdGhlIGNoaWxkXG4gICAgICAgICAgLy8gbXV0YXRlcyBhIHByb3AgYXJyYXksIHRoZW4gcmVwbGFjZXMgaXQuICgjMTY4MylcbiAgICAgICAgICBzeW5jOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMucGFyZW50V2F0Y2hlci50ZWFyZG93bigpO1xuICAgIGlmICh0aGlzLmNoaWxkV2F0Y2hlcikge1xuICAgICAgdGhpcy5jaGlsZFdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBxdWV1ZSQxID0gW107XG52YXIgcXVldWVkID0gZmFsc2U7XG5cbi8qKlxuICogUHVzaCBhIGpvYiBpbnRvIHRoZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2JcbiAqL1xuXG5mdW5jdGlvbiBwdXNoSm9iKGpvYikge1xuICBxdWV1ZSQxLnB1c2goam9iKTtcbiAgaWYgKCFxdWV1ZWQpIHtcbiAgICBxdWV1ZWQgPSB0cnVlO1xuICAgIG5leHRUaWNrKGZsdXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIHRoZSBxdWV1ZSwgYW5kIGRvIG9uZSBmb3JjZWQgcmVmbG93IGJlZm9yZVxuICogdHJpZ2dlcmluZyB0cmFuc2l0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgLy8gRm9yY2UgbGF5b3V0XG4gIHZhciBmID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZSQxLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWUkMVtpXSgpO1xuICB9XG4gIHF1ZXVlJDEgPSBbXTtcbiAgcXVldWVkID0gZmFsc2U7XG4gIC8vIGR1bW15IHJldHVybiwgc28ganMgbGludGVycyBkb24ndCBjb21wbGFpbiBhYm91dFxuICAvLyB1bnVzZWQgdmFyaWFibGUgZlxuICByZXR1cm4gZjtcbn1cblxudmFyIFRZUEVfVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBUWVBFX0FOSU1BVElPTiA9ICdhbmltYXRpb24nO1xudmFyIHRyYW5zRHVyYXRpb25Qcm9wID0gdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nO1xudmFyIGFuaW1EdXJhdGlvblByb3AgPSBhbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJztcblxuLyoqXG4gKiBJZiBhIGp1c3QtZW50ZXJlZCBlbGVtZW50IGlzIGFwcGxpZWQgdGhlXG4gKiBsZWF2ZSBjbGFzcyB3aGlsZSBpdHMgZW50ZXIgdHJhbnNpdGlvbiBoYXNuJ3Qgc3RhcnRlZCB5ZXQsXG4gKiBhbmQgdGhlIHRyYW5zaXRpb25lZCBwcm9wZXJ0eSBoYXMgdGhlIHNhbWUgdmFsdWUgZm9yIGJvdGhcbiAqIGVudGVyL2xlYXZlLCB0aGVuIHRoZSBsZWF2ZSB0cmFuc2l0aW9uIHdpbGwgYmUgc2tpcHBlZCBhbmRcbiAqIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50IG5ldmVyIGZpcmVzLiBUaGlzIGZ1bmN0aW9uIGVuc3VyZXNcbiAqIGl0cyBjYWxsYmFjayB0byBiZSBjYWxsZWQgYWZ0ZXIgYSB0cmFuc2l0aW9uIGhhcyBzdGFydGVkXG4gKiBieSB3YWl0aW5nIGZvciBkb3VibGUgcmFmLlxuICpcbiAqIEl0IGZhbGxzIGJhY2sgdG8gc2V0VGltZW91dCBvbiBkZXZpY2VzIHRoYXQgc3VwcG9ydCBDU1NcbiAqIHRyYW5zaXRpb25zIGJ1dCBub3QgcmFmIChlLmcuIEFuZHJvaWQgNC4yIGJyb3dzZXIpIC0gc2luY2VcbiAqIHRoZXNlIGVudmlyb25tZW50cyBhcmUgdXN1YWxseSBzbG93LCB3ZSBhcmUgZ2l2aW5nIGl0IGFcbiAqIHJlbGF0aXZlbHkgbGFyZ2UgdGltZW91dC5cbiAqL1xuXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG52YXIgd2FpdEZvclRyYW5zaXRpb25TdGFydCA9IHJhZlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbj8gZnVuY3Rpb24gKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHNldFRpbWVvdXQoZm4sIDUwKTtcbn07XG5cbi8qKlxuICogQSBUcmFuc2l0aW9uIG9iamVjdCB0aGF0IGVuY2Fwc3VsYXRlcyB0aGUgc3RhdGUgYW5kIGxvZ2ljXG4gKiBvZiB0aGUgdHJhbnNpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBob29rc1xuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cbmZ1bmN0aW9uIFRyYW5zaXRpb24oZWwsIGlkLCBob29rcywgdm0pIHtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmVsID0gZWw7XG4gIHRoaXMuZW50ZXJDbGFzcyA9IGhvb2tzICYmIGhvb2tzLmVudGVyQ2xhc3MgfHwgaWQgKyAnLWVudGVyJztcbiAgdGhpcy5sZWF2ZUNsYXNzID0gaG9va3MgJiYgaG9va3MubGVhdmVDbGFzcyB8fCBpZCArICctbGVhdmUnO1xuICB0aGlzLmhvb2tzID0gaG9va3M7XG4gIHRoaXMudm0gPSB2bTtcbiAgLy8gYXN5bmMgc3RhdGVcbiAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IHRoaXMub3AgPSB0aGlzLmNiID0gbnVsbDtcbiAgdGhpcy5qdXN0RW50ZXJlZCA9IGZhbHNlO1xuICB0aGlzLmVudGVyZWQgPSB0aGlzLmxlZnQgPSBmYWxzZTtcbiAgdGhpcy50eXBlQ2FjaGUgPSB7fTtcbiAgLy8gY2hlY2sgY3NzIHRyYW5zaXRpb24gdHlwZVxuICB0aGlzLnR5cGUgPSBob29rcyAmJiBob29rcy50eXBlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodGhpcy50eXBlICYmIHRoaXMudHlwZSAhPT0gVFlQRV9UUkFOU0lUSU9OICYmIHRoaXMudHlwZSAhPT0gVFlQRV9BTklNQVRJT04pIHtcbiAgICAgIHdhcm4oJ2ludmFsaWQgQ1NTIHRyYW5zaXRpb24gdHlwZSBmb3IgdHJhbnNpdGlvbj1cIicgKyB0aGlzLmlkICsgJ1wiOiAnICsgdGhpcy50eXBlLCB2bSk7XG4gICAgfVxuICB9XG4gIC8vIGJpbmRcbiAgdmFyIHNlbGYgPSB0aGlzO1snZW50ZXJOZXh0VGljaycsICdlbnRlckRvbmUnLCAnbGVhdmVOZXh0VGljaycsICdsZWF2ZURvbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgc2VsZlttXSA9IGJpbmQoc2VsZlttXSwgc2VsZik7XG4gIH0pO1xufVxuXG52YXIgcCQxID0gVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbi8qKlxuICogU3RhcnQgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbi5cbiAqXG4gKiAxLiBlbnRlciB0cmFuc2l0aW9uIHRyaWdnZXJlZFxuICogMi4gY2FsbCBiZWZvcmVFbnRlciBob29rXG4gKiAzLiBhZGQgZW50ZXIgY2xhc3NcbiAqIDQuIGluc2VydC9zaG93IGVsZW1lbnRcbiAqIDUuIGNhbGwgZW50ZXIgaG9vayAod2l0aCBwb3NzaWJsZSBleHBsaWNpdCBqcyBjYWxsYmFjaylcbiAqIDYuIHJlZmxvd1xuICogNy4gYmFzZWQgb24gdHJhbnNpdGlvbiB0eXBlOlxuICogICAgLSB0cmFuc2l0aW9uOlxuICogICAgICAgIHJlbW92ZSBjbGFzcyBub3csIHdhaXQgZm9yIHRyYW5zaXRpb25lbmQsXG4gKiAgICAgICAgdGhlbiBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIGFuaW1hdGlvbjpcbiAqICAgICAgICB3YWl0IGZvciBhbmltYXRpb25lbmQsIHJlbW92ZSBjbGFzcyxcbiAqICAgICAgICB0aGVuIGRvbmUgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqICAgIC0gbm8gY3NzIHRyYW5zaXRpb246XG4gKiAgICAgICAgZG9uZSBub3cgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqIDguIHdhaXQgZm9yIGVpdGhlciBkb25lIG9yIGpzIGNhbGxiYWNrLCB0aGVuIGNhbGxcbiAqICAgIGFmdGVyRW50ZXIgaG9vay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIGluc2VydC9zaG93IHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxucCQxLmVudGVyID0gZnVuY3Rpb24gKG9wLCBjYikge1xuICB0aGlzLmNhbmNlbFBlbmRpbmcoKTtcbiAgdGhpcy5jYWxsSG9vaygnYmVmb3JlRW50ZXInKTtcbiAgdGhpcy5jYiA9IGNiO1xuICBhZGRDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICBvcCgpO1xuICB0aGlzLmVudGVyZWQgPSBmYWxzZTtcbiAgdGhpcy5jYWxsSG9va1dpdGhDYignZW50ZXInKTtcbiAgaWYgKHRoaXMuZW50ZXJlZCkge1xuICAgIHJldHVybjsgLy8gdXNlciBjYWxsZWQgZG9uZSBzeW5jaHJvbm91c2x5LlxuICB9XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmVudGVyQ2FuY2VsbGVkO1xuICBwdXNoSm9iKHRoaXMuZW50ZXJOZXh0VGljayk7XG59O1xuXG4vKipcbiAqIFRoZSBcIm5leHRUaWNrXCIgcGhhc2Ugb2YgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbiwgd2hpY2ggaXNcbiAqIHRvIGJlIHB1c2hlZCBpbnRvIGEgcXVldWUgYW5kIGV4ZWN1dGVkIGFmdGVyIGEgcmVmbG93IHNvXG4gKiB0aGF0IHJlbW92aW5nIHRoZSBjbGFzcyBjYW4gdHJpZ2dlciBhIENTUyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5lbnRlck5leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIC8vIHByZXZlbnQgdHJhbnNpdGlvbiBza2lwcGluZ1xuICB0aGlzLmp1c3RFbnRlcmVkID0gdHJ1ZTtcbiAgd2FpdEZvclRyYW5zaXRpb25TdGFydChmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuanVzdEVudGVyZWQgPSBmYWxzZTtcbiAgfSk7XG4gIHZhciBlbnRlckRvbmUgPSB0aGlzLmVudGVyRG9uZTtcbiAgdmFyIHR5cGUgPSB0aGlzLmdldENzc1RyYW5zaXRpb25UeXBlKHRoaXMuZW50ZXJDbGFzcyk7XG4gIGlmICghdGhpcy5wZW5kaW5nSnNDYikge1xuICAgIGlmICh0eXBlID09PSBUWVBFX1RSQU5TSVRJT04pIHtcbiAgICAgIC8vIHRyaWdnZXIgdHJhbnNpdGlvbiBieSByZW1vdmluZyBlbnRlciBjbGFzcyBub3dcbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gICAgICB0aGlzLnNldHVwQ3NzQ2IodHJhbnNpdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVFlQRV9BTklNQVRJT04pIHtcbiAgICAgIHRoaXMuc2V0dXBDc3NDYihhbmltYXRpb25FbmRFdmVudCwgZW50ZXJEb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJEb25lKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTikge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIFwiY2xlYW51cFwiIHBoYXNlIG9mIGFuIGVudGVyaW5nIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmVudGVyRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbnRlcmVkID0gdHJ1ZTtcbiAgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbDtcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgdGhpcy5jYWxsSG9vaygnYWZ0ZXJFbnRlcicpO1xuICBpZiAodGhpcy5jYikgdGhpcy5jYigpO1xufTtcblxuLyoqXG4gKiBTdGFydCBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAqXG4gKiAxLiBsZWF2ZSB0cmFuc2l0aW9uIHRyaWdnZXJlZC5cbiAqIDIuIGNhbGwgYmVmb3JlTGVhdmUgaG9va1xuICogMy4gYWRkIGxlYXZlIGNsYXNzICh0cmlnZ2VyIGNzcyB0cmFuc2l0aW9uKVxuICogNC4gY2FsbCBsZWF2ZSBob29rICh3aXRoIHBvc3NpYmxlIGV4cGxpY2l0IGpzIGNhbGxiYWNrKVxuICogNS4gcmVmbG93IGlmIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gKiA2LiBiYXNlZCBvbiB0cmFuc2l0aW9uIHR5cGU6XG4gKiAgICAtIHRyYW5zaXRpb24gb3IgYW5pbWF0aW9uOlxuICogICAgICAgIHdhaXQgZm9yIGVuZCBldmVudCwgcmVtb3ZlIGNsYXNzLCB0aGVuIGRvbmUgaWZcbiAqICAgICAgICB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBubyBjc3MgdHJhbnNpdGlvbjpcbiAqICAgICAgICBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiA3LiB3YWl0IGZvciBlaXRoZXIgZG9uZSBvciBqcyBjYWxsYmFjaywgdGhlbiBjYWxsXG4gKiAgICBhZnRlckxlYXZlIGhvb2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSByZW1vdmUvaGlkZSB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbnAkMS5sZWF2ZSA9IGZ1bmN0aW9uIChvcCwgY2IpIHtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nKCk7XG4gIHRoaXMuY2FsbEhvb2soJ2JlZm9yZUxlYXZlJyk7XG4gIHRoaXMub3AgPSBvcDtcbiAgdGhpcy5jYiA9IGNiO1xuICBhZGRDbGFzcyh0aGlzLmVsLCB0aGlzLmxlYXZlQ2xhc3MpO1xuICB0aGlzLmxlZnQgPSBmYWxzZTtcbiAgdGhpcy5jYWxsSG9va1dpdGhDYignbGVhdmUnKTtcbiAgaWYgKHRoaXMubGVmdCkge1xuICAgIHJldHVybjsgLy8gdXNlciBjYWxsZWQgZG9uZSBzeW5jaHJvbm91c2x5LlxuICB9XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmxlYXZlQ2FuY2VsbGVkO1xuICAvLyBvbmx5IG5lZWQgdG8gaGFuZGxlIGxlYXZlRG9uZSBpZlxuICAvLyAxLiB0aGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGRvbmUgKHN5bmNocm9ub3VzbHkgY2FsbGVkXG4gIC8vICAgIGJ5IHRoZSB1c2VyLCB3aGljaCBjYXVzZXMgdGhpcy5vcCBzZXQgdG8gbnVsbClcbiAgLy8gMi4gdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFja1xuICBpZiAodGhpcy5vcCAmJiAhdGhpcy5wZW5kaW5nSnNDYikge1xuICAgIC8vIGlmIGEgQ1NTIHRyYW5zaXRpb24gbGVhdmVzIGltbWVkaWF0ZWx5IGFmdGVyIGVudGVyLFxuICAgIC8vIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50IG5ldmVyIGZpcmVzLiB0aGVyZWZvcmUgd2VcbiAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZW5kIHRoZSBsZWF2ZSBpbW1lZGlhdGVseS5cbiAgICBpZiAodGhpcy5qdXN0RW50ZXJlZCkge1xuICAgICAgdGhpcy5sZWF2ZURvbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEpvYih0aGlzLmxlYXZlTmV4dFRpY2spO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgXCJuZXh0VGlja1wiIHBoYXNlIG9mIGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5sZWF2ZU5leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHlwZSA9IHRoaXMuZ2V0Q3NzVHJhbnNpdGlvblR5cGUodGhpcy5sZWF2ZUNsYXNzKTtcbiAgaWYgKHR5cGUpIHtcbiAgICB2YXIgZXZlbnQgPSB0eXBlID09PSBUWVBFX1RSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgICB0aGlzLnNldHVwQ3NzQ2IoZXZlbnQsIHRoaXMubGVhdmVEb25lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxlYXZlRG9uZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBcImNsZWFudXBcIiBwaGFzZSBvZiBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEubGVhdmVEb25lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxlZnQgPSB0cnVlO1xuICB0aGlzLmNhbmNlbCA9IHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsO1xuICB0aGlzLm9wKCk7XG4gIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyk7XG4gIHRoaXMuY2FsbEhvb2soJ2FmdGVyTGVhdmUnKTtcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKTtcbiAgdGhpcy5vcCA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbmNlbCBhbnkgcGVuZGluZyBjYWxsYmFja3MgZnJvbSBhIHByZXZpb3VzbHkgcnVubmluZ1xuICogYnV0IG5vdCBmaW5pc2hlZCB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5jYW5jZWxQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm9wID0gdGhpcy5jYiA9IG51bGw7XG4gIHZhciBoYXNQZW5kaW5nID0gZmFsc2U7XG4gIGlmICh0aGlzLnBlbmRpbmdDc3NDYikge1xuICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgIG9mZih0aGlzLmVsLCB0aGlzLnBlbmRpbmdDc3NFdmVudCwgdGhpcy5wZW5kaW5nQ3NzQ2IpO1xuICAgIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID0gdGhpcy5wZW5kaW5nQ3NzQ2IgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnBlbmRpbmdKc0NiKSB7XG4gICAgaGFzUGVuZGluZyA9IHRydWU7XG4gICAgdGhpcy5wZW5kaW5nSnNDYi5jYW5jZWwoKTtcbiAgICB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbDtcbiAgfVxuICBpZiAoaGFzUGVuZGluZykge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKTtcbiAgfVxuICBpZiAodGhpcy5jYW5jZWwpIHtcbiAgICB0aGlzLmNhbmNlbC5jYWxsKHRoaXMudm0sIHRoaXMuZWwpO1xuICAgIHRoaXMuY2FuY2VsID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgdXNlci1wcm92aWRlZCBzeW5jaHJvbm91cyBob29rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cblxucCQxLmNhbGxIb29rID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXSkge1xuICAgIHRoaXMuaG9va3NbdHlwZV0uY2FsbCh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgdXNlci1wcm92aWRlZCwgcG90ZW50aWFsbHktYXN5bmMgaG9vayBmdW5jdGlvbi5cbiAqIFdlIGNoZWNrIGZvciB0aGUgbGVuZ3RoIG9mIGFyZ3VtZW50cyB0byBzZWUgaWYgdGhlIGhvb2tcbiAqIGV4cGVjdHMgYSBgZG9uZWAgY2FsbGJhY2suIElmIHRydWUsIHRoZSB0cmFuc2l0aW9uJ3MgZW5kXG4gKiB3aWxsIGJlIGRldGVybWluZWQgYnkgd2hlbiB0aGUgdXNlciBjYWxscyB0aGF0IGNhbGxiYWNrO1xuICogb3RoZXJ3aXNlLCB0aGUgZW5kIGlzIGRldGVybWluZWQgYnkgdGhlIENTUyB0cmFuc2l0aW9uIG9yXG4gKiBhbmltYXRpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5wJDEuY2FsbEhvb2tXaXRoQ2IgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgaG9vayA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXTtcbiAgaWYgKGhvb2spIHtcbiAgICBpZiAoaG9vay5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnBlbmRpbmdKc0NiID0gY2FuY2VsbGFibGUodGhpc1t0eXBlICsgJ0RvbmUnXSk7XG4gICAgfVxuICAgIGhvb2suY2FsbCh0aGlzLnZtLCB0aGlzLmVsLCB0aGlzLnBlbmRpbmdKc0NiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIHRyYW5zaXRpb24gdHlwZSBiYXNlZCBvbiB0aGVcbiAqIGNhbGN1bGF0ZWQgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuXG5wJDEuZ2V0Q3NzVHJhbnNpdGlvblR5cGUgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXRyYW5zaXRpb25FbmRFdmVudCB8fFxuICAvLyBza2lwIENTUyB0cmFuc2l0aW9ucyBpZiBwYWdlIGlzIG5vdCB2aXNpYmxlIC1cbiAgLy8gdGhpcyBzb2x2ZXMgdGhlIGlzc3VlIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzIG5vdFxuICAvLyBmaXJpbmcgdW50aWwgdGhlIHBhZ2UgaXMgdmlzaWJsZSBhZ2Fpbi5cbiAgLy8gcGFnZVZpc2liaWxpdHkgQVBJIGlzIHN1cHBvcnRlZCBpbiBJRTEwKywgc2FtZSBhc1xuICAvLyBDU1MgdHJhbnNpdGlvbnMuXG4gIGRvY3VtZW50LmhpZGRlbiB8fFxuICAvLyBleHBsaWNpdCBqcy1vbmx5IHRyYW5zaXRpb25cbiAgdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmNzcyA9PT0gZmFsc2UgfHxcbiAgLy8gZWxlbWVudCBpcyBoaWRkZW5cbiAgaXNIaWRkZW4odGhpcy5lbCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHR5cGUgPSB0aGlzLnR5cGUgfHwgdGhpcy50eXBlQ2FjaGVbY2xhc3NOYW1lXTtcbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlO1xuICB2YXIgaW5saW5lU3R5bGVzID0gdGhpcy5lbC5zdHlsZTtcbiAgdmFyIGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbCk7XG4gIHZhciB0cmFuc0R1cmF0aW9uID0gaW5saW5lU3R5bGVzW3RyYW5zRHVyYXRpb25Qcm9wXSB8fCBjb21wdXRlZFN0eWxlc1t0cmFuc0R1cmF0aW9uUHJvcF07XG4gIGlmICh0cmFuc0R1cmF0aW9uICYmIHRyYW5zRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICB0eXBlID0gVFlQRV9UUkFOU0lUSU9OO1xuICB9IGVsc2Uge1xuICAgIHZhciBhbmltRHVyYXRpb24gPSBpbmxpbmVTdHlsZXNbYW5pbUR1cmF0aW9uUHJvcF0gfHwgY29tcHV0ZWRTdHlsZXNbYW5pbUR1cmF0aW9uUHJvcF07XG4gICAgaWYgKGFuaW1EdXJhdGlvbiAmJiBhbmltRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICAgIHR5cGUgPSBUWVBFX0FOSU1BVElPTjtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGUpIHtcbiAgICB0aGlzLnR5cGVDYWNoZVtjbGFzc05hbWVdID0gdHlwZTtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn07XG5cbi8qKlxuICogU2V0dXAgYSBDU1MgdHJhbnNpdGlvbmVuZC9hbmltYXRpb25lbmQgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbnAkMS5zZXR1cENzc0NiID0gZnVuY3Rpb24gKGV2ZW50LCBjYikge1xuICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IGV2ZW50O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlbCA9IHRoaXMuZWw7XG4gIHZhciBvbkVuZCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBvZmYoZWwsIGV2ZW50LCBvbkVuZCk7XG4gICAgICBzZWxmLnBlbmRpbmdDc3NFdmVudCA9IHNlbGYucGVuZGluZ0Nzc0NiID0gbnVsbDtcbiAgICAgIGlmICghc2VsZi5wZW5kaW5nSnNDYiAmJiBjYikge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgb24oZWwsIGV2ZW50LCBvbkVuZCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgaGlkZGVuIC0gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0XG4gKiBza2lwIHRoZSB0cmFuc2l0aW9uIGFsbHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNIaWRkZW4oZWwpIHtcbiAgaWYgKC9zdmckLy50ZXN0KGVsLm5hbWVzcGFjZVVSSSkpIHtcbiAgICAvLyBTVkcgZWxlbWVudHMgZG8gbm90IGhhdmUgb2Zmc2V0KFdpZHRofEhlaWdodClcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBjbGllbnQgcmVjdFxuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuICEocmVjdC53aWR0aCB8fCByZWN0LmhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICEoZWwub2Zmc2V0V2lkdGggfHwgZWwub2Zmc2V0SGVpZ2h0IHx8IGVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiQxID0ge1xuXG4gIHByaW9yaXR5OiBUUkFOU0lUSU9OLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGlkLCBvbGRJZCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgLy8gcmVzb2x2ZSBvbiBvd25lciB2bVxuICAgIHZhciBob29rcyA9IHJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAndHJhbnNpdGlvbnMnLCBpZCk7XG4gICAgaWQgPSBpZCB8fCAndic7XG4gICAgb2xkSWQgPSBvbGRJZCB8fCAndic7XG4gICAgZWwuX192X3RyYW5zID0gbmV3IFRyYW5zaXRpb24oZWwsIGlkLCBob29rcywgdGhpcy52bSk7XG4gICAgcmVtb3ZlQ2xhc3MoZWwsIG9sZElkICsgJy10cmFuc2l0aW9uJyk7XG4gICAgYWRkQ2xhc3MoZWwsIGlkICsgJy10cmFuc2l0aW9uJyk7XG4gIH1cbn07XG5cbnZhciBpbnRlcm5hbERpcmVjdGl2ZXMgPSB7XG4gIHN0eWxlOiBzdHlsZSxcbiAgJ2NsYXNzJzogdkNsYXNzLFxuICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgcHJvcDogcHJvcERlZixcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiQxXG59O1xuXG4vLyBzcGVjaWFsIGJpbmRpbmcgcHJlZml4ZXNcbnZhciBiaW5kUkUgPSAvXnYtYmluZDp8XjovO1xudmFyIG9uUkUgPSAvXnYtb246fF5ALztcbnZhciBkaXJBdHRyUkUgPSAvXnYtKFteOl0rKSg/OiR8OiguKikkKS87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXlxcLl0rL2c7XG52YXIgdHJhbnNpdGlvblJFID0gL14odi1iaW5kOnw6KT90cmFuc2l0aW9uJC87XG5cbi8vIGRlZmF1bHQgZGlyZWN0aXZlIHByaW9yaXR5XG52YXIgREVGQVVMVF9QUklPUklUWSA9IDEwMDA7XG52YXIgREVGQVVMVF9URVJNSU5BTF9QUklPUklUWSA9IDIwMDA7XG5cbi8qKlxuICogQ29tcGlsZSBhIHRlbXBsYXRlIGFuZCByZXR1cm4gYSByZXVzYWJsZSBjb21wb3NpdGUgbGlua1xuICogZnVuY3Rpb24sIHdoaWNoIHJlY3Vyc2l2ZWx5IGNvbnRhaW5zIG1vcmUgbGluayBmdW5jdGlvbnNcbiAqIGluc2lkZS4gVGhpcyB0b3AgbGV2ZWwgY29tcGlsZSBmdW5jdGlvbiB3b3VsZCBub3JtYWxseVxuICogYmUgY2FsbGVkIG9uIGluc3RhbmNlIHJvb3Qgbm9kZXMsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkXG4gKiBmb3IgcGFydGlhbCBjb21waWxhdGlvbiBpZiB0aGUgcGFydGlhbCBhcmd1bWVudCBpcyB0cnVlLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjb21wb3NpdGUgbGluayBmdW5jdGlvbiwgd2hlbiBjYWxsZWQsIHdpbGxcbiAqIHJldHVybiBhbiB1bmxpbmsgZnVuY3Rpb24gdGhhdCB0ZWFyc2Rvd24gYWxsIGRpcmVjdGl2ZXNcbiAqIGNyZWF0ZWQgZHVyaW5nIHRoZSBsaW5raW5nIHBoYXNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFydGlhbFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZShlbCwgb3B0aW9ucywgcGFydGlhbCkge1xuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgbm9kZSBpdHNlbGYuXG4gIHZhciBub2RlTGlua0ZuID0gcGFydGlhbCB8fCAhb3B0aW9ucy5fYXNDb21wb25lbnQgPyBjb21waWxlTm9kZShlbCwgb3B0aW9ucykgOiBudWxsO1xuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgY2hpbGROb2Rlc1xuICB2YXIgY2hpbGRMaW5rRm4gPSAhKG5vZGVMaW5rRm4gJiYgbm9kZUxpbmtGbi50ZXJtaW5hbCkgJiYgIWlzU2NyaXB0KGVsKSAmJiBlbC5oYXNDaGlsZE5vZGVzKCkgPyBjb21waWxlTm9kZUxpc3QoZWwuY2hpbGROb2Rlcywgb3B0aW9ucykgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGNvbXBvc2l0ZSBsaW5rZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGEgYWxyZWFkeVxuICAgKiBjb21waWxlZCBwaWVjZSBvZiBET00sIHdoaWNoIGluc3RhbnRpYXRlcyBhbGwgZGlyZWN0aXZlXG4gICAqIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICAgKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdIC0gaG9zdCB2bSBvZiB0cmFuc2NsdWRlZCBjb250ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gbGluayBjb250ZXh0IGZyYWdtZW50XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICovXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBvc2l0ZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KGVsLmNoaWxkTm9kZXMpO1xuICAgIC8vIGxpbmtcbiAgICB2YXIgZGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uIGNvbXBvc2l0ZUxpbmtDYXB0dXJlcigpIHtcbiAgICAgIGlmIChub2RlTGlua0ZuKSBub2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgICAgaWYgKGNoaWxkTGlua0ZuKSBjaGlsZExpbmtGbih2bSwgY2hpbGROb2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgIH0sIHZtKTtcbiAgICByZXR1cm4gbWFrZVVubGlua0ZuKHZtLCBkaXJzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBseSBhIGxpbmtlciB0byBhIHZtL2VsZW1lbnQgcGFpciBhbmQgY2FwdHVyZSB0aGVcbiAqIGRpcmVjdGl2ZXMgY3JlYXRlZCBkdXJpbmcgdGhlIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua2VyXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBsaW5rQW5kQ2FwdHVyZShsaW5rZXIsIHZtKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIHJlc2V0IGRpcmVjdGl2ZXMgYmVmb3JlIGV2ZXJ5IGNhcHR1cmUgaW4gcHJvZHVjdGlvblxuICAgIC8vIG1vZGUsIHNvIHRoYXQgd2hlbiB1bmxpbmtpbmcgd2UgZG9uJ3QgbmVlZCB0byBzcGxpY2VcbiAgICAvLyB0aGVtIG91dCAod2hpY2ggdHVybnMgb3V0IHRvIGJlIGEgcGVyZiBoaXQpLlxuICAgIC8vIHRoZXkgYXJlIGtlcHQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIHRoZXkgYXJlXG4gICAgLy8gdXNlZnVsIGZvciBWdWUncyBvd24gdGVzdHMuXG4gICAgdm0uX2RpcmVjdGl2ZXMgPSBbXTtcbiAgfVxuICB2YXIgb3JpZ2luYWxEaXJDb3VudCA9IHZtLl9kaXJlY3RpdmVzLmxlbmd0aDtcbiAgbGlua2VyKCk7XG4gIHZhciBkaXJzID0gdm0uX2RpcmVjdGl2ZXMuc2xpY2Uob3JpZ2luYWxEaXJDb3VudCk7XG4gIGRpcnMuc29ydChkaXJlY3RpdmVDb21wYXJhdG9yKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpcnNbaV0uX2JpbmQoKTtcbiAgfVxuICByZXR1cm4gZGlycztcbn1cblxuLyoqXG4gKiBEaXJlY3RpdmUgcHJpb3JpdHkgc29ydCBjb21wYXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKi9cblxuZnVuY3Rpb24gZGlyZWN0aXZlQ29tcGFyYXRvcihhLCBiKSB7XG4gIGEgPSBhLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFk7XG4gIGIgPSBiLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFk7XG4gIHJldHVybiBhID4gYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xufVxuXG4vKipcbiAqIExpbmtlciBmdW5jdGlvbnMgcmV0dXJuIGFuIHVubGluayBmdW5jdGlvbiB0aGF0XG4gKiB0ZWFyc2Rvd24gYWxsIGRpcmVjdGl2ZXMgaW5zdGFuY2VzIGdlbmVyYXRlZCBkdXJpbmdcbiAqIHRoZSBwcm9jZXNzLlxuICpcbiAqIFdlIGNyZWF0ZSB1bmxpbmsgZnVuY3Rpb25zIHdpdGggb25seSB0aGUgbmVjZXNzYXJ5XG4gKiBpbmZvcm1hdGlvbiB0byBhdm9pZCByZXRhaW5pbmcgYWRkaXRpb25hbCBjbG9zdXJlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7QXJyYXl9IGRpcnNcbiAqIEBwYXJhbSB7VnVlfSBbY29udGV4dF1cbiAqIEBwYXJhbSB7QXJyYXl9IFtjb250ZXh0RGlyc11cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIG1ha2VVbmxpbmtGbih2bSwgZGlycywgY29udGV4dCwgY29udGV4dERpcnMpIHtcbiAgZnVuY3Rpb24gdW5saW5rKGRlc3Ryb3lpbmcpIHtcbiAgICB0ZWFyZG93bkRpcnModm0sIGRpcnMsIGRlc3Ryb3lpbmcpO1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHREaXJzKSB7XG4gICAgICB0ZWFyZG93bkRpcnMoY29udGV4dCwgY29udGV4dERpcnMpO1xuICAgIH1cbiAgfVxuICAvLyBleHBvc2UgbGlua2VkIGRpcmVjdGl2ZXNcbiAgdW5saW5rLmRpcnMgPSBkaXJzO1xuICByZXR1cm4gdW5saW5rO1xufVxuXG4vKipcbiAqIFRlYXJkb3duIHBhcnRpYWwgbGlua2VkIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRlc3Ryb3lpbmdcbiAqL1xuXG5mdW5jdGlvbiB0ZWFyZG93bkRpcnModm0sIGRpcnMsIGRlc3Ryb3lpbmcpIHtcbiAgdmFyIGkgPSBkaXJzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGRpcnNbaV0uX3RlYXJkb3duKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWRlc3Ryb3lpbmcpIHtcbiAgICAgIHZtLl9kaXJlY3RpdmVzLiRyZW1vdmUoZGlyc1tpXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBsaW5rIHByb3BzIG9uIGFuIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUFuZExpbmtQcm9wcyh2bSwgZWwsIHByb3BzLCBzY29wZSkge1xuICB2YXIgcHJvcHNMaW5rRm4gPSBjb21waWxlUHJvcHMoZWwsIHByb3BzLCB2bSk7XG4gIHZhciBwcm9wRGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uICgpIHtcbiAgICBwcm9wc0xpbmtGbih2bSwgc2NvcGUpO1xuICB9LCB2bSk7XG4gIHJldHVybiBtYWtlVW5saW5rRm4odm0sIHByb3BEaXJzKTtcbn1cblxuLyoqXG4gKiBDb21waWxlIHRoZSByb290IGVsZW1lbnQgb2YgYW4gaW5zdGFuY2UuXG4gKlxuICogMS4gYXR0cnMgb24gY29udGV4dCBjb250YWluZXIgKGNvbnRleHQgc2NvcGUpXG4gKiAyLiBhdHRycyBvbiB0aGUgY29tcG9uZW50IHRlbXBsYXRlIHJvb3Qgbm9kZSwgaWZcbiAqICAgIHJlcGxhY2U6dHJ1ZSAoY2hpbGQgc2NvcGUpXG4gKlxuICogSWYgdGhpcyBpcyBhIGZyYWdtZW50IGluc3RhbmNlLCB3ZSBvbmx5IG5lZWQgdG8gY29tcGlsZSAxLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dE9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVSb290KGVsLCBvcHRpb25zLCBjb250ZXh0T3B0aW9ucykge1xuICB2YXIgY29udGFpbmVyQXR0cnMgPSBvcHRpb25zLl9jb250YWluZXJBdHRycztcbiAgdmFyIHJlcGxhY2VyQXR0cnMgPSBvcHRpb25zLl9yZXBsYWNlckF0dHJzO1xuICB2YXIgY29udGV4dExpbmtGbiwgcmVwbGFjZXJMaW5rRm47XG5cbiAgLy8gb25seSBuZWVkIHRvIGNvbXBpbGUgb3RoZXIgYXR0cmlidXRlcyBmb3JcbiAgLy8gbm9uLWZyYWdtZW50IGluc3RhbmNlc1xuICBpZiAoZWwubm9kZVR5cGUgIT09IDExKSB7XG4gICAgLy8gZm9yIGNvbXBvbmVudHMsIGNvbnRhaW5lciBhbmQgcmVwbGFjZXIgbmVlZCB0byBiZVxuICAgIC8vIGNvbXBpbGVkIHNlcGFyYXRlbHkgYW5kIGxpbmtlZCBpbiBkaWZmZXJlbnQgc2NvcGVzLlxuICAgIGlmIChvcHRpb25zLl9hc0NvbXBvbmVudCkge1xuICAgICAgLy8gMi4gY29udGFpbmVyIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChjb250YWluZXJBdHRycyAmJiBjb250ZXh0T3B0aW9ucykge1xuICAgICAgICBjb250ZXh0TGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoY29udGFpbmVyQXR0cnMsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXBsYWNlckF0dHJzKSB7XG4gICAgICAgIC8vIDMuIHJlcGxhY2VyIGF0dHJpYnV0ZXNcbiAgICAgICAgcmVwbGFjZXJMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhyZXBsYWNlckF0dHJzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9uLWNvbXBvbmVudCwganVzdCBjb21waWxlIGFzIGEgbm9ybWFsIGVsZW1lbnQuXG4gICAgICByZXBsYWNlckxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGVsLmF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbnRhaW5lckF0dHJzKSB7XG4gICAgLy8gd2FybiBjb250YWluZXIgZGlyZWN0aXZlcyBmb3IgZnJhZ21lbnQgaW5zdGFuY2VzXG4gICAgdmFyIG5hbWVzID0gY29udGFpbmVyQXR0cnMuZmlsdGVyKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAvLyBhbGxvdyB2dWUtbG9hZGVyL3Z1ZWlmeSBzY29wZWQgY3NzIGF0dHJpYnV0ZXNcbiAgICAgIHJldHVybiBhdHRyLm5hbWUuaW5kZXhPZignX3YtJykgPCAwICYmXG4gICAgICAvLyBhbGxvdyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICFvblJFLnRlc3QoYXR0ci5uYW1lKSAmJlxuICAgICAgLy8gYWxsb3cgc2xvdHNcbiAgICAgIGF0dHIubmFtZSAhPT0gJ3Nsb3QnO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgcmV0dXJuICdcIicgKyBhdHRyLm5hbWUgKyAnXCInO1xuICAgIH0pO1xuICAgIGlmIChuYW1lcy5sZW5ndGgpIHtcbiAgICAgIHZhciBwbHVyYWwgPSBuYW1lcy5sZW5ndGggPiAxO1xuICAgICAgd2FybignQXR0cmlidXRlJyArIChwbHVyYWwgPyAncyAnIDogJyAnKSArIG5hbWVzLmpvaW4oJywgJykgKyAocGx1cmFsID8gJyBhcmUnIDogJyBpcycpICsgJyBpZ25vcmVkIG9uIGNvbXBvbmVudCAnICsgJzwnICsgb3B0aW9ucy5lbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyAnPiBiZWNhdXNlICcgKyAndGhlIGNvbXBvbmVudCBpcyBhIGZyYWdtZW50IGluc3RhbmNlOiAnICsgJ2h0dHA6Ly92dWVqcy5vcmcvZ3VpZGUvY29tcG9uZW50cy5odG1sI0ZyYWdtZW50LUluc3RhbmNlJyk7XG4gICAgfVxuICB9XG5cbiAgb3B0aW9ucy5fY29udGFpbmVyQXR0cnMgPSBvcHRpb25zLl9yZXBsYWNlckF0dHJzID0gbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJvb3RMaW5rRm4odm0sIGVsLCBzY29wZSkge1xuICAgIC8vIGxpbmsgY29udGV4dCBzY29wZSBkaXJzXG4gICAgdmFyIGNvbnRleHQgPSB2bS5fY29udGV4dDtcbiAgICB2YXIgY29udGV4dERpcnM7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dExpbmtGbikge1xuICAgICAgY29udGV4dERpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRleHRMaW5rRm4oY29udGV4dCwgZWwsIG51bGwsIHNjb3BlKTtcbiAgICAgIH0sIGNvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIGxpbmsgc2VsZlxuICAgIHZhciBzZWxmRGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyZXBsYWNlckxpbmtGbikgcmVwbGFjZXJMaW5rRm4odm0sIGVsKTtcbiAgICB9LCB2bSk7XG5cbiAgICAvLyByZXR1cm4gdGhlIHVubGluayBmdW5jdGlvbiB0aGF0IHRlYXJzZG93biBjb250ZXh0XG4gICAgLy8gY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gICAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgc2VsZkRpcnMsIGNvbnRleHQsIGNvbnRleHREaXJzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgbm9kZSBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbiBiYXNlZCBvbiB0aGVcbiAqIG5vZGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVOb2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgdmFyIHR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICBpZiAodHlwZSA9PT0gMSAmJiAhaXNTY3JpcHQobm9kZSkpIHtcbiAgICByZXR1cm4gY29tcGlsZUVsZW1lbnQobm9kZSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gMyAmJiBub2RlLmRhdGEudHJpbSgpKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVUZXh0Tm9kZShub2RlLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlRWxlbWVudChlbCwgb3B0aW9ucykge1xuICAvLyBwcmVwcm9jZXNzIHRleHRhcmVhcy5cbiAgLy8gdGV4dGFyZWEgdHJlYXRzIGl0cyB0ZXh0IGNvbnRlbnQgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gIC8vIGp1c3QgYmluZCBpdCBhcyBhbiBhdHRyIGRpcmVjdGl2ZSBmb3IgdmFsdWUuXG4gIGlmIChlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgdmFyIHRva2VucyA9IHBhcnNlVGV4dChlbC52YWx1ZSk7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCc6dmFsdWUnLCB0b2tlbnNUb0V4cCh0b2tlbnMpKTtcbiAgICAgIGVsLnZhbHVlID0gJyc7XG4gICAgfVxuICB9XG4gIHZhciBsaW5rRm47XG4gIHZhciBoYXNBdHRycyA9IGVsLmhhc0F0dHJpYnV0ZXMoKTtcbiAgdmFyIGF0dHJzID0gaGFzQXR0cnMgJiYgdG9BcnJheShlbC5hdHRyaWJ1dGVzKTtcbiAgLy8gY2hlY2sgdGVybWluYWwgZGlyZWN0aXZlcyAoZm9yICYgaWYpXG4gIGlmIChoYXNBdHRycykge1xuICAgIGxpbmtGbiA9IGNoZWNrVGVybWluYWxEaXJlY3RpdmVzKGVsLCBhdHRycywgb3B0aW9ucyk7XG4gIH1cbiAgLy8gY2hlY2sgZWxlbWVudCBkaXJlY3RpdmVzXG4gIGlmICghbGlua0ZuKSB7XG4gICAgbGlua0ZuID0gY2hlY2tFbGVtZW50RGlyZWN0aXZlcyhlbCwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gY2hlY2sgY29tcG9uZW50XG4gIGlmICghbGlua0ZuKSB7XG4gICAgbGlua0ZuID0gY2hlY2tDb21wb25lbnQoZWwsIG9wdGlvbnMpO1xuICB9XG4gIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gIGlmICghbGlua0ZuICYmIGhhc0F0dHJzKSB7XG4gICAgbGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoYXR0cnMsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBsaW5rRm47XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHRleHROb2RlIGFuZCByZXR1cm4gYSBub2RlTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7VGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfSB0ZXh0Tm9kZUxpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVUZXh0Tm9kZShub2RlLCBvcHRpb25zKSB7XG4gIC8vIHNraXAgbWFya2VkIHRleHQgbm9kZXNcbiAgaWYgKG5vZGUuX3NraXApIHtcbiAgICByZXR1cm4gcmVtb3ZlVGV4dDtcbiAgfVxuXG4gIHZhciB0b2tlbnMgPSBwYXJzZVRleHQobm9kZS53aG9sZVRleHQpO1xuICBpZiAoIXRva2Vucykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbWFyayBhZGphY2VudCB0ZXh0IG5vZGVzIGFzIHNraXBwZWQsXG4gIC8vIGJlY2F1c2Ugd2UgYXJlIHVzaW5nIG5vZGUud2hvbGVUZXh0IHRvIGNvbXBpbGVcbiAgLy8gYWxsIGFkamFjZW50IHRleHQgbm9kZXMgdG9nZXRoZXIuIFRoaXMgZml4ZXNcbiAgLy8gaXNzdWVzIGluIElFIHdoZXJlIHNvbWV0aW1lcyBpdCBzcGxpdHMgdXAgYSBzaW5nbGVcbiAgLy8gdGV4dCBub2RlIGludG8gbXVsdGlwbGUgb25lcy5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICB3aGlsZSAobmV4dCAmJiBuZXh0Lm5vZGVUeXBlID09PSAzKSB7XG4gICAgbmV4dC5fc2tpcCA9IHRydWU7XG4gICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gIH1cblxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgdmFyIGVsLCB0b2tlbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgZWwgPSB0b2tlbi50YWcgPyBwcm9jZXNzVGV4dFRva2VuKHRva2VuLCBvcHRpb25zKSA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKTtcbiAgICBmcmFnLmFwcGVuZENoaWxkKGVsKTtcbiAgfVxuICByZXR1cm4gbWFrZVRleHROb2RlTGlua0ZuKHRva2VucywgZnJhZywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogTGlua2VyIGZvciBhbiBza2lwcGVkIHRleHQgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7VGV4dH0gbm9kZVxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZVRleHQodm0sIG5vZGUpIHtcbiAgcmVtb3ZlKG5vZGUpO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBzaW5nbGUgdGV4dCB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5cbmZ1bmN0aW9uIHByb2Nlc3NUZXh0VG9rZW4odG9rZW4sIG9wdGlvbnMpIHtcbiAgdmFyIGVsO1xuICBpZiAodG9rZW4ub25lVGltZSkge1xuICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodG9rZW4udmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0b2tlbi5odG1sKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3YtaHRtbCcpO1xuICAgICAgc2V0VG9rZW5UeXBlKCdodG1sJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElFIHdpbGwgY2xlYW4gdXAgZW1wdHkgdGV4dE5vZGVzIGR1cmluZ1xuICAgICAgLy8gZnJhZy5jbG9uZU5vZGUodHJ1ZSksIHNvIHdlIGhhdmUgdG8gZ2l2ZSBpdFxuICAgICAgLy8gc29tZXRoaW5nIGhlcmUuLi5cbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKTtcbiAgICAgIHNldFRva2VuVHlwZSgndGV4dCcpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRUb2tlblR5cGUodHlwZSkge1xuICAgIGlmICh0b2tlbi5kZXNjcmlwdG9yKSByZXR1cm47XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKHRva2VuLnZhbHVlKTtcbiAgICB0b2tlbi5kZXNjcmlwdG9yID0ge1xuICAgICAgbmFtZTogdHlwZSxcbiAgICAgIGRlZjogZGlyZWN0aXZlc1t0eXBlXSxcbiAgICAgIGV4cHJlc3Npb246IHBhcnNlZC5leHByZXNzaW9uLFxuICAgICAgZmlsdGVyczogcGFyc2VkLmZpbHRlcnNcbiAgICB9O1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGEgdGV4dE5vZGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSB0b2tlbnNcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICovXG5cbmZ1bmN0aW9uIG1ha2VUZXh0Tm9kZUxpbmtGbih0b2tlbnMsIGZyYWcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRleHROb2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUpIHtcbiAgICB2YXIgZnJhZ0Nsb25lID0gZnJhZy5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KGZyYWdDbG9uZS5jaGlsZE5vZGVzKTtcbiAgICB2YXIgdG9rZW4sIHZhbHVlLCBub2RlO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgaWYgKHRva2VuLnRhZykge1xuICAgICAgICBub2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgaWYgKHRva2VuLm9uZVRpbWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IChzY29wZSB8fCB2bSkuJGV2YWwodmFsdWUpO1xuICAgICAgICAgIGlmICh0b2tlbi5odG1sKSB7XG4gICAgICAgICAgICByZXBsYWNlKG5vZGUsIHBhcnNlVGVtcGxhdGUodmFsdWUsIHRydWUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm0uX2JpbmREaXIodG9rZW4uZGVzY3JpcHRvciwgbm9kZSwgaG9zdCwgc2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZWwsIGZyYWdDbG9uZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIG5vZGUgbGlzdCBhbmQgcmV0dXJuIGEgY2hpbGRMaW5rRm4uXG4gKlxuICogQHBhcmFtIHtOb2RlTGlzdH0gbm9kZUxpc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZU5vZGVMaXN0KG5vZGVMaXN0LCBvcHRpb25zKSB7XG4gIHZhciBsaW5rRm5zID0gW107XG4gIHZhciBub2RlTGlua0ZuLCBjaGlsZExpbmtGbiwgbm9kZTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBub2RlID0gbm9kZUxpc3RbaV07XG4gICAgbm9kZUxpbmtGbiA9IGNvbXBpbGVOb2RlKG5vZGUsIG9wdGlvbnMpO1xuICAgIGNoaWxkTGlua0ZuID0gIShub2RlTGlua0ZuICYmIG5vZGVMaW5rRm4udGVybWluYWwpICYmIG5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCcgJiYgbm9kZS5oYXNDaGlsZE5vZGVzKCkgPyBjb21waWxlTm9kZUxpc3Qobm9kZS5jaGlsZE5vZGVzLCBvcHRpb25zKSA6IG51bGw7XG4gICAgbGlua0Zucy5wdXNoKG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuKTtcbiAgfVxuICByZXR1cm4gbGlua0Zucy5sZW5ndGggPyBtYWtlQ2hpbGRMaW5rRm4obGlua0ZucykgOiBudWxsO1xufVxuXG4vKipcbiAqIE1ha2UgYSBjaGlsZCBsaW5rIGZ1bmN0aW9uIGZvciBhIG5vZGUncyBjaGlsZE5vZGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8RnVuY3Rpb24+fSBsaW5rRm5zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gY2hpbGRMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlQ2hpbGRMaW5rRm4obGlua0Zucykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hpbGRMaW5rRm4odm0sIG5vZGVzLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIHZhciBub2RlLCBub2RlTGlua0ZuLCBjaGlsZHJlbkxpbmtGbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IDAsIGwgPSBsaW5rRm5zLmxlbmd0aDsgaSA8IGw7IG4rKykge1xuICAgICAgbm9kZSA9IG5vZGVzW25dO1xuICAgICAgbm9kZUxpbmtGbiA9IGxpbmtGbnNbaSsrXTtcbiAgICAgIGNoaWxkcmVuTGlua0ZuID0gbGlua0Zuc1tpKytdO1xuICAgICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IHRvQXJyYXkobm9kZS5jaGlsZE5vZGVzKTtcbiAgICAgIGlmIChub2RlTGlua0ZuKSB7XG4gICAgICAgIG5vZGVMaW5rRm4odm0sIG5vZGUsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZHJlbkxpbmtGbikge1xuICAgICAgICBjaGlsZHJlbkxpbmtGbih2bSwgY2hpbGROb2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBmb3IgZWxlbWVudCBkaXJlY3RpdmVzIChjdXN0b20gZWxlbWVudHMgdGhhdCBzaG91bGRcbiAqIGJlIHJlc292bGVkIGFzIHRlcm1pbmFsIGRpcmVjdGl2ZXMpLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tFbGVtZW50RGlyZWN0aXZlcyhlbCwgb3B0aW9ucykge1xuICB2YXIgdGFnID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoY29tbW9uVGFnUkUudGVzdCh0YWcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBkZWYgPSByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2VsZW1lbnREaXJlY3RpdmVzJywgdGFnKTtcbiAgaWYgKGRlZikge1xuICAgIHJldHVybiBtYWtlVGVybWluYWxOb2RlTGlua0ZuKGVsLCB0YWcsICcnLCBvcHRpb25zLCBkZWYpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIGNvbXBvbmVudC4gSWYgeWVzLCByZXR1cm5cbiAqIGEgY29tcG9uZW50IGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudChlbCwgb3B0aW9ucykge1xuICB2YXIgY29tcG9uZW50ID0gY2hlY2tDb21wb25lbnRBdHRyKGVsLCBvcHRpb25zKTtcbiAgaWYgKGNvbXBvbmVudCkge1xuICAgIHZhciByZWYgPSBmaW5kUmVmKGVsKTtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgIG5hbWU6ICdjb21wb25lbnQnLFxuICAgICAgcmVmOiByZWYsXG4gICAgICBleHByZXNzaW9uOiBjb21wb25lbnQuaWQsXG4gICAgICBkZWY6IGludGVybmFsRGlyZWN0aXZlcy5jb21wb25lbnQsXG4gICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgbGl0ZXJhbDogIWNvbXBvbmVudC5keW5hbWljXG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgY29tcG9uZW50TGlua0ZuID0gZnVuY3Rpb24gY29tcG9uZW50TGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUoKHNjb3BlIHx8IHZtKS4kcmVmcywgcmVmLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHZtLl9iaW5kRGlyKGRlc2NyaXB0b3IsIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgfTtcbiAgICBjb21wb25lbnRMaW5rRm4udGVybWluYWwgPSB0cnVlO1xuICAgIHJldHVybiBjb21wb25lbnRMaW5rRm47XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBhbiBlbGVtZW50IGZvciB0ZXJtaW5hbCBkaXJlY3RpdmVzIGluIGZpeGVkIG9yZGVyLlxuICogSWYgaXQgZmluZHMgb25lLCByZXR1cm4gYSB0ZXJtaW5hbCBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7QXJyYXl9IGF0dHJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259IHRlcm1pbmFsTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tUZXJtaW5hbERpcmVjdGl2ZXMoZWwsIGF0dHJzLCBvcHRpb25zKSB7XG4gIC8vIHNraXAgdi1wcmVcbiAgaWYgKGdldEF0dHIoZWwsICd2LXByZScpICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNraXA7XG4gIH1cbiAgLy8gc2tpcCB2LWVsc2UgYmxvY2ssIGJ1dCBvbmx5IGlmIGZvbGxvd2luZyB2LWlmXG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3YtZWxzZScpKSB7XG4gICAgdmFyIHByZXYgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIGlmIChwcmV2ICYmIHByZXYuaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICAgIHJldHVybiBza2lwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhdHRyLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBtYXRjaGVkLCBkaXJOYW1lLCByYXdOYW1lLCBhcmcsIGRlZiwgdGVybURlZjtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBhdHRycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgbmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICBpZiAobWF0Y2hlZCA9IG5hbWUubWF0Y2goZGlyQXR0clJFKSkge1xuICAgICAgZGVmID0gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdkaXJlY3RpdmVzJywgbWF0Y2hlZFsxXSk7XG4gICAgICBpZiAoZGVmICYmIGRlZi50ZXJtaW5hbCkge1xuICAgICAgICBpZiAoIXRlcm1EZWYgfHwgKGRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1RFUk1JTkFMX1BSSU9SSVRZKSA+IHRlcm1EZWYucHJpb3JpdHkpIHtcbiAgICAgICAgICB0ZXJtRGVmID0gZGVmO1xuICAgICAgICAgIHJhd05hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMoYXR0ci5uYW1lKTtcbiAgICAgICAgICB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgZGlyTmFtZSA9IG1hdGNoZWRbMV07XG4gICAgICAgICAgYXJnID0gbWF0Y2hlZFsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0ZXJtRGVmKSB7XG4gICAgcmV0dXJuIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIGRpck5hbWUsIHZhbHVlLCBvcHRpb25zLCB0ZXJtRGVmLCByYXdOYW1lLCBhcmcsIG1vZGlmaWVycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2tpcCgpIHt9XG5za2lwLnRlcm1pbmFsID0gdHJ1ZTtcblxuLyoqXG4gKiBCdWlsZCBhIG5vZGUgbGluayBmdW5jdGlvbiBmb3IgYSB0ZXJtaW5hbCBkaXJlY3RpdmUuXG4gKiBBIHRlcm1pbmFsIGxpbmsgZnVuY3Rpb24gdGVybWluYXRlcyB0aGUgY3VycmVudFxuICogY29tcGlsYXRpb24gcmVjdXJzaW9uIGFuZCBoYW5kbGVzIGNvbXBpbGF0aW9uIG9mIHRoZVxuICogc3VidHJlZSBpbiB0aGUgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBkaXJOYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Jhd05hbWVdXG4gKiBAcGFyYW0ge1N0cmluZ30gW2FyZ11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbbW9kaWZpZXJzXVxuICogQHJldHVybiB7RnVuY3Rpb259IHRlcm1pbmFsTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgZGlyTmFtZSwgdmFsdWUsIG9wdGlvbnMsIGRlZiwgcmF3TmFtZSwgYXJnLCBtb2RpZmllcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKHZhbHVlKTtcbiAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgbmFtZTogZGlyTmFtZSxcbiAgICBhcmc6IGFyZyxcbiAgICBleHByZXNzaW9uOiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICBmaWx0ZXJzOiBwYXJzZWQuZmlsdGVycyxcbiAgICByYXc6IHZhbHVlLFxuICAgIGF0dHI6IHJhd05hbWUsXG4gICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgZGVmOiBkZWZcbiAgfTtcbiAgLy8gY2hlY2sgcmVmIGZvciB2LWZvciBhbmQgcm91dGVyLXZpZXdcbiAgaWYgKGRpck5hbWUgPT09ICdmb3InIHx8IGRpck5hbWUgPT09ICdyb3V0ZXItdmlldycpIHtcbiAgICBkZXNjcmlwdG9yLnJlZiA9IGZpbmRSZWYoZWwpO1xuICB9XG4gIHZhciBmbiA9IGZ1bmN0aW9uIHRlcm1pbmFsTm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IucmVmKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSgoc2NvcGUgfHwgdm0pLiRyZWZzLCBkZXNjcmlwdG9yLnJlZiwgbnVsbCk7XG4gICAgfVxuICAgIHZtLl9iaW5kRGlyKGRlc2NyaXB0b3IsIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gIH07XG4gIGZuLnRlcm1pbmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIENvbXBpbGUgdGhlIGRpcmVjdGl2ZXMgb24gYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbGlua2VyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8TmFtZWROb2RlTWFwfSBhdHRyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVEaXJlY3RpdmVzKGF0dHJzLCBvcHRpb25zKSB7XG4gIHZhciBpID0gYXR0cnMubGVuZ3RoO1xuICB2YXIgZGlycyA9IFtdO1xuICB2YXIgYXR0ciwgbmFtZSwgdmFsdWUsIHJhd05hbWUsIHJhd1ZhbHVlLCBkaXJOYW1lLCBhcmcsIG1vZGlmaWVycywgZGlyRGVmLCB0b2tlbnMsIG1hdGNoZWQ7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgbmFtZSA9IHJhd05hbWUgPSBhdHRyLm5hbWU7XG4gICAgdmFsdWUgPSByYXdWYWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgdG9rZW5zID0gcGFyc2VUZXh0KHZhbHVlKTtcbiAgICAvLyByZXNldCBhcmdcbiAgICBhcmcgPSBudWxsO1xuICAgIC8vIGNoZWNrIG1vZGlmaWVyc1xuICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuXG4gICAgLy8gYXR0cmlidXRlIGludGVycG9sYXRpb25zXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgdmFsdWUgPSB0b2tlbnNUb0V4cCh0b2tlbnMpO1xuICAgICAgYXJnID0gbmFtZTtcbiAgICAgIHB1c2hEaXIoJ2JpbmQnLCBkaXJlY3RpdmVzLmJpbmQsIHRva2Vucyk7XG4gICAgICAvLyB3YXJuIGFnYWluc3QgbWl4aW5nIG11c3RhY2hlcyB3aXRoIHYtYmluZFxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChhdHRycywgZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gYXR0ci5uYW1lID09PSAnOmNsYXNzJyB8fCBhdHRyLm5hbWUgPT09ICd2LWJpbmQ6Y2xhc3MnO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdhcm4oJ2NsYXNzPVwiJyArIHJhd1ZhbHVlICsgJ1wiOiBEbyBub3QgbWl4IG11c3RhY2hlIGludGVycG9sYXRpb24gJyArICdhbmQgdi1iaW5kIGZvciBcImNsYXNzXCIgb24gdGhlIHNhbWUgZWxlbWVudC4gVXNlIG9uZSBvciB0aGUgb3RoZXIuJywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2VcblxuICAgICAgLy8gc3BlY2lhbCBhdHRyaWJ1dGU6IHRyYW5zaXRpb25cbiAgICAgIGlmICh0cmFuc2l0aW9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICBtb2RpZmllcnMubGl0ZXJhbCA9ICFiaW5kUkUudGVzdChuYW1lKTtcbiAgICAgICAgcHVzaERpcigndHJhbnNpdGlvbicsIGludGVybmFsRGlyZWN0aXZlcy50cmFuc2l0aW9uKTtcbiAgICAgIH0gZWxzZVxuXG4gICAgICAgIC8vIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICBhcmcgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICAgIHB1c2hEaXIoJ29uJywgZGlyZWN0aXZlcy5vbik7XG4gICAgICAgIH0gZWxzZVxuXG4gICAgICAgICAgLy8gYXR0cmlidXRlIGJpbmRpbmdzXG4gICAgICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBkaXJOYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICAgICAgaWYgKGRpck5hbWUgPT09ICdzdHlsZScgfHwgZGlyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICBwdXNoRGlyKGRpck5hbWUsIGludGVybmFsRGlyZWN0aXZlc1tkaXJOYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhcmcgPSBkaXJOYW1lO1xuICAgICAgICAgICAgICBwdXNoRGlyKCdiaW5kJywgZGlyZWN0aXZlcy5iaW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcblxuICAgICAgICAgICAgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIGlmIChtYXRjaGVkID0gbmFtZS5tYXRjaChkaXJBdHRyUkUpKSB7XG4gICAgICAgICAgICAgIGRpck5hbWUgPSBtYXRjaGVkWzFdO1xuICAgICAgICAgICAgICBhcmcgPSBtYXRjaGVkWzJdO1xuXG4gICAgICAgICAgICAgIC8vIHNraXAgdi1lbHNlICh3aGVuIHVzZWQgd2l0aCB2LXNob3cpXG4gICAgICAgICAgICAgIGlmIChkaXJOYW1lID09PSAnZWxzZScpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRpckRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpck5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICBpZiAoZGlyRGVmKSB7XG4gICAgICAgICAgICAgICAgcHVzaERpcihkaXJOYW1lLCBkaXJEZWYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVzaCBhIGRpcmVjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpck5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IGRlZlxuICAgKiBAcGFyYW0ge0FycmF5fSBbaW50ZXJwVG9rZW5zXVxuICAgKi9cblxuICBmdW5jdGlvbiBwdXNoRGlyKGRpck5hbWUsIGRlZiwgaW50ZXJwVG9rZW5zKSB7XG4gICAgdmFyIGhhc09uZVRpbWVUb2tlbiA9IGludGVycFRva2VucyAmJiBoYXNPbmVUaW1lKGludGVycFRva2Vucyk7XG4gICAgdmFyIHBhcnNlZCA9ICFoYXNPbmVUaW1lVG9rZW4gJiYgcGFyc2VEaXJlY3RpdmUodmFsdWUpO1xuICAgIGRpcnMucHVzaCh7XG4gICAgICBuYW1lOiBkaXJOYW1lLFxuICAgICAgYXR0cjogcmF3TmFtZSxcbiAgICAgIHJhdzogcmF3VmFsdWUsXG4gICAgICBkZWY6IGRlZixcbiAgICAgIGFyZzogYXJnLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICAvLyBjb252ZXJzaW9uIGZyb20gaW50ZXJwb2xhdGlvbiBzdHJpbmdzIHdpdGggb25lLXRpbWUgdG9rZW5cbiAgICAgIC8vIHRvIGV4cHJlc3Npb24gaXMgZGlmZmVyZWQgdW50aWwgZGlyZWN0aXZlIGJpbmQgdGltZSBzbyB0aGF0IHdlXG4gICAgICAvLyBoYXZlIGFjY2VzcyB0byB0aGUgYWN0dWFsIHZtIGNvbnRleHQgZm9yIG9uZS10aW1lIGJpbmRpbmdzLlxuICAgICAgZXhwcmVzc2lvbjogcGFyc2VkICYmIHBhcnNlZC5leHByZXNzaW9uLFxuICAgICAgZmlsdGVyczogcGFyc2VkICYmIHBhcnNlZC5maWx0ZXJzLFxuICAgICAgaW50ZXJwOiBpbnRlcnBUb2tlbnMsXG4gICAgICBoYXNPbmVUaW1lOiBoYXNPbmVUaW1lVG9rZW5cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChkaXJzLmxlbmd0aCkge1xuICAgIHJldHVybiBtYWtlTm9kZUxpbmtGbihkaXJzKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIG1vZGlmaWVycyBmcm9tIGRpcmVjdGl2ZSBhdHRyaWJ1dGUgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzKG5hbWUpIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBpID0gbWF0Y2gubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHJlc1ttYXRjaFtpXS5zbGljZSgxKV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgbGluayBmdW5jdGlvbiBmb3IgYWxsIGRpcmVjdGl2ZXMgb24gYSBzaW5nbGUgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJlY3RpdmVzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gZGlyZWN0aXZlc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VOb2RlTGlua0ZuKGRpcmVjdGl2ZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIC8vIHJldmVyc2UgYXBwbHkgYmVjYXVzZSBpdCdzIHNvcnRlZCBsb3cgdG8gaGlnaFxuICAgIHZhciBpID0gZGlyZWN0aXZlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX2JpbmREaXIoZGlyZWN0aXZlc1tpXSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gaW50ZXJwb2xhdGlvbiBzdHJpbmcgY29udGFpbnMgb25lLXRpbWUgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHRva2Vuc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXNPbmVUaW1lKHRva2Vucykge1xuICB2YXIgaSA9IHRva2Vucy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodG9rZW5zW2ldLm9uZVRpbWUpIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2NyaXB0KGVsKSB7XG4gIHJldHVybiBlbC50YWdOYW1lID09PSAnU0NSSVBUJyAmJiAoIWVsLmhhc0F0dHJpYnV0ZSgndHlwZScpIHx8IGVsLmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAndGV4dC9qYXZhc2NyaXB0Jyk7XG59XG5cbnZhciBzcGVjaWFsQ2hhclJFID0gL1teXFx3XFwtOlxcLl0vO1xuXG4vKipcbiAqIFByb2Nlc3MgYW4gZWxlbWVudCBvciBhIERvY3VtZW50RnJhZ21lbnQgYmFzZWQgb24gYVxuICogaW5zdGFuY2Ugb3B0aW9uIG9iamVjdC4gVGhpcyBhbGxvd3MgdXMgdG8gdHJhbnNjbHVkZVxuICogYSB0ZW1wbGF0ZSBub2RlL2ZyYWdtZW50IGJlZm9yZSB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCxcbiAqIHNvIHRoZSBwcm9jZXNzZWQgZnJhZ21lbnQgY2FuIHRoZW4gYmUgY2xvbmVkIGFuZCByZXVzZWRcbiAqIGluIHYtZm9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gdHJhbnNjbHVkZShlbCwgb3B0aW9ucykge1xuICAvLyBleHRyYWN0IGNvbnRhaW5lciBhdHRyaWJ1dGVzIHRvIHBhc3MgdGhlbSBkb3duXG4gIC8vIHRvIGNvbXBpbGVyLCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSBjb21waWxlZCBpblxuICAvLyBwYXJlbnQgc2NvcGUuIHdlIGFyZSBtdXRhdGluZyB0aGUgb3B0aW9ucyBvYmplY3QgaGVyZVxuICAvLyBhc3N1bWluZyB0aGUgc2FtZSBvYmplY3Qgd2lsbCBiZSB1c2VkIGZvciBjb21waWxlXG4gIC8vIHJpZ2h0IGFmdGVyIHRoaXMuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5fY29udGFpbmVyQXR0cnMgPSBleHRyYWN0QXR0cnMoZWwpO1xuICB9XG4gIC8vIGZvciB0ZW1wbGF0ZSB0YWdzLCB3aGF0IHdlIHdhbnQgaXMgaXRzIGNvbnRlbnQgYXNcbiAgLy8gYSBkb2N1bWVudEZyYWdtZW50IChmb3IgZnJhZ21lbnQgaW5zdGFuY2VzKVxuICBpZiAoaXNUZW1wbGF0ZShlbCkpIHtcbiAgICBlbCA9IHBhcnNlVGVtcGxhdGUoZWwpO1xuICB9XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50ICYmICFvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLnRlbXBsYXRlID0gJzxzbG90Pjwvc2xvdD4nO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgICAgb3B0aW9ucy5fY29udGVudCA9IGV4dHJhY3RDb250ZW50KGVsKTtcbiAgICAgIGVsID0gdHJhbnNjbHVkZVRlbXBsYXRlKGVsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRnJhZ21lbnQoZWwpKSB7XG4gICAgLy8gYW5jaG9ycyBmb3IgZnJhZ21lbnQgaW5zdGFuY2VcbiAgICAvLyBwYXNzaW5nIGluIGBwZXJzaXN0OiB0cnVlYCB0byBhdm9pZCB0aGVtIGJlaW5nXG4gICAgLy8gZGlzY2FyZGVkIGJ5IElFIGR1cmluZyB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgcHJlcGVuZChjcmVhdGVBbmNob3IoJ3Ytc3RhcnQnLCB0cnVlKSwgZWwpO1xuICAgIGVsLmFwcGVuZENoaWxkKGNyZWF0ZUFuY2hvcigndi1lbmQnLCB0cnVlKSk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlIG9wdGlvbi5cbiAqIElmIHRoZSByZXBsYWNlIG9wdGlvbiBpcyB0cnVlIHRoaXMgd2lsbCBzd2FwIHRoZSAkZWwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2NsdWRlVGVtcGxhdGUoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgdmFyIGZyYWcgPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0cnVlKTtcbiAgaWYgKGZyYWcpIHtcbiAgICB2YXIgcmVwbGFjZXIgPSBmcmFnLmZpcnN0Q2hpbGQ7XG4gICAgdmFyIHRhZyA9IHJlcGxhY2VyLnRhZ05hbWUgJiYgcmVwbGFjZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignWW91IGFyZSBtb3VudGluZyBhbiBpbnN0YW5jZSB3aXRoIGEgdGVtcGxhdGUgdG8gJyArICc8Ym9keT4uIFRoaXMgd2lsbCByZXBsYWNlIDxib2R5PiBlbnRpcmVseS4gWW91ICcgKyAnc2hvdWxkIHByb2JhYmx5IHVzZSBgcmVwbGFjZTogZmFsc2VgIGhlcmUuJyk7XG4gICAgICB9XG4gICAgICAvLyB0aGVyZSBhcmUgbWFueSBjYXNlcyB3aGVyZSB0aGUgaW5zdGFuY2UgbXVzdFxuICAgICAgLy8gYmVjb21lIGEgZnJhZ21lbnQgaW5zdGFuY2U6IGJhc2ljYWxseSBhbnl0aGluZyB0aGF0XG4gICAgICAvLyBjYW4gY3JlYXRlIG1vcmUgdGhhbiAxIHJvb3Qgbm9kZXMuXG4gICAgICBpZiAoXG4gICAgICAvLyBtdWx0aS1jaGlsZHJlbiB0ZW1wbGF0ZVxuICAgICAgZnJhZy5jaGlsZE5vZGVzLmxlbmd0aCA+IDEgfHxcbiAgICAgIC8vIG5vbi1lbGVtZW50IHRlbXBsYXRlXG4gICAgICByZXBsYWNlci5ub2RlVHlwZSAhPT0gMSB8fFxuICAgICAgLy8gc2luZ2xlIG5lc3RlZCBjb21wb25lbnRcbiAgICAgIHRhZyA9PT0gJ2NvbXBvbmVudCcgfHwgcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSB8fCBoYXNCaW5kQXR0cihyZXBsYWNlciwgJ2lzJykgfHxcbiAgICAgIC8vIGVsZW1lbnQgZGlyZWN0aXZlXG4gICAgICByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2VsZW1lbnREaXJlY3RpdmVzJywgdGFnKSB8fFxuICAgICAgLy8gZm9yIGJsb2NrXG4gICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtZm9yJykgfHxcbiAgICAgIC8vIGlmIGJsb2NrXG4gICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuX3JlcGxhY2VyQXR0cnMgPSBleHRyYWN0QXR0cnMocmVwbGFjZXIpO1xuICAgICAgICBtZXJnZUF0dHJzKGVsLCByZXBsYWNlcik7XG4gICAgICAgIHJldHVybiByZXBsYWNlcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246ICcgKyB0ZW1wbGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZXh0cmFjdCBhIGNvbXBvbmVudCBjb250YWluZXIncyBhdHRyaWJ1dGVzXG4gKiBpbnRvIGEgcGxhaW4gb2JqZWN0IGFycmF5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RBdHRycyhlbCkge1xuICBpZiAoZWwubm9kZVR5cGUgPT09IDEgJiYgZWwuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoZWwuYXR0cmlidXRlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0aGUgYXR0cmlidXRlcyBvZiB0d28gZWxlbWVudHMsIGFuZCBtYWtlIHN1cmVcbiAqIHRoZSBjbGFzcyBuYW1lcyBhcmUgbWVyZ2VkIHByb3Blcmx5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbVxuICogQHBhcmFtIHtFbGVtZW50fSB0b1xuICovXG5cbmZ1bmN0aW9uIG1lcmdlQXR0cnMoZnJvbSwgdG8pIHtcbiAgdmFyIGF0dHJzID0gZnJvbS5hdHRyaWJ1dGVzO1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aDtcbiAgdmFyIG5hbWUsIHZhbHVlO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgdmFsdWUgPSBhdHRyc1tpXS52YWx1ZTtcbiAgICBpZiAoIXRvLmhhc0F0dHJpYnV0ZShuYW1lKSAmJiAhc3BlY2lhbENoYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICB0by5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzJyAmJiAhcGFyc2VUZXh0KHZhbHVlKSAmJiAodmFsdWUgPSB2YWx1ZS50cmltKCkpKSB7XG4gICAgICB2YWx1ZS5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgICBhZGRDbGFzcyh0bywgY2xzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNjYW4gYW5kIGRldGVybWluZSBzbG90IGNvbnRlbnQgZGlzdHJpYnV0aW9uLlxuICogV2UgZG8gdGhpcyBkdXJpbmcgdHJhbnNjbHVzaW9uIGluc3RlYWQgYXQgY29tcGlsZSB0aW1lIHNvIHRoYXRcbiAqIHRoZSBkaXN0cmlidXRpb24gaXMgZGVjb3VwbGVkIGZyb20gdGhlIGNvbXBpbGF0aW9uIG9yZGVyIG9mXG4gKiB0aGUgc2xvdHMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRlbnRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyh2bSwgY29udGVudCkge1xuICBpZiAoIWNvbnRlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNvbnRlbnRzID0gdm0uX3Nsb3RDb250ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBlbCwgbmFtZTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZW50LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGVsID0gY29udGVudC5jaGlsZHJlbltpXTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGlmIChuYW1lID0gZWwuZ2V0QXR0cmlidXRlKCdzbG90JykpIHtcbiAgICAgIChjb250ZW50c1tuYW1lXSB8fCAoY29udGVudHNbbmFtZV0gPSBbXSkpLnB1c2goZWwpO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0QmluZEF0dHIoZWwsICdzbG90JykpIHtcbiAgICAgIHdhcm4oJ1RoZSBcInNsb3RcIiBhdHRyaWJ1dGUgbXVzdCBiZSBzdGF0aWMuJywgdm0uJHBhcmVudCk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBjb250ZW50cykge1xuICAgIGNvbnRlbnRzW25hbWVdID0gZXh0cmFjdEZyYWdtZW50KGNvbnRlbnRzW25hbWVdLCBjb250ZW50KTtcbiAgfVxuICBpZiAoY29udGVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICB2YXIgbm9kZXMgPSBjb250ZW50LmNoaWxkTm9kZXM7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBub2Rlc1swXS5ub2RlVHlwZSA9PT0gMyAmJiAhbm9kZXNbMF0uZGF0YS50cmltKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGVudHNbJ2RlZmF1bHQnXSA9IGV4dHJhY3RGcmFnbWVudChjb250ZW50LmNoaWxkTm9kZXMsIGNvbnRlbnQpO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBxdWFsaWZpZWQgY29udGVudCBub2RlcyBmcm9tIGEgbm9kZSBsaXN0LlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVzXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RGcmFnbWVudChub2RlcywgcGFyZW50KSB7XG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBub2RlcyA9IHRvQXJyYXkobm9kZXMpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKGlzVGVtcGxhdGUobm9kZSkgJiYgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWlmJykgJiYgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWZvcicpKSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICBub2RlID0gcGFyc2VUZW1wbGF0ZShub2RlLCB0cnVlKTtcbiAgICB9XG4gICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgfVxuICByZXR1cm4gZnJhZztcbn1cblxuXG5cbnZhciBjb21waWxlciA9IE9iamVjdC5mcmVlemUoe1xuXHRjb21waWxlOiBjb21waWxlLFxuXHRjb21waWxlQW5kTGlua1Byb3BzOiBjb21waWxlQW5kTGlua1Byb3BzLFxuXHRjb21waWxlUm9vdDogY29tcGlsZVJvb3QsXG5cdHRyYW5zY2x1ZGU6IHRyYW5zY2x1ZGUsXG5cdHJlc29sdmVTbG90czogcmVzb2x2ZVNsb3RzXG59KTtcblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBBY2Nlc3NvciBmb3IgYCRkYXRhYCBwcm9wZXJ0eSwgc2luY2Ugc2V0dGluZyAkZGF0YVxuICAgKiByZXF1aXJlcyBvYnNlcnZpbmcgdGhlIG5ldyBvYmplY3QgYW5kIHVwZGF0aW5nXG4gICAqIHByb3hpZWQgcHJvcGVydGllcy5cbiAgICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3RGF0YSkge1xuICAgICAgaWYgKG5ld0RhdGEgIT09IHRoaXMuX2RhdGEpIHtcbiAgICAgICAgdGhpcy5fc2V0RGF0YShuZXdEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTZXR1cCB0aGUgc2NvcGUgb2YgYW4gaW5zdGFuY2UsIHdoaWNoIGNvbnRhaW5zOlxuICAgKiAtIG9ic2VydmVkIGRhdGFcbiAgICogLSBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAqIC0gdXNlciBtZXRob2RzXG4gICAqIC0gbWV0YSBwcm9wZXJ0aWVzXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbml0UHJvcHMoKTtcbiAgICB0aGlzLl9pbml0TWV0YSgpO1xuICAgIHRoaXMuX2luaXRNZXRob2RzKCk7XG4gICAgdGhpcy5faW5pdERhdGEoKTtcbiAgICB0aGlzLl9pbml0Q29tcHV0ZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBwcm9wcy5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdFByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICB2YXIgZWwgPSBvcHRpb25zLmVsO1xuICAgIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gICAgaWYgKHByb3BzICYmICFlbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdQcm9wcyB3aWxsIG5vdCBiZSBjb21waWxlZCBpZiBubyBgZWxgIG9wdGlvbiBpcyAnICsgJ3Byb3ZpZGVkIGF0IGluc3RhbnRpYXRpb24uJywgdGhpcyk7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0byBjb252ZXJ0IHN0cmluZyBzZWxlY3RvcnMgaW50byBlbGVtZW50IG5vd1xuICAgIGVsID0gb3B0aW9ucy5lbCA9IHF1ZXJ5KGVsKTtcbiAgICB0aGlzLl9wcm9wc1VubGlua0ZuID0gZWwgJiYgZWwubm9kZVR5cGUgPT09IDEgJiYgcHJvcHNcbiAgICAvLyBwcm9wcyBtdXN0IGJlIGxpbmtlZCBpbiBwcm9wZXIgc2NvcGUgaWYgaW5zaWRlIHYtZm9yXG4gICAgPyBjb21waWxlQW5kTGlua1Byb3BzKHRoaXMsIGVsLCBwcm9wcywgdGhpcy5fc2NvcGUpIDogbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgZGF0YS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFGbiA9IHRoaXMuJG9wdGlvbnMuZGF0YTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEgPSBkYXRhRm4gPyBkYXRhRm4oKSA6IHt9O1xuICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4nLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdGhpcy5fcHJvcHM7XG4gICAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgdmFyIGksIGtleTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vIHRoZXJlIGFyZSB0d28gc2NlbmFyaW9zIHdoZXJlIHdlIGNhbiBwcm94eSBhIGRhdGEga2V5OlxuICAgICAgLy8gMS4gaXQncyBub3QgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcFxuICAgICAgLy8gMi4gaXQncyBwcm92aWRlZCB2aWEgYSBpbnN0YW50aWF0aW9uIG9wdGlvbiBBTkQgdGhlcmUgYXJlIG5vXG4gICAgICAvLyAgICB0ZW1wbGF0ZSBwcm9wIHByZXNlbnRcbiAgICAgIGlmICghcHJvcHMgfHwgIWhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB0aGlzLl9wcm94eShrZXkpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ0RhdGEgZmllbGQgXCInICsga2V5ICsgJ1wiIGlzIGFscmVhZHkgZGVmaW5lZCAnICsgJ2FzIGEgcHJvcC4gVG8gcHJvdmlkZSBkZWZhdWx0IHZhbHVlIGZvciBhIHByb3AsIHVzZSB0aGUgXCJkZWZhdWx0XCIgJyArICdwcm9wIG9wdGlvbjsgaWYgeW91IHdhbnQgdG8gcGFzcyBwcm9wIHZhbHVlcyB0byBhbiBpbnN0YW50aWF0aW9uICcgKyAnY2FsbCwgdXNlIHRoZSBcInByb3BzRGF0YVwiIG9wdGlvbi4nLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb2JzZXJ2ZSBkYXRhXG4gICAgb2JzZXJ2ZShkYXRhLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogU3dhcCB0aGUgaW5zdGFuY2UncyAkZGF0YS4gQ2FsbGVkIGluICRkYXRhJ3Mgc2V0dGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbmV3RGF0YVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9zZXREYXRhID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICBuZXdEYXRhID0gbmV3RGF0YSB8fCB7fTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdGhpcy5fZGF0YSA9IG5ld0RhdGE7XG4gICAgdmFyIGtleXMsIGtleSwgaTtcbiAgICAvLyB1bnByb3h5IGtleXMgbm90IHByZXNlbnQgaW4gbmV3IGRhdGFcbiAgICBrZXlzID0gT2JqZWN0LmtleXMob2xkRGF0YSk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIShrZXkgaW4gbmV3RGF0YSkpIHtcbiAgICAgICAgdGhpcy5fdW5wcm94eShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwcm94eSBrZXlzIG5vdCBhbHJlYWR5IHByb3hpZWQsXG4gICAgLy8gYW5kIHRyaWdnZXIgY2hhbmdlIGZvciBjaGFuZ2VkIHZhbHVlc1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhuZXdEYXRhKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghaGFzT3duKHRoaXMsIGtleSkpIHtcbiAgICAgICAgLy8gbmV3IHByb3BlcnR5XG4gICAgICAgIHRoaXMuX3Byb3h5KGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIG9sZERhdGEuX19vYl9fLnJlbW92ZVZtKHRoaXMpO1xuICAgIG9ic2VydmUobmV3RGF0YSwgdGhpcyk7XG4gICAgdGhpcy5fZGlnZXN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3h5IGEgcHJvcGVydHksIHNvIHRoYXRcbiAgICogdm0ucHJvcCA9PT0gdm0uX2RhdGEucHJvcFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAvLyBuZWVkIHRvIHN0b3JlIHJlZiB0byBzZWxmIGhlcmVcbiAgICAgIC8vIGJlY2F1c2UgdGhlc2UgZ2V0dGVyL3NldHRlcnMgbWlnaHRcbiAgICAgIC8vIGJlIGNhbGxlZCBieSBjaGlsZCBzY29wZXMgdmlhXG4gICAgICAvLyBwcm90b3R5cGUgaW5oZXJpdGFuY2UuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBwcm94eUdldHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fZGF0YVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHByb3h5U2V0dGVyKHZhbCkge1xuICAgICAgICAgIHNlbGYuX2RhdGFba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbnByb3h5IGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fdW5wcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlIHVwZGF0ZSBvbiBldmVyeSB3YXRjaGVyIGluIHNjb3BlLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl93YXRjaGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuX3dhdGNoZXJzW2ldLnVwZGF0ZSh0cnVlKTsgLy8gc2hhbGxvdyB1cGRhdGVzXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXR1cCBjb21wdXRlZCBwcm9wZXJ0aWVzLiBUaGV5IGFyZSBlc3NlbnRpYWxseVxuICAgKiBzcGVjaWFsIGdldHRlci9zZXR0ZXJzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICBWdWUucHJvdG90eXBlLl9pbml0Q29tcHV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gdGhpcy4kb3B0aW9ucy5jb21wdXRlZDtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgICAgIHZhciBkZWYgPSB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmLmdldCA9IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLCB0aGlzKTtcbiAgICAgICAgICBkZWYuc2V0ID0gbm9vcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWYuZ2V0ID0gdXNlckRlZi5nZXQgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZSA/IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLmdldCwgdGhpcykgOiBiaW5kKHVzZXJEZWYuZ2V0LCB0aGlzKSA6IG5vb3A7XG4gICAgICAgICAgZGVmLnNldCA9IHVzZXJEZWYuc2V0ID8gYmluZCh1c2VyRGVmLnNldCwgdGhpcykgOiBub29wO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIGRlZik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VDb21wdXRlZEdldHRlcihnZXR0ZXIsIG93bmVyKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBudWxsLCB7XG4gICAgICBsYXp5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgaW5zdGFuY2UgbWV0aG9kcy4gTWV0aG9kcyBtdXN0IGJlIGJvdW5kIHRvIHRoZVxuICAgKiBpbnN0YW5jZSBzaW5jZSB0aGV5IG1pZ2h0IGJlIHBhc3NlZCBkb3duIGFzIGEgcHJvcCB0b1xuICAgKiBjaGlsZCBjb21wb25lbnRzLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0TWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0aG9kcyA9IHRoaXMuJG9wdGlvbnMubWV0aG9kcztcbiAgICBpZiAobWV0aG9kcykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAgdGhpc1trZXldID0gYmluZChtZXRob2RzW2tleV0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBtZXRhIGluZm9ybWF0aW9uIGxpa2UgJGluZGV4LCAka2V5ICYgJHZhbHVlLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0TWV0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0YXMgPSB0aGlzLiRvcHRpb25zLl9tZXRhO1xuICAgIGlmIChtZXRhcykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGFzKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHRoaXMsIGtleSwgbWV0YXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZXZlbnRSRSA9IC9edi1vbjp8XkAvO1xuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBTZXR1cCB0aGUgaW5zdGFuY2UncyBvcHRpb24gZXZlbnRzICYgd2F0Y2hlcnMuXG4gICAqIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgd2UgcHVsbCBpdCBmcm9tIHRoZVxuICAgKiBpbnN0YW5jZSdzIG1ldGhvZHMgYnkgbmFtZS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgICByZWdpc3RlckNvbXBvbmVudEV2ZW50cyh0aGlzLCBvcHRpb25zLmVsKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJDYWxsYmFja3ModGhpcywgJyRvbicsIG9wdGlvbnMuZXZlbnRzKTtcbiAgICByZWdpc3RlckNhbGxiYWNrcyh0aGlzLCAnJHdhdGNoJywgb3B0aW9ucy53YXRjaCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHYtb24gZXZlbnRzIG9uIGEgY2hpbGQgY29tcG9uZW50XG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50RXZlbnRzKHZtLCBlbCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJpYnV0ZXM7XG4gICAgdmFyIG5hbWUsIHZhbHVlLCBoYW5kbGVyO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBuYW1lID0gYXR0cnNbaV0ubmFtZTtcbiAgICAgIGlmIChldmVudFJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShldmVudFJFLCAnJyk7XG4gICAgICAgIC8vIGZvcmNlIHRoZSBleHByZXNzaW9uIGludG8gYSBzdGF0ZW1lbnQgc28gdGhhdFxuICAgICAgICAvLyBpdCBhbHdheXMgZHluYW1pY2FsbHkgcmVzb2x2ZXMgdGhlIG1ldGhvZCB0byBjYWxsICgjMjY3MClcbiAgICAgICAgLy8ga2luZGEgdWdseSBoYWNrLCBidXQgZG9lcyB0aGUgam9iLlxuICAgICAgICB2YWx1ZSA9IGF0dHJzW2ldLnZhbHVlO1xuICAgICAgICBpZiAoaXNTaW1wbGVQYXRoKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlICs9ICcuYXBwbHkodGhpcywgJGFyZ3VtZW50cyknO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXIgPSAodm0uX3Njb3BlIHx8IHZtLl9jb250ZXh0KS4kZXZhbCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIGhhbmRsZXIuX2Zyb21QYXJlbnQgPSB0cnVlO1xuICAgICAgICB2bS4kb24obmFtZS5yZXBsYWNlKGV2ZW50UkUpLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgY2FsbGJhY2tzIGZvciBvcHRpb24gZXZlbnRzIGFuZCB3YXRjaGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGhhc2hcbiAgICovXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJDYWxsYmFja3Modm0sIGFjdGlvbiwgaGFzaCkge1xuICAgIGlmICghaGFzaCkgcmV0dXJuO1xuICAgIHZhciBoYW5kbGVycywga2V5LCBpLCBqO1xuICAgIGZvciAoa2V5IGluIGhhc2gpIHtcbiAgICAgIGhhbmRsZXJzID0gaGFzaFtrZXldO1xuICAgICAgaWYgKGlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVycyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byByZWdpc3RlciBhbiBldmVudC93YXRjaCBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ3xPYmplY3R9IGhhbmRsZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cblxuICBmdW5jdGlvbiByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBoYW5kbGVyO1xuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2bVthY3Rpb25dKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICAgICAgdmFyIG1ldGhvZCA9IG1ldGhvZHMgJiYgbWV0aG9kc1toYW5kbGVyXTtcbiAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgdm1bYWN0aW9uXShrZXksIG1ldGhvZCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1Vua25vd24gbWV0aG9kOiBcIicgKyBoYW5kbGVyICsgJ1wiIHdoZW4gJyArICdyZWdpc3RlcmluZyBjYWxsYmFjayBmb3IgJyArIGFjdGlvbiArICc6IFwiJyArIGtleSArICdcIi4nLCB2bSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyICYmIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXIuaGFuZGxlciwgaGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIHJlY3Vyc2l2ZSBhdHRhY2hlZC9kZXRhY2hlZCBjYWxsc1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RE9NSG9va3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kb24oJ2hvb2s6YXR0YWNoZWQnLCBvbkF0dGFjaGVkKTtcbiAgICB0aGlzLiRvbignaG9vazpkZXRhY2hlZCcsIG9uRGV0YWNoZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byByZWN1cnNpdmVseSBjYWxsIGF0dGFjaGVkIGhvb2sgb24gY2hpbGRyZW5cbiAgICovXG5cbiAgZnVuY3Rpb24gb25BdHRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChjYWxsQXR0YWNoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0b3IgdG8gY2FsbCBhdHRhY2hlZCBob29rXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICAgKi9cblxuICBmdW5jdGlvbiBjYWxsQXR0YWNoKGNoaWxkKSB7XG4gICAgaWYgKCFjaGlsZC5faXNBdHRhY2hlZCAmJiBpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgICBjaGlsZC5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgZGV0YWNoZWQgaG9vayBvbiBjaGlsZHJlblxuICAgKi9cblxuICBmdW5jdGlvbiBvbkRldGFjaGVkKCkge1xuICAgIGlmICh0aGlzLl9pc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl9pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNhbGxEZXRhY2gpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRvciB0byBjYWxsIGRldGFjaGVkIGhvb2tcbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhbGxEZXRhY2goY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQuX2lzQXR0YWNoZWQgJiYgIWluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBhbGwgaGFuZGxlcnMgZm9yIGEgaG9va1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaG9va1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9jYWxsSG9vayA9IGZ1bmN0aW9uIChob29rKSB7XG4gICAgdGhpcy4kZW1pdCgncHJlLWhvb2s6JyArIGhvb2spO1xuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuJG9wdGlvbnNbaG9va107XG4gICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCQxKCkge31cblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSBsaW5rcyBhIERPTSBlbGVtZW50IHdpdGggYSBwaWVjZSBvZiBkYXRhLFxuICogd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIGFuIGV4cHJlc3Npb24uXG4gKiBJdCByZWdpc3RlcnMgYSB3YXRjaGVyIHdpdGggdGhlIGV4cHJlc3Npb24gYW5kIGNhbGxzXG4gKiB0aGUgRE9NIHVwZGF0ZSBmdW5jdGlvbiB3aGVuIGEgY2hhbmdlIGlzIHRyaWdnZXJlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvclxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gbmFtZVxuICogICAgICAgICAgICAgICAgIC0ge09iamVjdH0gZGVmXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBleHByZXNzaW9uXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXk8T2JqZWN0Pn0gW2ZpbHRlcnNdXG4gKiAgICAgICAgICAgICAgICAgLSB7T2JqZWN0fSBbbW9kaWZpZXJzXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGxpdGVyYWxcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGF0dHJcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGFyZ1xuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gcmF3XG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBbcmVmXVxuICogICAgICAgICAgICAgICAgIC0ge0FycmF5PE9iamVjdD59IFtpbnRlcnBdXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW2hhc09uZVRpbWVdXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSB0cmFuc2NsdXNpb24gaG9zdCBjb21wb25lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIG93bmVyIGZyYWdtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRGlyZWN0aXZlKGRlc2NyaXB0b3IsIHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgdGhpcy52bSA9IHZtO1xuICB0aGlzLmVsID0gZWw7XG4gIC8vIGNvcHkgZGVzY3JpcHRvciBwcm9wZXJ0aWVzXG4gIHRoaXMuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3I7XG4gIHRoaXMubmFtZSA9IGRlc2NyaXB0b3IubmFtZTtcbiAgdGhpcy5leHByZXNzaW9uID0gZGVzY3JpcHRvci5leHByZXNzaW9uO1xuICB0aGlzLmFyZyA9IGRlc2NyaXB0b3IuYXJnO1xuICB0aGlzLm1vZGlmaWVycyA9IGRlc2NyaXB0b3IubW9kaWZpZXJzO1xuICB0aGlzLmZpbHRlcnMgPSBkZXNjcmlwdG9yLmZpbHRlcnM7XG4gIHRoaXMubGl0ZXJhbCA9IHRoaXMubW9kaWZpZXJzICYmIHRoaXMubW9kaWZpZXJzLmxpdGVyYWw7XG4gIC8vIHByaXZhdGVcbiAgdGhpcy5fbG9ja2VkID0gZmFsc2U7XG4gIHRoaXMuX2JvdW5kID0gZmFsc2U7XG4gIHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XG4gIC8vIGxpbmsgY29udGV4dFxuICB0aGlzLl9ob3N0ID0gaG9zdDtcbiAgdGhpcy5fc2NvcGUgPSBzY29wZTtcbiAgdGhpcy5fZnJhZyA9IGZyYWc7XG4gIC8vIHN0b3JlIGRpcmVjdGl2ZXMgb24gbm9kZSBpbiBkZXYgbW9kZVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsKSB7XG4gICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMgPSB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcyB8fCBbXTtcbiAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcy5wdXNoKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZGlyZWN0aXZlLCBtaXhpbiBkZWZpbml0aW9uIHByb3BlcnRpZXMsXG4gKiBzZXR1cCB0aGUgd2F0Y2hlciwgY2FsbCBkZWZpbml0aW9uIGJpbmQoKSBhbmQgdXBkYXRlKClcbiAqIGlmIHByZXNlbnQuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG4gIHZhciBkZXNjcmlwdG9yID0gdGhpcy5kZXNjcmlwdG9yO1xuXG4gIC8vIHJlbW92ZSBhdHRyaWJ1dGVcbiAgaWYgKChuYW1lICE9PSAnY2xvYWsnIHx8IHRoaXMudm0uX2lzQ29tcGlsZWQpICYmIHRoaXMuZWwgJiYgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICB2YXIgYXR0ciA9IGRlc2NyaXB0b3IuYXR0ciB8fCAndi0nICsgbmFtZTtcbiAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgfVxuXG4gIC8vIGNvcHkgZGVmIHByb3BlcnRpZXNcbiAgdmFyIGRlZiA9IGRlc2NyaXB0b3IuZGVmO1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMudXBkYXRlID0gZGVmO1xuICB9IGVsc2Uge1xuICAgIGV4dGVuZCh0aGlzLCBkZWYpO1xuICB9XG5cbiAgLy8gc2V0dXAgZGlyZWN0aXZlIHBhcmFtc1xuICB0aGlzLl9zZXR1cFBhcmFtcygpO1xuXG4gIC8vIGluaXRpYWwgYmluZFxuICBpZiAodGhpcy5iaW5kKSB7XG4gICAgdGhpcy5iaW5kKCk7XG4gIH1cbiAgdGhpcy5fYm91bmQgPSB0cnVlO1xuXG4gIGlmICh0aGlzLmxpdGVyYWwpIHtcbiAgICB0aGlzLnVwZGF0ZSAmJiB0aGlzLnVwZGF0ZShkZXNjcmlwdG9yLnJhdyk7XG4gIH0gZWxzZSBpZiAoKHRoaXMuZXhwcmVzc2lvbiB8fCB0aGlzLm1vZGlmaWVycykgJiYgKHRoaXMudXBkYXRlIHx8IHRoaXMudHdvV2F5KSAmJiAhdGhpcy5fY2hlY2tTdGF0ZW1lbnQoKSkge1xuICAgIC8vIHdyYXBwZWQgdXBkYXRlciBmb3IgY29udGV4dFxuICAgIHZhciBkaXIgPSB0aGlzO1xuICAgIGlmICh0aGlzLnVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XG4gICAgICAgIGlmICghZGlyLl9sb2NrZWQpIHtcbiAgICAgICAgICBkaXIudXBkYXRlKHZhbCwgb2xkVmFsKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlID0gbm9vcCQxO1xuICAgIH1cbiAgICB2YXIgcHJlUHJvY2VzcyA9IHRoaXMuX3ByZVByb2Nlc3MgPyBiaW5kKHRoaXMuX3ByZVByb2Nlc3MsIHRoaXMpIDogbnVsbDtcbiAgICB2YXIgcG9zdFByb2Nlc3MgPSB0aGlzLl9wb3N0UHJvY2VzcyA/IGJpbmQodGhpcy5fcG9zdFByb2Nlc3MsIHRoaXMpIDogbnVsbDtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih0aGlzLnZtLCB0aGlzLmV4cHJlc3Npb24sIHRoaXMuX3VwZGF0ZSwgLy8gY2FsbGJhY2tcbiAgICB7XG4gICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICB0d29XYXk6IHRoaXMudHdvV2F5LFxuICAgICAgZGVlcDogdGhpcy5kZWVwLFxuICAgICAgcHJlUHJvY2VzczogcHJlUHJvY2VzcyxcbiAgICAgIHBvc3RQcm9jZXNzOiBwb3N0UHJvY2VzcyxcbiAgICAgIHNjb3BlOiB0aGlzLl9zY29wZVxuICAgIH0pO1xuICAgIC8vIHYtbW9kZWwgd2l0aCBpbml0YWwgaW5saW5lIHZhbHVlIG5lZWQgdG8gc3luYyBiYWNrIHRvXG4gICAgLy8gbW9kZWwgaW5zdGVhZCBvZiB1cGRhdGUgdG8gRE9NIG9uIGluaXQuIFRoZXkgd291bGRcbiAgICAvLyBzZXQgdGhlIGFmdGVyQmluZCBob29rIHRvIGluZGljYXRlIHRoYXQuXG4gICAgaWYgKHRoaXMuYWZ0ZXJCaW5kKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlKHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXR1cCBhbGwgcGFyYW0gYXR0cmlidXRlcywgZS5nLiB0cmFjay1ieSxcbiAqIHRyYW5zaXRpb24tbW9kZSwgZXRjLi4uXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5wYXJhbXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAvLyBzd2FwIHRoZSBwYXJhbXMgYXJyYXkgd2l0aCBhIGZyZXNoIG9iamVjdC5cbiAgdGhpcy5wYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgaSA9IHBhcmFtcy5sZW5ndGg7XG4gIHZhciBrZXksIHZhbCwgbWFwcGVkS2V5O1xuICB3aGlsZSAoaS0tKSB7XG4gICAga2V5ID0gaHlwaGVuYXRlKHBhcmFtc1tpXSk7XG4gICAgbWFwcGVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICB2YWwgPSBnZXRCaW5kQXR0cih0aGlzLmVsLCBrZXkpO1xuICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgLy8gZHluYW1pY1xuICAgICAgdGhpcy5fc2V0dXBQYXJhbVdhdGNoZXIobWFwcGVkS2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdGF0aWNcbiAgICAgIHZhbCA9IGdldEF0dHIodGhpcy5lbCwga2V5KTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhcmFtc1ttYXBwZWRLZXldID0gdmFsID09PSAnJyA/IHRydWUgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNldHVwIGEgd2F0Y2hlciBmb3IgYSBkeW5hbWljIHBhcmFtLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbVdhdGNoZXIgPSBmdW5jdGlvbiAoa2V5LCBleHByZXNzaW9uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICB2YXIgdW53YXRjaCA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kd2F0Y2goZXhwcmVzc2lvbiwgZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XG4gICAgc2VsZi5wYXJhbXNba2V5XSA9IHZhbDtcbiAgICAvLyBzaW5jZSB3ZSBhcmUgaW4gaW1tZWRpYXRlIG1vZGUsXG4gICAgLy8gb25seSBjYWxsIHRoZSBwYXJhbSBjaGFuZ2UgY2FsbGJhY2tzIGlmIHRoaXMgaXMgbm90IHRoZSBmaXJzdCB1cGRhdGUuXG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgdmFyIGNiID0gc2VsZi5wYXJhbVdhdGNoZXJzICYmIHNlbGYucGFyYW1XYXRjaGVyc1trZXldO1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiLmNhbGwoc2VsZiwgdmFsLCBvbGRWYWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICB1c2VyOiBmYWxzZVxuICB9KTsodGhpcy5fcGFyYW1VbndhdGNoRm5zIHx8ICh0aGlzLl9wYXJhbVVud2F0Y2hGbnMgPSBbXSkpLnB1c2godW53YXRjaCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkaXJlY3RpdmUgaXMgYSBmdW5jdGlvbiBjYWxsZXJcbiAqIGFuZCBpZiB0aGUgZXhwcmVzc2lvbiBpcyBhIGNhbGxhYmxlIG9uZS4gSWYgYm90aCB0cnVlLFxuICogd2Ugd3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBhbmQgdXNlIGl0IGFzIHRoZSBldmVudFxuICogaGFuZGxlci5cbiAqXG4gKiBlLmcuIG9uLWNsaWNrPVwiYSsrXCJcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgaWYgKGV4cHJlc3Npb24gJiYgdGhpcy5hY2NlcHRTdGF0ZW1lbnQgJiYgIWlzU2ltcGxlUGF0aChleHByZXNzaW9uKSkge1xuICAgIHZhciBmbiA9IHBhcnNlRXhwcmVzc2lvbihleHByZXNzaW9uKS5nZXQ7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5fc2NvcGUgfHwgdGhpcy52bTtcbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuICAgICAgc2NvcGUuJGV2ZW50ID0gZTtcbiAgICAgIGZuLmNhbGwoc2NvcGUsIHNjb3BlKTtcbiAgICAgIHNjb3BlLiRldmVudCA9IG51bGw7XG4gICAgfTtcbiAgICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgICBoYW5kbGVyID0gc2NvcGUuX2FwcGx5RmlsdGVycyhoYW5kbGVyLCBudWxsLCB0aGlzLmZpbHRlcnMpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShoYW5kbGVyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgd2l0aCB0aGUgc2V0dGVyLlxuICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIHR3by13YXkgZGlyZWN0aXZlc1xuICogZS5nLiB2LW1vZGVsLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwdWJsaWNcbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy50d29XYXkpIHtcbiAgICB0aGlzLl93aXRoTG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl93YXRjaGVyLnNldCh2YWx1ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oJ0RpcmVjdGl2ZS5zZXQoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB0d29XYXknICsgJ2RpcmVjdGl2ZXMuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGZ1bmN0aW9uIHdoaWxlIHByZXZlbnRpbmcgdGhhdCBmdW5jdGlvbiBmcm9tXG4gKiB0cmlnZ2VyaW5nIHVwZGF0ZXMgb24gdGhpcyBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl93aXRoTG9jayA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuX2xvY2tlZCA9IHRydWU7XG4gIGZuLmNhbGwoc2VsZik7XG4gIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9sb2NrZWQgPSBmYWxzZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF0dGFjaGVzIGEgRE9NIGV2ZW50IGxpc3RlbmVyXG4gKiB0byB0aGUgZGlyZWN0aXZlIGVsZW1lbnQgYW5kIGF1dG9tZXRpY2FsbHkgdGVhcnMgaXQgZG93blxuICogZHVyaW5nIHVuYmluZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICBvbih0aGlzLmVsLCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7KHRoaXMuX2xpc3RlbmVycyB8fCAodGhpcy5fbGlzdGVuZXJzID0gW10pKS5wdXNoKFtldmVudCwgaGFuZGxlcl0pO1xufTtcblxuLyoqXG4gKiBUZWFyZG93biB0aGUgd2F0Y2hlciBhbmQgY2FsbCB1bmJpbmQuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fdGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9ib3VuZCkge1xuICAgIHRoaXMuX2JvdW5kID0gZmFsc2U7XG4gICAgaWYgKHRoaXMudW5iaW5kKSB7XG4gICAgICB0aGlzLnVuYmluZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fd2F0Y2hlcikge1xuICAgICAgdGhpcy5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIHZhciBpO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGkgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBvZmYodGhpcy5lbCwgbGlzdGVuZXJzW2ldWzBdLCBsaXN0ZW5lcnNbaV1bMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdW53YXRjaEZucyA9IHRoaXMuX3BhcmFtVW53YXRjaEZucztcbiAgICBpZiAodW53YXRjaEZucykge1xuICAgICAgaSA9IHVud2F0Y2hGbnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB1bndhdGNoRm5zW2ldKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwpIHtcbiAgICAgIHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzLiRyZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIHRoaXMudm0gPSB0aGlzLmVsID0gdGhpcy5fd2F0Y2hlciA9IHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgLyoqXG4gICAqIFVwZGF0ZSB2LXJlZiBmb3IgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl91cGRhdGVSZWYgPSBmdW5jdGlvbiAocmVtb3ZlKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuJG9wdGlvbnMuX3JlZjtcbiAgICBpZiAocmVmKSB7XG4gICAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLl9jb250ZXh0KS4kcmVmcztcbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgaWYgKHJlZnNbcmVmXSA9PT0gdGhpcykge1xuICAgICAgICAgIHJlZnNbcmVmXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNbcmVmXSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUcmFuc2NsdWRlLCBjb21waWxlIGFuZCBsaW5rIGVsZW1lbnQuXG4gICAqXG4gICAqIElmIGEgcHJlLWNvbXBpbGVkIGxpbmtlciBpcyBhdmFpbGFibGUsIHRoYXQgbWVhbnMgdGhlXG4gICAqIHBhc3NlZCBpbiBlbGVtZW50IHdpbGwgYmUgcHJlLXRyYW5zY2x1ZGVkIGFuZCBjb21waWxlZFxuICAgKiBhcyB3ZWxsIC0gYWxsIHdlIG5lZWQgdG8gZG8gaXMgdG8gY2FsbCB0aGUgbGlua2VyLlxuICAgKlxuICAgKiBPdGhlcndpc2Ugd2UgbmVlZCB0byBjYWxsIHRyYW5zY2x1ZGUvY29tcGlsZS9saW5rIGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcblxuICAgIC8vIHRyYW5zY2x1ZGUgYW5kIGluaXQgZWxlbWVudFxuICAgIC8vIHRyYW5zY2x1ZGUgY2FuIHBvdGVudGlhbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGtlZXAgcmVmZXJlbmNlOyB0aGlzIHN0ZXAgYWxzbyBpbmplY3RzXG4gICAgLy8gdGhlIHRlbXBsYXRlIGFuZCBjYWNoZXMgdGhlIG9yaWdpbmFsIGF0dHJpYnV0ZXNcbiAgICAvLyBvbiB0aGUgY29udGFpbmVyIG5vZGUgYW5kIHJlcGxhY2VyIG5vZGUuXG4gICAgdmFyIG9yaWdpbmFsID0gZWw7XG4gICAgZWwgPSB0cmFuc2NsdWRlKGVsLCBvcHRpb25zKTtcbiAgICB0aGlzLl9pbml0RWxlbWVudChlbCk7XG5cbiAgICAvLyBoYW5kbGUgdi1wcmUgb24gcm9vdCBub2RlICgjMjAyNilcbiAgICBpZiAoZWwubm9kZVR5cGUgPT09IDEgJiYgZ2V0QXR0cihlbCwgJ3YtcHJlJykgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByb290IGlzIGFsd2F5cyBjb21waWxlZCBwZXItaW5zdGFuY2UsIGJlY2F1c2VcbiAgICAvLyBjb250YWluZXIgYXR0cnMgYW5kIHByb3BzIGNhbiBiZSBkaWZmZXJlbnQgZXZlcnkgdGltZS5cbiAgICB2YXIgY29udGV4dE9wdGlvbnMgPSB0aGlzLl9jb250ZXh0ICYmIHRoaXMuX2NvbnRleHQuJG9wdGlvbnM7XG4gICAgdmFyIHJvb3RMaW5rZXIgPSBjb21waWxlUm9vdChlbCwgb3B0aW9ucywgY29udGV4dE9wdGlvbnMpO1xuXG4gICAgLy8gcmVzb2x2ZSBzbG90IGRpc3RyaWJ1dGlvblxuICAgIHJlc29sdmVTbG90cyh0aGlzLCBvcHRpb25zLl9jb250ZW50KTtcblxuICAgIC8vIGNvbXBpbGUgYW5kIGxpbmsgdGhlIHJlc3RcbiAgICB2YXIgY29udGVudExpbmtGbjtcbiAgICB2YXIgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgLy8gY29tcG9uZW50IGNvbXBpbGF0aW9uIGNhbiBiZSBjYWNoZWRcbiAgICAvLyBhcyBsb25nIGFzIGl0J3Mgbm90IHVzaW5nIGlubGluZS10ZW1wbGF0ZVxuICAgIGlmIChvcHRpb25zLl9saW5rZXJDYWNoYWJsZSkge1xuICAgICAgY29udGVudExpbmtGbiA9IGN0b3IubGlua2VyO1xuICAgICAgaWYgKCFjb250ZW50TGlua0ZuKSB7XG4gICAgICAgIGNvbnRlbnRMaW5rRm4gPSBjdG9yLmxpbmtlciA9IGNvbXBpbGUoZWwsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGxpbmsgcGhhc2VcbiAgICAvLyBtYWtlIHN1cmUgdG8gbGluayByb290IHdpdGggcHJvcCBzY29wZSFcbiAgICB2YXIgcm9vdFVubGlua0ZuID0gcm9vdExpbmtlcih0aGlzLCBlbCwgdGhpcy5fc2NvcGUpO1xuICAgIHZhciBjb250ZW50VW5saW5rRm4gPSBjb250ZW50TGlua0ZuID8gY29udGVudExpbmtGbih0aGlzLCBlbCkgOiBjb21waWxlKGVsLCBvcHRpb25zKSh0aGlzLCBlbCk7XG5cbiAgICAvLyByZWdpc3RlciBjb21wb3NpdGUgdW5saW5rIGZ1bmN0aW9uXG4gICAgLy8gdG8gYmUgY2FsbGVkIGR1cmluZyBpbnN0YW5jZSBkZXN0cnVjdGlvblxuICAgIHRoaXMuX3VubGlua0ZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcm9vdFVubGlua0ZuKCk7XG4gICAgICAvLyBwYXNzaW5nIGRlc3Ryb3lpbmc6IHRydWUgdG8gYXZvaWQgc2VhcmNoaW5nIGFuZFxuICAgICAgLy8gc3BsaWNpbmcgdGhlIGRpcmVjdGl2ZXNcbiAgICAgIGNvbnRlbnRVbmxpbmtGbih0cnVlKTtcbiAgICB9O1xuXG4gICAgLy8gZmluYWxseSByZXBsYWNlIG9yaWdpbmFsXG4gICAgaWYgKG9wdGlvbnMucmVwbGFjZSkge1xuICAgICAgcmVwbGFjZShvcmlnaW5hbCwgZWwpO1xuICAgIH1cblxuICAgIHRoaXMuX2lzQ29tcGlsZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxIb29rKCdjb21waWxlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGluc3RhbmNlIGVsZW1lbnQuIENhbGxlZCBpbiB0aGUgcHVibGljXG4gICAqICRtb3VudCgpIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChpc0ZyYWdtZW50KGVsKSkge1xuICAgICAgdGhpcy5faXNGcmFnbWVudCA9IHRydWU7XG4gICAgICB0aGlzLiRlbCA9IHRoaXMuX2ZyYWdtZW50U3RhcnQgPSBlbC5maXJzdENoaWxkO1xuICAgICAgdGhpcy5fZnJhZ21lbnRFbmQgPSBlbC5sYXN0Q2hpbGQ7XG4gICAgICAvLyBzZXQgcGVyc2lzdGVkIHRleHQgYW5jaG9ycyB0byBlbXB0eVxuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50U3RhcnQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgdGhpcy5fZnJhZ21lbnRTdGFydC5kYXRhID0gdGhpcy5fZnJhZ21lbnRFbmQuZGF0YSA9ICcnO1xuICAgICAgfVxuICAgICAgdGhpcy5fZnJhZ21lbnQgPSBlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWwgPSBlbDtcbiAgICB9XG4gICAgdGhpcy4kZWwuX192dWVfXyA9IHRoaXM7XG4gICAgdGhpcy5fY2FsbEhvb2soJ2JlZm9yZUNvbXBpbGUnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBiaW5kIGEgZGlyZWN0aXZlIHRvIGFuIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yIC0gcGFyc2VkIGRpcmVjdGl2ZSBkZXNjcmlwdG9yXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgIC0gdGFyZ2V0IG5vZGVcbiAgICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIHRyYW5zY2x1c2lvbiBob3N0IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIG93bmVyIGZyYWdtZW50XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2JpbmREaXIgPSBmdW5jdGlvbiAoZGVzY3JpcHRvciwgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB0aGlzLl9kaXJlY3RpdmVzLnB1c2gobmV3IERpcmVjdGl2ZShkZXNjcmlwdG9yLCB0aGlzLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWFyZG93biBhbiBpbnN0YW5jZSwgdW5vYnNlcnZlcyB0aGUgZGF0YSwgdW5iaW5kIGFsbCB0aGVcbiAgICogZGlyZWN0aXZlcywgdHVybiBvZmYgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgLSB3aGV0aGVyIHRvIHJlbW92ZSB0aGUgRE9NIG5vZGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJDbGVhbnVwIC0gaWYgdHJ1ZSwgZGVmZXIgY2xlYW51cCB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGNhbGxlZCBsYXRlclxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZSwgZGVmZXJDbGVhbnVwKSB7XG4gICAgaWYgKHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghZGVmZXJDbGVhbnVwKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVzdHJveVJlYWR5O1xuICAgIHZhciBwZW5kaW5nUmVtb3ZhbDtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBDbGVhbnVwIHNob3VsZCBiZSBjYWxsZWQgZWl0aGVyIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3lzbHkgYXNcbiAgICAvLyBjYWxsYmFjayBvZiB0aGlzLiRyZW1vdmUoKSwgb3IgaWYgcmVtb3ZlIGFuZCBkZWZlckNsZWFudXAgYXJlIGZhbHNlLlxuICAgIC8vIEluIGFueSBjYXNlIGl0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIG90aGVyIHJlbW92aW5nLCB1bmJpbmRpbmcgYW5kXG4gICAgLy8gdHVybmluZyBvZiBpcyBkb25lXG4gICAgdmFyIGNsZWFudXBJZlBvc3NpYmxlID0gZnVuY3Rpb24gY2xlYW51cElmUG9zc2libGUoKSB7XG4gICAgICBpZiAoZGVzdHJveVJlYWR5ICYmICFwZW5kaW5nUmVtb3ZhbCAmJiAhZGVmZXJDbGVhbnVwKSB7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlIERPTSBlbGVtZW50XG4gICAgaWYgKHJlbW92ZSAmJiB0aGlzLiRlbCkge1xuICAgICAgcGVuZGluZ1JlbW92YWwgPSB0cnVlO1xuICAgICAgdGhpcy4kcmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGVuZGluZ1JlbW92YWwgPSBmYWxzZTtcbiAgICAgICAgY2xlYW51cElmUG9zc2libGUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdmFyIGk7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnQuIG9ubHkgbmVjZXNzYXJ5XG4gICAgLy8gaWYgcGFyZW50IGlzIG5vdCBiZWluZyBkZXN0cm95ZWQgYXMgd2VsbC5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcGFyZW50LiRjaGlsZHJlbi4kcmVtb3ZlKHRoaXMpO1xuICAgICAgLy8gdW5yZWdpc3RlciByZWYgKHJlbW92ZTogdHJ1ZSlcbiAgICAgIHRoaXMuX3VwZGF0ZVJlZih0cnVlKTtcbiAgICB9XG4gICAgLy8gZGVzdHJveSBhbGwgY2hpbGRyZW4uXG4gICAgaSA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLiRjaGlsZHJlbltpXS4kZGVzdHJveSgpO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biBwcm9wc1xuICAgIGlmICh0aGlzLl9wcm9wc1VubGlua0ZuKSB7XG4gICAgICB0aGlzLl9wcm9wc1VubGlua0ZuKCk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIGFsbCBkaXJlY3RpdmVzLiB0aGlzIGFsc28gdGVhcnNkb3duIGFsbFxuICAgIC8vIGRpcmVjdGl2ZS1vd25lZCB3YXRjaGVycy5cbiAgICBpZiAodGhpcy5fdW5saW5rRm4pIHtcbiAgICAgIHRoaXMuX3VubGlua0ZuKCk7XG4gICAgfVxuICAgIGkgPSB0aGlzLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBzZWxmIG9uICRlbFxuICAgIGlmICh0aGlzLiRlbCkge1xuICAgICAgdGhpcy4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVzdHJveVJlYWR5ID0gdHJ1ZTtcbiAgICBjbGVhbnVwSWZQb3NzaWJsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCB0byBlbnN1cmUgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgbGVhdmUgdHJhbnNpdGlvbiBpZiB0aGVyZVxuICAgKiBpcyBhbnkuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2lzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gb3duZXIgZnJhZ21lbnRcbiAgICAvLyBkbyBpdCBpbiBjbGVhbnVwIHNvIHRoYXQgd2UgY2FuIGNhbGwgJGRlc3Ryb3kgd2l0aFxuICAgIC8vIGRlZmVyIHJpZ2h0IHdoZW4gYSBmcmFnbWVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkLlxuICAgIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgICB0aGlzLl9mcmFnLmNoaWxkcmVuLiRyZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHRoaXMuX2RhdGEgJiYgdGhpcy5fZGF0YS5fX29iX18pIHtcbiAgICAgIHRoaXMuX2RhdGEuX19vYl9fLnJlbW92ZVZtKHRoaXMpO1xuICAgIH1cbiAgICAvLyBDbGVhbiB1cCByZWZlcmVuY2VzIHRvIHByaXZhdGUgcHJvcGVydGllcyBhbmQgb3RoZXJcbiAgICAvLyBpbnN0YW5jZXMuIHByZXNlcnZlIHJlZmVyZW5jZSB0byBfZGF0YSBzbyB0aGF0IHByb3h5XG4gICAgLy8gYWNjZXNzb3JzIHN0aWxsIHdvcmsuIFRoZSBvbmx5IHBvdGVudGlhbCBzaWRlIGVmZmVjdFxuICAgIC8vIGhlcmUgaXMgdGhhdCBtdXRhdGluZyB0aGUgaW5zdGFuY2UgYWZ0ZXIgaXQncyBkZXN0cm95ZWRcbiAgICAvLyBtYXkgYWZmZWN0IHRoZSBzdGF0ZSBvZiBvdGhlciBjb21wb25lbnRzIHRoYXQgYXJlIHN0aWxsXG4gICAgLy8gb2JzZXJ2aW5nIHRoZSBzYW1lIG9iamVjdCwgYnV0IHRoYXQgc2VlbXMgdG8gYmUgYVxuICAgIC8vIHJlYXNvbmFibGUgcmVzcG9uc2liaWxpdHkgZm9yIHRoZSB1c2VyIHJhdGhlciB0aGFuXG4gICAgLy8gYWx3YXlzIHRocm93aW5nIGFuIGVycm9yIG9uIHRoZW0uXG4gICAgdGhpcy4kZWwgPSB0aGlzLiRwYXJlbnQgPSB0aGlzLiRyb290ID0gdGhpcy4kY2hpbGRyZW4gPSB0aGlzLl93YXRjaGVycyA9IHRoaXMuX2NvbnRleHQgPSB0aGlzLl9zY29wZSA9IHRoaXMuX2RpcmVjdGl2ZXMgPSBudWxsO1xuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHRoaXMuX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jYWxsSG9vaygnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB0aGlzLiRvZmYoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWlzY01peGluIChWdWUpIHtcbiAgLyoqXG4gICAqIEFwcGx5IGEgbGlzdCBvZiBmaWx0ZXIgKGRlc2NyaXB0b3JzKSB0byBhIHZhbHVlLlxuICAgKiBVc2luZyBwbGFpbiBmb3IgbG9vcHMgaGVyZSBiZWNhdXNlIHRoaXMgd2lsbCBiZSBjYWxsZWQgaW5cbiAgICogdGhlIGdldHRlciBvZiBhbnkgd2F0Y2hlciB3aXRoIGZpbHRlcnMgc28gaXQgaXMgdmVyeVxuICAgKiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHsqfSBbb2xkVmFsdWVdXG4gICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnNcbiAgICogQHBhcmFtIHtCb29sZWFufSB3cml0ZVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9hcHBseUZpbHRlcnMgPSBmdW5jdGlvbiAodmFsdWUsIG9sZFZhbHVlLCBmaWx0ZXJzLCB3cml0ZSkge1xuICAgIHZhciBmaWx0ZXIsIGZuLCBhcmdzLCBhcmcsIG9mZnNldCwgaSwgbCwgaiwgaztcbiAgICBmb3IgKGkgPSAwLCBsID0gZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZpbHRlciA9IGZpbHRlcnNbd3JpdGUgPyBsIC0gaSAtIDEgOiBpXTtcbiAgICAgIGZuID0gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgZmlsdGVyLm5hbWUsIHRydWUpO1xuICAgICAgaWYgKCFmbikgY29udGludWU7XG4gICAgICBmbiA9IHdyaXRlID8gZm4ud3JpdGUgOiBmbi5yZWFkIHx8IGZuO1xuICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgY29udGludWU7XG4gICAgICBhcmdzID0gd3JpdGUgPyBbdmFsdWUsIG9sZFZhbHVlXSA6IFt2YWx1ZV07XG4gICAgICBvZmZzZXQgPSB3cml0ZSA/IDIgOiAxO1xuICAgICAgaWYgKGZpbHRlci5hcmdzKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGsgPSBmaWx0ZXIuYXJncy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICBhcmcgPSBmaWx0ZXIuYXJnc1tqXTtcbiAgICAgICAgICBhcmdzW2ogKyBvZmZzZXRdID0gYXJnLmR5bmFtaWMgPyB0aGlzLiRnZXQoYXJnLnZhbHVlKSA6IGFyZy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGEgY29tcG9uZW50LCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgY29tcG9uZW50XG4gICAqIGlzIGRlZmluZWQgbm9ybWFsbHkgb3IgdXNpbmcgYW4gYXN5bmMgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICogUmVzb2x2ZXMgc3luY2hyb25vdXNseSBpZiBhbHJlYWR5IHJlc29sdmVkLCBvdGhlcndpc2VcbiAgICogcmVzb2x2ZXMgYXN5bmNocm9ub3VzbHkgYW5kIGNhY2hlcyB0aGUgcmVzb2x2ZWRcbiAgICogY29uc3RydWN0b3Igb24gdGhlIGZhY3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9yZXNvbHZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBjYikge1xuICAgIHZhciBmYWN0b3J5O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZhY3RvcnkgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFjdG9yeSA9IHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnY29tcG9uZW50cycsIHZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFmYWN0b3J5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5XG4gICAgaWYgKCFmYWN0b3J5Lm9wdGlvbnMpIHtcbiAgICAgIGlmIChmYWN0b3J5LnJlc29sdmVkKSB7XG4gICAgICAgIC8vIGNhY2hlZFxuICAgICAgICBjYihmYWN0b3J5LnJlc29sdmVkKTtcbiAgICAgIH0gZWxzZSBpZiAoZmFjdG9yeS5yZXF1ZXN0ZWQpIHtcbiAgICAgICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICAgICAgZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeS5yZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgY2JzID0gZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzID0gW2NiXTtcbiAgICAgICAgZmFjdG9yeS5jYWxsKHRoaXMsIGZ1bmN0aW9uIHJlc29sdmUocmVzKSB7XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QocmVzKSkge1xuICAgICAgICAgICAgcmVzID0gVnVlLmV4dGVuZChyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXM7XG4gICAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrc1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY2JzW2ldKHJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQnICsgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnOiAnICsgdmFsdWUgOiAnJykgKyAnLiAnICsgKHJlYXNvbiA/ICdcXG5SZWFzb246ICcgKyByZWFzb24gOiAnJykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9ybWFsIGNvbXBvbmVudFxuICAgICAgY2IoZmFjdG9yeSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgZmlsdGVyUkUkMSA9IC9bXnxdXFx8W158XS87XG5cbmZ1bmN0aW9uIGRhdGFBUEkgKFZ1ZSkge1xuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBmcm9tIGFuIGV4cHJlc3Npb24gb24gdGhpcyB2bS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthc1N0YXRlbWVudF1cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZ2V0ID0gZnVuY3Rpb24gKGV4cCwgYXNTdGF0ZW1lbnQpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VFeHByZXNzaW9uKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgaWYgKGFzU3RhdGVtZW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0YXRlbWVudEhhbmRsZXIoKSB7XG4gICAgICAgICAgc2VsZi4kYXJndW1lbnRzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZXMuZ2V0LmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICAgICAgc2VsZi4kYXJndW1lbnRzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVzLmdldC5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSBmcm9tIGFuIGV4cHJlc3Npb24gb24gdGhpcyB2bS5cbiAgICogVGhlIGV4cHJlc3Npb24gbXVzdCBiZSBhIHZhbGlkIGxlZnQtaGFuZFxuICAgKiBleHByZXNzaW9uIGluIGFuIGFzc2lnbm1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAgICogQHBhcmFtIHsqfSB2YWxcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gZnVuY3Rpb24gKGV4cCwgdmFsKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRXhwcmVzc2lvbihleHAsIHRydWUpO1xuICAgIGlmIChyZXMgJiYgcmVzLnNldCkge1xuICAgICAgcmVzLnNldC5jYWxsKHRoaXMsIHRoaXMsIHZhbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBwcm9wZXJ0eSBvbiB0aGUgVk1cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVsKHRoaXMuX2RhdGEsIGtleSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhdGNoIGFuIGV4cHJlc3Npb24sIHRyaWdnZXIgY2FsbGJhY2sgd2hlbiBpdHNcbiAgICogdmFsdWUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGV4cE9yRm5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZGVlcFxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gaW1tZWRpYXRlXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIHVud2F0Y2hGblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHBhcnNlZDtcbiAgICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZShleHBPckZuKTtcbiAgICAgIGV4cE9yRm4gPSBwYXJzZWQuZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIHtcbiAgICAgIGRlZXA6IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWVwLFxuICAgICAgc3luYzogb3B0aW9ucyAmJiBvcHRpb25zLnN5bmMsXG4gICAgICBmaWx0ZXJzOiBwYXJzZWQgJiYgcGFyc2VkLmZpbHRlcnMsXG4gICAgICB1c2VyOiAhb3B0aW9ucyB8fCBvcHRpb25zLnVzZXIgIT09IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIGEgdGV4dCBkaXJlY3RpdmUsIGluY2x1ZGluZyBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthc1N0YXRlbWVudF1cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRldmFsID0gZnVuY3Rpb24gKHRleHQsIGFzU3RhdGVtZW50KSB7XG4gICAgLy8gY2hlY2sgZm9yIGZpbHRlcnMuXG4gICAgaWYgKGZpbHRlclJFJDEudGVzdCh0ZXh0KSkge1xuICAgICAgdmFyIGRpciA9IHBhcnNlRGlyZWN0aXZlKHRleHQpO1xuICAgICAgLy8gdGhlIGZpbHRlciByZWdleCBjaGVjayBtaWdodCBnaXZlIGZhbHNlIHBvc2l0aXZlXG4gICAgICAvLyBmb3IgcGlwZXMgaW5zaWRlIHN0cmluZ3MsIHNvIGl0J3MgcG9zc2libGUgdGhhdFxuICAgICAgLy8gd2UgZG9uJ3QgZ2V0IGFueSBmaWx0ZXJzIGhlcmVcbiAgICAgIHZhciB2YWwgPSB0aGlzLiRnZXQoZGlyLmV4cHJlc3Npb24sIGFzU3RhdGVtZW50KTtcbiAgICAgIHJldHVybiBkaXIuZmlsdGVycyA/IHRoaXMuX2FwcGx5RmlsdGVycyh2YWwsIG51bGwsIGRpci5maWx0ZXJzKSA6IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gZmlsdGVyXG4gICAgICByZXR1cm4gdGhpcy4kZ2V0KHRleHQsIGFzU3RhdGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVycG9sYXRlIGEgcGllY2Ugb2YgdGVtcGxhdGUgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdmFyIHRva2VucyA9IHBhcnNlVGV4dCh0ZXh0KTtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB2bS4kZXZhbCh0b2tlbnNbMF0udmFsdWUpICsgJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4udGFnID8gdm0uJGV2YWwodG9rZW4udmFsdWUpIDogdG9rZW4udmFsdWU7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExvZyBpbnN0YW5jZSBkYXRhIGFzIGEgcGxhaW4gSlMgb2JqZWN0XG4gICAqIHNvIHRoYXQgaXQgaXMgZWFzaWVyIHRvIGluc3BlY3QgaW4gY29uc29sZS5cbiAgICogVGhpcyBtZXRob2QgYXNzdW1lcyBjb25zb2xlIGlzIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRsb2cgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBkYXRhID0gcGF0aCA/IGdldFBhdGgodGhpcy5fZGF0YSwgcGF0aCkgOiB0aGlzLl9kYXRhO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBkYXRhID0gY2xlYW4oZGF0YSk7XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgY29tcHV0ZWQgZmllbGRzXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICB2YXIga2V5O1xuICAgICAgZm9yIChrZXkgaW4gdGhpcy4kb3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgICBkYXRhW2tleV0gPSBjbGVhbih0aGlzW2tleV0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Byb3BzKSB7XG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuX3Byb3BzKSB7XG4gICAgICAgICAgZGF0YVtrZXldID0gY2xlYW4odGhpc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogXCJjbGVhblwiIGEgZ2V0dGVyL3NldHRlciBjb252ZXJ0ZWQgb2JqZWN0IGludG8gYSBwbGFpblxuICAgKiBvYmplY3QgY29weS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IC0gb2JqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gY2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZG9tQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG9uLWluc3RhbmNlIG5leHRUaWNrLiBUaGUgY2FsbGJhY2sgaXNcbiAgICogYXV0by1ib3VuZCB0byB0aGUgaW5zdGFuY2UsIGFuZCB0aGlzIGF2b2lkcyBjb21wb25lbnRcbiAgICogbW9kdWxlcyBoYXZpbmcgdG8gcmVseSBvbiB0aGUgZ2xvYmFsIFZ1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBuZXh0VGljayhmbiwgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBpbnN0YW5jZSB0byB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGFwcGVuZFRvID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluc2VydCh0aGlzLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgYXBwZW5kLCBhcHBlbmRXaXRoVHJhbnNpdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByZXBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRwcmVwZW5kVG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICB0aGlzLiRiZWZvcmUodGFyZ2V0LmZpcnN0Q2hpbGQsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGFwcGVuZFRvKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc2VydCBpbnN0YW5jZSBiZWZvcmUgdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRiZWZvcmUgPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gaW5zZXJ0KHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLCBiZWZvcmVXaXRoQ2IsIGJlZm9yZVdpdGhUcmFuc2l0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0IGluc3RhbmNlIGFmdGVyIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYWZ0ZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXQubmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQubmV4dFNpYmxpbmcsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGFwcGVuZFRvKHRhcmdldC5wYXJlbnROb2RlLCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGluc3RhbmNlIGZyb20gRE9NXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRyZW1vdmUgPSBmdW5jdGlvbiAoY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgaWYgKCF0aGlzLiRlbC5wYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gY2IgJiYgY2IoKTtcbiAgICB9XG4gICAgdmFyIGluRG9jdW1lbnQgPSB0aGlzLl9pc0F0dGFjaGVkICYmIGluRG9jKHRoaXMuJGVsKTtcbiAgICAvLyBpZiB3ZSBhcmUgbm90IGluIGRvY3VtZW50LCBubyBuZWVkIHRvIGNoZWNrXG4gICAgLy8gZm9yIHRyYW5zaXRpb25zXG4gICAgaWYgKCFpbkRvY3VtZW50KSB3aXRoVHJhbnNpdGlvbiA9IGZhbHNlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVhbENiID0gZnVuY3Rpb24gcmVhbENiKCkge1xuICAgICAgaWYgKGluRG9jdW1lbnQpIHNlbGYuX2NhbGxIb29rKCdkZXRhY2hlZCcpO1xuICAgICAgaWYgKGNiKSBjYigpO1xuICAgIH07XG4gICAgaWYgKHRoaXMuX2lzRnJhZ21lbnQpIHtcbiAgICAgIHJlbW92ZU5vZGVSYW5nZSh0aGlzLl9mcmFnbWVudFN0YXJ0LCB0aGlzLl9mcmFnbWVudEVuZCwgdGhpcywgdGhpcy5fZnJhZ21lbnQsIHJlYWxDYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvcCA9IHdpdGhUcmFuc2l0aW9uID09PSBmYWxzZSA/IHJlbW92ZVdpdGhDYiA6IHJlbW92ZVdpdGhUcmFuc2l0aW9uO1xuICAgICAgb3AodGhpcy4kZWwsIHRoaXMsIHJlYWxDYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaGFyZWQgRE9NIGluc2VydGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wMSAtIG9wIGZvciBub24tdHJhbnNpdGlvbiBpbnNlcnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3AyIC0gb3AgZm9yIHRyYW5zaXRpb24gaW5zZXJ0XG4gICAqIEByZXR1cm4gdm1cbiAgICovXG5cbiAgZnVuY3Rpb24gaW5zZXJ0KHZtLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgb3AxLCBvcDIpIHtcbiAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgIHZhciB0YXJnZXRJc0RldGFjaGVkID0gIWluRG9jKHRhcmdldCk7XG4gICAgdmFyIG9wID0gd2l0aFRyYW5zaXRpb24gPT09IGZhbHNlIHx8IHRhcmdldElzRGV0YWNoZWQgPyBvcDEgOiBvcDI7XG4gICAgdmFyIHNob3VsZENhbGxIb29rID0gIXRhcmdldElzRGV0YWNoZWQgJiYgIXZtLl9pc0F0dGFjaGVkICYmICFpbkRvYyh2bS4kZWwpO1xuICAgIGlmICh2bS5faXNGcmFnbWVudCkge1xuICAgICAgbWFwTm9kZVJhbmdlKHZtLl9mcmFnbWVudFN0YXJ0LCB2bS5fZnJhZ21lbnRFbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG9wKG5vZGUsIHRhcmdldCwgdm0pO1xuICAgICAgfSk7XG4gICAgICBjYiAmJiBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcCh2bS4kZWwsIHRhcmdldCwgdm0sIGNiKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZENhbGxIb29rKSB7XG4gICAgICB2bS5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB2bTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBmb3Igc2VsZWN0b3JzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGVsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHF1ZXJ5KGVsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKSA6IGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBvcGVyYXRpb24gdGhhdCB0YWtlcyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFwcGVuZChlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRCZWZvcmUgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBmdW5jdGlvbiBiZWZvcmVXaXRoQ2IoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVXaXRoQ2IoZWwsIHZtLCBjYikge1xuICAgIHJlbW92ZShlbCk7XG4gICAgaWYgKGNiKSBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50c0FQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgKHRoaXMuX2V2ZW50c1tldmVudF0gfHwgKHRoaXMuX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAgICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgc2VsZi4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHRoaXMuJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gICAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciBjYnM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICAgIGZvciAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICBpZiAoY2JzKSB7XG4gICAgICAgICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtY2JzLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgLWNicy5sZW5ndGgpO1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtMSk7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlciBhbiBldmVudCBvbiBzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHNob3VsZFByb3BhZ2F0ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGlzU291cmNlID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJztcbiAgICBldmVudCA9IGlzU291cmNlID8gZXZlbnQgOiBldmVudC5uYW1lO1xuICAgIHZhciBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgIHZhciBzaG91bGRQcm9wYWdhdGUgPSBpc1NvdXJjZSB8fCAhY2JzO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGhhY2t5IHNvbHV0aW9uIHRvIHRoZSBxdWVzdGlvbiByYWlzZWRcbiAgICAgIC8vIGluICMyMTAyOiBmb3IgYW4gaW5saW5lIGNvbXBvbmVudCBsaXN0ZW5lciBsaWtlIDxjb21wIEB0ZXN0PVwiZG9UaGlzXCI+LFxuICAgICAgLy8gdGhlIHByb3BhZ2F0aW9uIGhhbmRsaW5nIGlzIHNvbWV3aGF0IGJyb2tlbi4gVGhlcmVmb3JlIHdlXG4gICAgICAvLyBuZWVkIHRvIHRyZWF0IHRoZXNlIGlubGluZSBjYWxsYmFja3MgZGlmZmVyZW50bHkuXG4gICAgICB2YXIgaGFzUGFyZW50Q2JzID0gaXNTb3VyY2UgJiYgY2JzLnNvbWUoZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHJldHVybiBjYi5fZnJvbVBhcmVudDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc1BhcmVudENicykge1xuICAgICAgICBzaG91bGRQcm9wYWdhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjYiA9IGNic1tpXTtcbiAgICAgICAgdmFyIHJlcyA9IGNiLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzID09PSB0cnVlICYmICghaGFzUGFyZW50Q2JzIHx8IGNiLl9mcm9tUGFyZW50KSkge1xuICAgICAgICAgIHNob3VsZFByb3BhZ2F0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZFByb3BhZ2F0ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgYnJvYWRjYXN0IGFuIGV2ZW50IHRvIGFsbCBjaGlsZHJlbiBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnRcbiAgICogQHBhcmFtIHsuLi4qfSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRicm9hZGNhc3QgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgaXNTb3VyY2UgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnO1xuICAgIGV2ZW50ID0gaXNTb3VyY2UgPyBldmVudCA6IGV2ZW50Lm5hbWU7XG4gICAgLy8gaWYgbm8gY2hpbGQgaGFzIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQsXG4gICAgLy8gdGhlbiB0aGVyZSdzIG5vIG5lZWQgdG8gYnJvYWRjYXN0LlxuICAgIGlmICghdGhpcy5fZXZlbnRzQ291bnRbZXZlbnRdKSByZXR1cm47XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kY2hpbGRyZW47XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgaWYgKGlzU291cmNlKSB7XG4gICAgICAvLyB1c2Ugb2JqZWN0IGV2ZW50IHRvIGluZGljYXRlIG5vbi1zb3VyY2UgZW1pdFxuICAgICAgLy8gb24gY2hpbGRyZW5cbiAgICAgIGFyZ3NbMF0gPSB7IG5hbWU6IGV2ZW50LCBzb3VyY2U6IHRoaXMgfTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIHNob3VsZFByb3BhZ2F0ZSA9IGNoaWxkLiRlbWl0LmFwcGx5KGNoaWxkLCBhcmdzKTtcbiAgICAgIGlmIChzaG91bGRQcm9wYWdhdGUpIHtcbiAgICAgICAgY2hpbGQuJGJyb2FkY2FzdC5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBwcm9wYWdhdGUgYW4gZXZlbnQgdXAgdGhlIHBhcmVudCBjaGFpbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZGlzcGF0Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgc2hvdWxkUHJvcGFnYXRlID0gdGhpcy4kZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghc2hvdWxkUHJvcGFnYXRlKSByZXR1cm47XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudDtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAvLyB1c2Ugb2JqZWN0IGV2ZW50IHRvIGluZGljYXRlIG5vbi1zb3VyY2UgZW1pdFxuICAgIC8vIG9uIHBhcmVudHNcbiAgICBhcmdzWzBdID0geyBuYW1lOiBldmVudCwgc291cmNlOiB0aGlzIH07XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgc2hvdWxkUHJvcGFnYXRlID0gcGFyZW50LiRlbWl0LmFwcGx5KHBhcmVudCwgYXJncyk7XG4gICAgICBwYXJlbnQgPSBzaG91bGRQcm9wYWdhdGUgPyBwYXJlbnQuJHBhcmVudCA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIGxpc3RlbmVyIGNvdW50cyBvbiBhbGwgcGFyZW50cy5cbiAgICogVGhpcyBib29ra2VlcGluZyBhbGxvd3MgJGJyb2FkY2FzdCB0byByZXR1cm4gZWFybHkgd2hlblxuICAgKiBubyBjaGlsZCBoYXMgbGlzdGVuZWQgdG8gYSBjZXJ0YWluIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICAgKi9cblxuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIGZ1bmN0aW9uIG1vZGlmeUxpc3RlbmVyQ291bnQodm0sIGV2ZW50LCBjb3VudCkge1xuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIC8vIGhvb2tzIGRvIG5vdCBnZXQgYnJvYWRjYXN0ZWQgc28gbm8gbmVlZFxuICAgIC8vIHRvIGRvIGJvb2trZWVwaW5nIGZvciB0aGVtXG4gICAgaWYgKCFwYXJlbnQgfHwgIWNvdW50IHx8IGhvb2tSRS50ZXN0KGV2ZW50KSkgcmV0dXJuO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdID0gKHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdIHx8IDApICsgY291bnQ7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIFNldCBpbnN0YW5jZSB0YXJnZXQgZWxlbWVudCBhbmQga2ljayBvZmYgdGhlIGNvbXBpbGF0aW9uXG4gICAqIHByb2Nlc3MuIFRoZSBwYXNzZWQgaW4gYGVsYCBjYW4gYmUgYSBzZWxlY3RvciBzdHJpbmcsIGFuXG4gICAqIGV4aXN0aW5nIEVsZW1lbnQsIG9yIGEgRG9jdW1lbnRGcmFnbWVudCAoZm9yIGJsb2NrXG4gICAqIGluc3RhbmNlcykuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fHN0cmluZ30gZWxcbiAgICogQHB1YmxpY1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICh0aGlzLl9pc0NvbXBpbGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJyRtb3VudCgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLicsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbCA9IHF1ZXJ5KGVsKTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH1cbiAgICB0aGlzLl9jb21waWxlKGVsKTtcbiAgICB0aGlzLl9pbml0RE9NSG9va3MoKTtcbiAgICBpZiAoaW5Eb2ModGhpcy4kZWwpKSB7XG4gICAgICB0aGlzLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICAgIHJlYWR5LmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJG9uY2UoJ2hvb2s6YXR0YWNoZWQnLCByZWFkeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXJrIGFuIGluc3RhbmNlIGFzIHJlYWR5LlxuICAgKi9cblxuICBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9jYWxsSG9vaygncmVhZHknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWFyZG93biB0aGUgaW5zdGFuY2UsIHNpbXBseSBkZWxlZ2F0ZSB0byB0aGUgaW50ZXJuYWxcbiAgICogX2Rlc3Ryb3kuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJDbGVhbnVwXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAocmVtb3ZlLCBkZWZlckNsZWFudXApIHtcbiAgICB0aGlzLl9kZXN0cm95KHJlbW92ZSwgZGVmZXJDbGVhbnVwKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFydGlhbGx5IGNvbXBpbGUgYSBwaWVjZSBvZiBET00gYW5kIHJldHVybiBhXG4gICAqIGRlY29tcGlsZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSBbaG9zdF1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAgICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRjb21waWxlID0gZnVuY3Rpb24gKGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIHJldHVybiBjb21waWxlKGVsLCB0aGlzLiRvcHRpb25zLCB0cnVlKSh0aGlzLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBleHBvc2VkIFZ1ZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBBUEkgY29udmVudGlvbnM6XG4gKiAtIHB1YmxpYyBBUEkgbWV0aG9kcy9wcm9wZXJ0aWVzIGFyZSBwcmVmaXhlZCB3aXRoIGAkYFxuICogLSBpbnRlcm5hbCBtZXRob2RzL3Byb3BlcnRpZXMgYXJlIHByZWZpeGVkIHdpdGggYF9gXG4gKiAtIG5vbi1wcmVmaXhlZCBwcm9wZXJ0aWVzIGFyZSBhc3N1bWVkIHRvIGJlIHByb3hpZWQgdXNlclxuICogICBkYXRhLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFZ1ZShvcHRpb25zKSB7XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbi8vIGluc3RhbGwgaW50ZXJuYWxzXG5pbml0TWl4aW4oVnVlKTtcbnN0YXRlTWl4aW4oVnVlKTtcbmV2ZW50c01peGluKFZ1ZSk7XG5saWZlY3ljbGVNaXhpbihWdWUpO1xubWlzY01peGluKFZ1ZSk7XG5cbi8vIGluc3RhbGwgaW5zdGFuY2UgQVBJc1xuZGF0YUFQSShWdWUpO1xuZG9tQVBJKFZ1ZSk7XG5ldmVudHNBUEkoVnVlKTtcbmxpZmVjeWNsZUFQSShWdWUpO1xuXG52YXIgc2xvdCA9IHtcblxuICBwcmlvcml0eTogU0xPVCxcbiAgcGFyYW1zOiBbJ25hbWUnXSxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIHRoaXMgd2FzIHJlc29sdmVkIGR1cmluZyBjb21wb25lbnQgdHJhbnNjbHVzaW9uXG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcmFtcy5uYW1lIHx8ICdkZWZhdWx0JztcbiAgICB2YXIgY29udGVudCA9IHRoaXMudm0uX3Nsb3RDb250ZW50cyAmJiB0aGlzLnZtLl9zbG90Q29udGVudHNbbmFtZV07XG4gICAgaWYgKCFjb250ZW50IHx8ICFjb250ZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdGhpcy5mYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbXBpbGUoY29udGVudC5jbG9uZU5vZGUodHJ1ZSksIHRoaXMudm0uX2NvbnRleHQsIHRoaXMudm0pO1xuICAgIH1cbiAgfSxcblxuICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKGNvbnRlbnQsIGNvbnRleHQsIGhvc3QpIHtcbiAgICBpZiAoY29udGVudCAmJiBjb250ZXh0KSB7XG4gICAgICBpZiAodGhpcy5lbC5oYXNDaGlsZE5vZGVzKCkgJiYgY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiBjb250ZW50LmNoaWxkTm9kZXNbMF0ubm9kZVR5cGUgPT09IDEgJiYgY29udGVudC5jaGlsZE5vZGVzWzBdLmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBpbnNlcnRlZCBzbG90IGhhcyB2LWlmXG4gICAgICAgIC8vIGluamVjdCBmYWxsYmFjayBjb250ZW50IGFzIHRoZSB2LWVsc2VcbiAgICAgICAgdmFyIGVsc2VCbG9jayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIGVsc2VCbG9jay5zZXRBdHRyaWJ1dGUoJ3YtZWxzZScsICcnKTtcbiAgICAgICAgZWxzZUJsb2NrLmlubmVySFRNTCA9IHRoaXMuZWwuaW5uZXJIVE1MO1xuICAgICAgICAvLyB0aGUgZWxzZSBibG9jayBzaG91bGQgYmUgY29tcGlsZWQgaW4gY2hpbGQgc2NvcGVcbiAgICAgICAgZWxzZUJsb2NrLl9jb250ZXh0ID0gdGhpcy52bTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChlbHNlQmxvY2spO1xuICAgICAgfVxuICAgICAgdmFyIHNjb3BlID0gaG9zdCA/IGhvc3QuX3Njb3BlIDogdGhpcy5fc2NvcGU7XG4gICAgICB0aGlzLnVubGluayA9IGNvbnRleHQuJGNvbXBpbGUoY29udGVudCwgaG9zdCwgc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgIH1cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgcmVwbGFjZSh0aGlzLmVsLCBjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKHRoaXMuZWwpO1xuICAgIH1cbiAgfSxcblxuICBmYWxsYmFjazogZnVuY3Rpb24gZmFsbGJhY2soKSB7XG4gICAgdGhpcy5jb21waWxlKGV4dHJhY3RDb250ZW50KHRoaXMuZWwsIHRydWUpLCB0aGlzLnZtKTtcbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICBpZiAodGhpcy51bmxpbmspIHtcbiAgICAgIHRoaXMudW5saW5rKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGFydGlhbCA9IHtcblxuICBwcmlvcml0eTogUEFSVElBTCxcblxuICBwYXJhbXM6IFsnbmFtZSddLFxuXG4gIC8vIHdhdGNoIGNoYW5nZXMgdG8gbmFtZSBmb3IgZHluYW1pYyBwYXJ0aWFsc1xuICBwYXJhbVdhdGNoZXJzOiB7XG4gICAgbmFtZTogZnVuY3Rpb24gbmFtZSh2YWx1ZSkge1xuICAgICAgdklmLnJlbW92ZS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1wYXJ0aWFsJyk7XG4gICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gICAgdGhpcy5pbnNlcnQodGhpcy5wYXJhbXMubmFtZSk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoaWQpIHtcbiAgICB2YXIgcGFydGlhbCA9IHJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAncGFydGlhbHMnLCBpZCwgdHJ1ZSk7XG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgcGFydGlhbCk7XG4gICAgICB2SWYuaW5zZXJ0LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZWxlbWVudERpcmVjdGl2ZXMgPSB7XG4gIHNsb3Q6IHNsb3QsXG4gIHBhcnRpYWw6IHBhcnRpYWxcbn07XG5cbnZhciBjb252ZXJ0QXJyYXkgPSB2Rm9yLl9wb3N0UHJvY2VzcztcblxuLyoqXG4gKiBMaW1pdCBmaWx0ZXIgZm9yIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IChEZWNpbWFsIGV4cGVjdGVkKVxuICovXG5cbmZ1bmN0aW9uIGxpbWl0QnkoYXJyLCBuLCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID8gcGFyc2VJbnQob2Zmc2V0LCAxMCkgOiAwO1xuICBuID0gdG9OdW1iZXIobik7XG4gIHJldHVybiB0eXBlb2YgbiA9PT0gJ251bWJlcicgPyBhcnIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBuKSA6IGFycjtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoXG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlbGltaXRlcl1cbiAqIEBwYXJhbSB7U3RyaW5nfSAuLi5kYXRhS2V5c1xuICovXG5cbmZ1bmN0aW9uIGZpbHRlckJ5KGFyciwgc2VhcmNoLCBkZWxpbWl0ZXIpIHtcbiAgYXJyID0gY29udmVydEFycmF5KGFycik7XG4gIGlmIChzZWFyY2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBhcnI7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYXJyLmZpbHRlcihzZWFyY2gpO1xuICB9XG4gIC8vIGNhc3QgdG8gbG93ZXJjYXNlIHN0cmluZ1xuICBzZWFyY2ggPSAoJycgKyBzZWFyY2gpLnRvTG93ZXJDYXNlKCk7XG4gIC8vIGFsbG93IG9wdGlvbmFsIGBpbmAgZGVsaW1pdGVyXG4gIC8vIGJlY2F1c2Ugd2h5IG5vdFxuICB2YXIgbiA9IGRlbGltaXRlciA9PT0gJ2luJyA/IDMgOiAyO1xuICAvLyBleHRyYWN0IGFuZCBmbGF0dGVuIGtleXNcbiAgdmFyIGtleXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB0b0FycmF5KGFyZ3VtZW50cywgbikpO1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpdGVtLCBrZXksIHZhbCwgajtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaXRlbSA9IGFycltpXTtcbiAgICB2YWwgPSBpdGVtICYmIGl0ZW0uJHZhbHVlIHx8IGl0ZW07XG4gICAgaiA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChqKSB7XG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGtleSA9IGtleXNbal07XG4gICAgICAgIGlmIChrZXkgPT09ICcka2V5JyAmJiBjb250YWlucyhpdGVtLiRrZXksIHNlYXJjaCkgfHwgY29udGFpbnMoZ2V0UGF0aCh2YWwsIGtleSksIHNlYXJjaCkpIHtcbiAgICAgICAgICByZXMucHVzaChpdGVtKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udGFpbnMoaXRlbSwgc2VhcmNoKSkge1xuICAgICAgcmVzLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogRmlsdGVyIGZpbHRlciBmb3IgYXJyYXlzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXk8U3RyaW5nPnxGdW5jdGlvbn0gLi4uc29ydEtleXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3JkZXJdXG4gKi9cblxuZnVuY3Rpb24gb3JkZXJCeShhcnIpIHtcbiAgdmFyIGNvbXBhcmF0b3IgPSBudWxsO1xuICB2YXIgc29ydEtleXMgPSB1bmRlZmluZWQ7XG4gIGFyciA9IGNvbnZlcnRBcnJheShhcnIpO1xuXG4gIC8vIGRldGVybWluZSBvcmRlciAobGFzdCBhcmd1bWVudClcbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gIHZhciBvcmRlciA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicpIHtcbiAgICBvcmRlciA9IG9yZGVyIDwgMCA/IC0xIDogMTtcbiAgICBhcmdzID0gYXJncy5sZW5ndGggPiAxID8gYXJncy5zbGljZSgwLCAtMSkgOiBhcmdzO1xuICB9IGVsc2Uge1xuICAgIG9yZGVyID0gMTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSBzb3J0S2V5cyAmIGNvbXBhcmF0b3JcbiAgdmFyIGZpcnN0QXJnID0gYXJnc1swXTtcbiAgaWYgKCFmaXJzdEFyZykge1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gY3VzdG9tIGNvbXBhcmF0b3JcbiAgICBjb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmaXJzdEFyZyhhLCBiKSAqIG9yZGVyO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gc3RyaW5nIGtleXMuIGZsYXR0ZW4gZmlyc3RcbiAgICBzb3J0S2V5cyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFyZ3MpO1xuICAgIGNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoYSwgYiwgaSkge1xuICAgICAgaSA9IGkgfHwgMDtcbiAgICAgIHJldHVybiBpID49IHNvcnRLZXlzLmxlbmd0aCAtIDEgPyBiYXNlQ29tcGFyZShhLCBiLCBpKSA6IGJhc2VDb21wYXJlKGEsIGIsIGkpIHx8IGNvbXBhcmF0b3IoYSwgYiwgaSArIDEpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBiYXNlQ29tcGFyZShhLCBiLCBzb3J0S2V5SW5kZXgpIHtcbiAgICB2YXIgc29ydEtleSA9IHNvcnRLZXlzW3NvcnRLZXlJbmRleF07XG4gICAgaWYgKHNvcnRLZXkpIHtcbiAgICAgIGlmIChzb3J0S2V5ICE9PSAnJGtleScpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICckdmFsdWUnIGluIGEpIGEgPSBhLiR2YWx1ZTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGIpICYmICckdmFsdWUnIGluIGIpIGIgPSBiLiR2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGEgPSBpc09iamVjdChhKSA/IGdldFBhdGgoYSwgc29ydEtleSkgOiBhO1xuICAgICAgYiA9IGlzT2JqZWN0KGIpID8gZ2V0UGF0aChiLCBzb3J0S2V5KSA6IGI7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gb3JkZXIgOiAtb3JkZXI7XG4gIH1cblxuICAvLyBzb3J0IG9uIGEgY29weSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBhcnJheVxuICByZXR1cm4gYXJyLnNsaWNlKCkuc29ydChjb21wYXJhdG9yKTtcbn1cblxuLyoqXG4gKiBTdHJpbmcgY29udGFpbiBoZWxwZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHZhbCwgc2VhcmNoKSB7XG4gIHZhciBpO1xuICBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnModmFsW2tleXNbaV1dLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnModmFsW2ldLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgIT0gbnVsbCkge1xuICAgIHJldHVybiB2YWwudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc2VhcmNoKSA+IC0xO1xuICB9XG59XG5cbnZhciBkaWdpdHNSRSA9IC8oXFxkezN9KSg/PVxcZCkvZztcblxuLy8gYXNzZXQgY29sbGVjdGlvbnMgbXVzdCBiZSBhIHBsYWluIG9iamVjdC5cbnZhciBmaWx0ZXJzID0ge1xuXG4gIG9yZGVyQnk6IG9yZGVyQnksXG4gIGZpbHRlckJ5OiBmaWx0ZXJCeSxcbiAgbGltaXRCeTogbGltaXRCeSxcblxuICAvKipcbiAgICogU3RyaW5naWZ5IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZW50XG4gICAqL1xuXG4gIGpzb246IHtcbiAgICByZWFkOiBmdW5jdGlvbiByZWFkKHZhbHVlLCBpbmRlbnQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBpbmRlbnQgOiAyKTtcbiAgICB9LFxuICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiAnYWJjJyA9PiAnQWJjJ1xuICAgKi9cblxuICBjYXBpdGFsaXplOiBmdW5jdGlvbiBjYXBpdGFsaXplKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkgcmV0dXJuICcnO1xuICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdmFsdWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zbGljZSgxKTtcbiAgfSxcblxuICAvKipcbiAgICogJ2FiYycgPT4gJ0FCQydcbiAgICovXG5cbiAgdXBwZXJjYXNlOiBmdW5jdGlvbiB1cHBlcmNhc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgfSxcblxuICAvKipcbiAgICogJ0FiQycgPT4gJ2FiYydcbiAgICovXG5cbiAgbG93ZXJjYXNlOiBmdW5jdGlvbiBsb3dlcmNhc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgfSxcblxuICAvKipcbiAgICogMTIzNDUgPT4gJDEyLDM0NS4wMFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2lnblxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVjaW1hbHMgRGVjaW1hbCBwbGFjZXNcbiAgICovXG5cbiAgY3VycmVuY3k6IGZ1bmN0aW9uIGN1cnJlbmN5KHZhbHVlLCBfY3VycmVuY3ksIGRlY2ltYWxzKSB7XG4gICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSB8fCAhdmFsdWUgJiYgdmFsdWUgIT09IDApIHJldHVybiAnJztcbiAgICBfY3VycmVuY3kgPSBfY3VycmVuY3kgIT0gbnVsbCA/IF9jdXJyZW5jeSA6ICckJztcbiAgICBkZWNpbWFscyA9IGRlY2ltYWxzICE9IG51bGwgPyBkZWNpbWFscyA6IDI7XG4gICAgdmFyIHN0cmluZ2lmaWVkID0gTWF0aC5hYnModmFsdWUpLnRvRml4ZWQoZGVjaW1hbHMpO1xuICAgIHZhciBfaW50ID0gZGVjaW1hbHMgPyBzdHJpbmdpZmllZC5zbGljZSgwLCAtMSAtIGRlY2ltYWxzKSA6IHN0cmluZ2lmaWVkO1xuICAgIHZhciBpID0gX2ludC5sZW5ndGggJSAzO1xuICAgIHZhciBoZWFkID0gaSA+IDAgPyBfaW50LnNsaWNlKDAsIGkpICsgKF9pbnQubGVuZ3RoID4gMyA/ICcsJyA6ICcnKSA6ICcnO1xuICAgIHZhciBfZmxvYXQgPSBkZWNpbWFscyA/IHN0cmluZ2lmaWVkLnNsaWNlKC0xIC0gZGVjaW1hbHMpIDogJyc7XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyAnLScgOiAnJztcbiAgICByZXR1cm4gc2lnbiArIF9jdXJyZW5jeSArIGhlYWQgKyBfaW50LnNsaWNlKGkpLnJlcGxhY2UoZGlnaXRzUkUsICckMSwnKSArIF9mbG9hdDtcbiAgfSxcblxuICAvKipcbiAgICogJ2l0ZW0nID0+ICdpdGVtcydcbiAgICpcbiAgICogQHBhcmFtc1xuICAgKiAgYW4gYXJyYXkgb2Ygc3RyaW5ncyBjb3JyZXNwb25kaW5nIHRvXG4gICAqICB0aGUgc2luZ2xlLCBkb3VibGUsIHRyaXBsZSAuLi4gZm9ybXMgb2YgdGhlIHdvcmQgdG9cbiAgICogIGJlIHBsdXJhbGl6ZWQuIFdoZW4gdGhlIG51bWJlciB0byBiZSBwbHVyYWxpemVkXG4gICAqICBleGNlZWRzIHRoZSBsZW5ndGggb2YgdGhlIGFyZ3MsIGl0IHdpbGwgdXNlIHRoZSBsYXN0XG4gICAqICBlbnRyeSBpbiB0aGUgYXJyYXkuXG4gICAqXG4gICAqICBlLmcuIFsnc2luZ2xlJywgJ2RvdWJsZScsICd0cmlwbGUnLCAnbXVsdGlwbGUnXVxuICAgKi9cblxuICBwbHVyYWxpemU6IGZ1bmN0aW9uIHBsdXJhbGl6ZSh2YWx1ZSkge1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGluZGV4ID0gdmFsdWUgJSAxMCAtIDE7XG4gICAgICByZXR1cm4gaW5kZXggaW4gYXJncyA/IGFyZ3NbaW5kZXhdIDogYXJnc1tsZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFyZ3NbMF0gKyAodmFsdWUgPT09IDEgPyAnJyA6ICdzJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWJvdW5jZSBhIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5ID0gMzAwXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBkZWJvdW5jZTogZnVuY3Rpb24gZGVib3VuY2UoaGFuZGxlciwgZGVsYXkpIHtcbiAgICBpZiAoIWhhbmRsZXIpIHJldHVybjtcbiAgICBpZiAoIWRlbGF5KSB7XG4gICAgICBkZWxheSA9IDMwMDtcbiAgICB9XG4gICAgcmV0dXJuIF9kZWJvdW5jZShoYW5kbGVyLCBkZWxheSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGluc3RhbGxHbG9iYWxBUEkgKFZ1ZSkge1xuICAvKipcbiAgICogVnVlIGFuZCBldmVyeSBjb25zdHJ1Y3RvciB0aGF0IGV4dGVuZHMgVnVlIGhhcyBhblxuICAgKiBhc3NvY2lhdGVkIG9wdGlvbnMgb2JqZWN0LCB3aGljaCBjYW4gYmUgYWNjZXNzZWQgZHVyaW5nXG4gICAqIGNvbXBpbGF0aW9uIHN0ZXBzIGFzIGB0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnNgLlxuICAgKlxuICAgKiBUaGVzZSBjYW4gYmUgc2VlbiBhcyB0aGUgZGVmYXVsdCBvcHRpb25zIG9mIGV2ZXJ5XG4gICAqIFZ1ZSBpbnN0YW5jZS5cbiAgICovXG5cbiAgVnVlLm9wdGlvbnMgPSB7XG4gICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICBlbGVtZW50RGlyZWN0aXZlczogZWxlbWVudERpcmVjdGl2ZXMsXG4gICAgZmlsdGVyczogZmlsdGVycyxcbiAgICB0cmFuc2l0aW9uczoge30sXG4gICAgY29tcG9uZW50czoge30sXG4gICAgcGFydGlhbHM6IHt9LFxuICAgIHJlcGxhY2U6IHRydWVcbiAgfTtcblxuICAvKipcbiAgICogRXhwb3NlIHVzZWZ1bCBpbnRlcm5hbHNcbiAgICovXG5cbiAgVnVlLnV0aWwgPSB1dGlsO1xuICBWdWUuY29uZmlnID0gY29uZmlnO1xuICBWdWUuc2V0ID0gc2V0O1xuICBWdWVbJ2RlbGV0ZSddID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICAvKipcbiAgICogVGhlIGZvbGxvd2luZyBhcmUgZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNhZ2UgLyBwbHVnaW5zXG4gICAqL1xuXG4gIFZ1ZS5jb21waWxlciA9IGNvbXBpbGVyO1xuICBWdWUuRnJhZ21lbnRGYWN0b3J5ID0gRnJhZ21lbnRGYWN0b3J5O1xuICBWdWUuaW50ZXJuYWxEaXJlY3RpdmVzID0gaW50ZXJuYWxEaXJlY3RpdmVzO1xuICBWdWUucGFyc2VycyA9IHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIHRleHQ6IHRleHQsXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIGRpcmVjdGl2ZTogZGlyZWN0aXZlLFxuICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgfTtcblxuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuZE9wdGlvbnNcbiAgICovXG5cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgaXNGaXJzdEV4dGVuZCA9IFN1cGVyLmNpZCA9PT0gMDtcbiAgICBpZiAoaXNGaXJzdEV4dGVuZCAmJiBleHRlbmRPcHRpb25zLl9DdG9yKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kT3B0aW9ucy5fQ3RvcjtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWNhdGVycyBhbmQgdGhlIGh5cGhlbi4nKTtcbiAgICAgICAgbmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBTdWIgPSBjcmVhdGVDbGFzcyhuYW1lIHx8ICdWdWVDb21wb25lbnQnKTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFN1cGVyLm9wdGlvbnMsIGV4dGVuZE9wdGlvbnMpO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgaWYgKGlzRmlyc3RFeHRlbmQpIHtcbiAgICAgIGV4dGVuZE9wdGlvbnMuX0N0b3IgPSBTdWI7XG4gICAgfVxuICAgIHJldHVybiBTdWI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3ViLWNsYXNzIGNvbnN0cnVjdG9yIHdpdGggdGhlXG4gICAqIGdpdmVuIG5hbWUuIFRoaXMgZ2l2ZXMgdXMgbXVjaCBuaWNlciBvdXRwdXQgd2hlblxuICAgKiBsb2dnaW5nIGluc3RhbmNlcyBpbiB0aGUgY29uc29sZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKG5hbWUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyAqL1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiAnICsgY2xhc3NpZnkobmFtZSkgKyAnIChvcHRpb25zKSB7IHRoaXMuX2luaXQob3B0aW9ucykgfScpKCk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYyAqL1xuICB9XG5cbiAgLyoqXG4gICAqIFBsdWdpbiBzeXN0ZW1cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpblxuICAgKi9cblxuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBseSBhIGdsb2JhbCBtaXhpbiBieSBtZXJnaW5nIGl0IGludG8gdGhlIGRlZmF1bHRcbiAgICogb3B0aW9ucy5cbiAgICovXG5cbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgVnVlLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoVnVlLm9wdGlvbnMsIG1peGluKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBzaWduYXR1cmU6XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgKiBAcGFyYW0geyp9IGRlZmluaXRpb25cbiAgICovXG5cbiAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoaWQsIGRlZmluaXRpb24pIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiAoY29tbW9uVGFnUkUudGVzdChpZCkgfHwgcmVzZXJ2ZWRUYWdSRS50ZXN0KGlkKSkpIHtcbiAgICAgICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArICdpZDogJyArIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBpZiAoIWRlZmluaXRpb24ubmFtZSkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmluaXRpb24gPSBWdWUuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyBleHBvc2UgaW50ZXJuYWwgdHJhbnNpdGlvbiBBUElcbiAgZXh0ZW5kKFZ1ZS50cmFuc2l0aW9uLCB0cmFuc2l0aW9uKTtcbn1cblxuaW5zdGFsbEdsb2JhbEFQSShWdWUpO1xuXG5WdWUudmVyc2lvbiA9ICcxLjAuMjYnO1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaW5Ccm93c2VyICYmIC9DaHJvbWVcXC9cXGQrLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgY29uc29sZS5sb2coJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJyk7XG4gICAgfVxuICB9XG59LCAwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWdWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlL2Rpc3QvdnVlLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * vue-router v0.7.13\n * (c) 2016 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.VueRouter = factory();\n}(this, function () { 'use strict';\n\n  var babelHelpers = {};\n\n  babelHelpers.classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n  function Target(path, matcher, delegate) {\n    this.path = path;\n    this.matcher = matcher;\n    this.delegate = delegate;\n  }\n\n  Target.prototype = {\n    to: function to(target, callback) {\n      var delegate = this.delegate;\n\n      if (delegate && delegate.willAddRoute) {\n        target = delegate.willAddRoute(this.matcher.target, target);\n      }\n\n      this.matcher.add(this.path, target);\n\n      if (callback) {\n        if (callback.length === 0) {\n          throw new Error(\"You must have an argument in the function passed to `to`\");\n        }\n        this.matcher.addChild(this.path, target, callback, this.delegate);\n      }\n      return this;\n    }\n  };\n\n  function Matcher(target) {\n    this.routes = {};\n    this.children = {};\n    this.target = target;\n  }\n\n  Matcher.prototype = {\n    add: function add(path, handler) {\n      this.routes[path] = handler;\n    },\n\n    addChild: function addChild(path, target, callback, delegate) {\n      var matcher = new Matcher(target);\n      this.children[path] = matcher;\n\n      var match = generateMatch(path, matcher, delegate);\n\n      if (delegate && delegate.contextEntered) {\n        delegate.contextEntered(target, match);\n      }\n\n      callback(match);\n    }\n  };\n\n  function generateMatch(startingPath, matcher, delegate) {\n    return function (path, nestedCallback) {\n      var fullPath = startingPath + path;\n\n      if (nestedCallback) {\n        nestedCallback(generateMatch(fullPath, matcher, delegate));\n      } else {\n        return new Target(startingPath + path, matcher, delegate);\n      }\n    };\n  }\n\n  function addRoute(routeArray, path, handler) {\n    var len = 0;\n    for (var i = 0, l = routeArray.length; i < l; i++) {\n      len += routeArray[i].path.length;\n    }\n\n    path = path.substr(len);\n    var route = { path: path, handler: handler };\n    routeArray.push(route);\n  }\n\n  function eachRoute(baseRoute, matcher, callback, binding) {\n    var routes = matcher.routes;\n\n    for (var path in routes) {\n      if (routes.hasOwnProperty(path)) {\n        var routeArray = baseRoute.slice();\n        addRoute(routeArray, path, routes[path]);\n\n        if (matcher.children[path]) {\n          eachRoute(routeArray, matcher.children[path], callback, binding);\n        } else {\n          callback.call(binding, routeArray);\n        }\n      }\n    }\n  }\n\n  function map (callback, addRouteCallback) {\n    var matcher = new Matcher();\n\n    callback(generateMatch(\"\", matcher, this.delegate));\n\n    eachRoute([], matcher, function (route) {\n      if (addRouteCallback) {\n        addRouteCallback(this, route);\n      } else {\n        this.add(route);\n      }\n    }, this);\n  }\n\n  var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n\n  var escapeRegex = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n\n  var noWarning = false;\n  function warn(msg) {\n    if (!noWarning && typeof console !== 'undefined') {\n      console.error('[vue-router] ' + msg);\n    }\n  }\n\n  function tryDecode(uri, asComponent) {\n    try {\n      return asComponent ? decodeURIComponent(uri) : decodeURI(uri);\n    } catch (e) {\n      warn('malformed URI' + (asComponent ? ' component: ' : ': ') + uri);\n    }\n  }\n\n  function isArray(test) {\n    return Object.prototype.toString.call(test) === \"[object Array]\";\n  }\n\n  // A Segment represents a segment in the original route description.\n  // Each Segment type provides an `eachChar` and `regex` method.\n  //\n  // The `eachChar` method invokes the callback with one or more character\n  // specifications. A character specification consumes one or more input\n  // characters.\n  //\n  // The `regex` method returns a regex fragment for the segment. If the\n  // segment is a dynamic of star segment, the regex fragment also includes\n  // a capture.\n  //\n  // A character specification contains:\n  //\n  // * `validChars`: a String with a list of all valid characters, or\n  // * `invalidChars`: a String with a list of all invalid characters\n  // * `repeat`: true if the character specification can repeat\n\n  function StaticSegment(string) {\n    this.string = string;\n  }\n  StaticSegment.prototype = {\n    eachChar: function eachChar(callback) {\n      var string = this.string,\n          ch;\n\n      for (var i = 0, l = string.length; i < l; i++) {\n        ch = string.charAt(i);\n        callback({ validChars: ch });\n      }\n    },\n\n    regex: function regex() {\n      return this.string.replace(escapeRegex, '\\\\$1');\n    },\n\n    generate: function generate() {\n      return this.string;\n    }\n  };\n\n  function DynamicSegment(name) {\n    this.name = name;\n  }\n  DynamicSegment.prototype = {\n    eachChar: function eachChar(callback) {\n      callback({ invalidChars: \"/\", repeat: true });\n    },\n\n    regex: function regex() {\n      return \"([^/]+)\";\n    },\n\n    generate: function generate(params) {\n      var val = params[this.name];\n      return val == null ? \":\" + this.name : val;\n    }\n  };\n\n  function StarSegment(name) {\n    this.name = name;\n  }\n  StarSegment.prototype = {\n    eachChar: function eachChar(callback) {\n      callback({ invalidChars: \"\", repeat: true });\n    },\n\n    regex: function regex() {\n      return \"(.+)\";\n    },\n\n    generate: function generate(params) {\n      var val = params[this.name];\n      return val == null ? \":\" + this.name : val;\n    }\n  };\n\n  function EpsilonSegment() {}\n  EpsilonSegment.prototype = {\n    eachChar: function eachChar() {},\n    regex: function regex() {\n      return \"\";\n    },\n    generate: function generate() {\n      return \"\";\n    }\n  };\n\n  function parse(route, names, specificity) {\n    // normalize route as not starting with a \"/\". Recognition will\n    // also normalize.\n    if (route.charAt(0) === \"/\") {\n      route = route.substr(1);\n    }\n\n    var segments = route.split(\"/\"),\n        results = [];\n\n    // A routes has specificity determined by the order that its different segments\n    // appear in. This system mirrors how the magnitude of numbers written as strings\n    // works.\n    // Consider a number written as: \"abc\". An example would be \"200\". Any other number written\n    // \"xyz\" will be smaller than \"abc\" so long as `a > z`. For instance, \"199\" is smaller\n    // then \"200\", even though \"y\" and \"z\" (which are both 9) are larger than \"0\" (the value\n    // of (`b` and `c`). This is because the leading symbol, \"2\", is larger than the other\n    // leading symbol, \"1\".\n    // The rule is that symbols to the left carry more weight than symbols to the right\n    // when a number is written out as a string. In the above strings, the leading digit\n    // represents how many 100's are in the number, and it carries more weight than the middle\n    // number which represents how many 10's are in the number.\n    // This system of number magnitude works well for route specificity, too. A route written as\n    // `a/b/c` will be more specific than `x/y/z` as long as `a` is more specific than\n    // `x`, irrespective of the other parts.\n    // Because of this similarity, we assign each type of segment a number value written as a\n    // string. We can find the specificity of compound routes by concatenating these strings\n    // together, from left to right. After we have looped through all of the segments,\n    // we convert the string to a number.\n    specificity.val = '';\n\n    for (var i = 0, l = segments.length; i < l; i++) {\n      var segment = segments[i],\n          match;\n\n      if (match = segment.match(/^:([^\\/]+)$/)) {\n        results.push(new DynamicSegment(match[1]));\n        names.push(match[1]);\n        specificity.val += '3';\n      } else if (match = segment.match(/^\\*([^\\/]+)$/)) {\n        results.push(new StarSegment(match[1]));\n        specificity.val += '2';\n        names.push(match[1]);\n      } else if (segment === \"\") {\n        results.push(new EpsilonSegment());\n        specificity.val += '1';\n      } else {\n        results.push(new StaticSegment(segment));\n        specificity.val += '4';\n      }\n    }\n\n    specificity.val = +specificity.val;\n\n    return results;\n  }\n\n  // A State has a character specification and (`charSpec`) and a list of possible\n  // subsequent states (`nextStates`).\n  //\n  // If a State is an accepting state, it will also have several additional\n  // properties:\n  //\n  // * `regex`: A regular expression that is used to extract parameters from paths\n  //   that reached this accepting state.\n  // * `handlers`: Information on how to convert the list of captures into calls\n  //   to registered handlers with the specified parameters\n  // * `types`: How many static, dynamic or star segments in this route. Used to\n  //   decide which route to use if multiple registered routes match a path.\n  //\n  // Currently, State is implemented naively by looping over `nextStates` and\n  // comparing a character specification against a character. A more efficient\n  // implementation would use a hash of keys pointing at one or more next states.\n\n  function State(charSpec) {\n    this.charSpec = charSpec;\n    this.nextStates = [];\n  }\n\n  State.prototype = {\n    get: function get(charSpec) {\n      var nextStates = this.nextStates;\n\n      for (var i = 0, l = nextStates.length; i < l; i++) {\n        var child = nextStates[i];\n\n        var isEqual = child.charSpec.validChars === charSpec.validChars;\n        isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;\n\n        if (isEqual) {\n          return child;\n        }\n      }\n    },\n\n    put: function put(charSpec) {\n      var state;\n\n      // If the character specification already exists in a child of the current\n      // state, just return that state.\n      if (state = this.get(charSpec)) {\n        return state;\n      }\n\n      // Make a new state for the character spec\n      state = new State(charSpec);\n\n      // Insert the new state as a child of the current state\n      this.nextStates.push(state);\n\n      // If this character specification repeats, insert the new state as a child\n      // of itself. Note that this will not trigger an infinite loop because each\n      // transition during recognition consumes a character.\n      if (charSpec.repeat) {\n        state.nextStates.push(state);\n      }\n\n      // Return the new state\n      return state;\n    },\n\n    // Find a list of child states matching the next character\n    match: function match(ch) {\n      // DEBUG \"Processing `\" + ch + \"`:\"\n      var nextStates = this.nextStates,\n          child,\n          charSpec,\n          chars;\n\n      // DEBUG \"  \" + debugState(this)\n      var returned = [];\n\n      for (var i = 0, l = nextStates.length; i < l; i++) {\n        child = nextStates[i];\n\n        charSpec = child.charSpec;\n\n        if (typeof (chars = charSpec.validChars) !== 'undefined') {\n          if (chars.indexOf(ch) !== -1) {\n            returned.push(child);\n          }\n        } else if (typeof (chars = charSpec.invalidChars) !== 'undefined') {\n          if (chars.indexOf(ch) === -1) {\n            returned.push(child);\n          }\n        }\n      }\n\n      return returned;\n    }\n\n    /** IF DEBUG\n    , debug: function() {\n      var charSpec = this.charSpec,\n          debug = \"[\",\n          chars = charSpec.validChars || charSpec.invalidChars;\n       if (charSpec.invalidChars) { debug += \"^\"; }\n      debug += chars;\n      debug += \"]\";\n       if (charSpec.repeat) { debug += \"+\"; }\n       return debug;\n    }\n    END IF **/\n  };\n\n  /** IF DEBUG\n  function debug(log) {\n    console.log(log);\n  }\n\n  function debugState(state) {\n    return state.nextStates.map(function(n) {\n      if (n.nextStates.length === 0) { return \"( \" + n.debug() + \" [accepting] )\"; }\n      return \"( \" + n.debug() + \" <then> \" + n.nextStates.map(function(s) { return s.debug() }).join(\" or \") + \" )\";\n    }).join(\", \")\n  }\n  END IF **/\n\n  // Sort the routes by specificity\n  function sortSolutions(states) {\n    return states.sort(function (a, b) {\n      return b.specificity.val - a.specificity.val;\n    });\n  }\n\n  function recognizeChar(states, ch) {\n    var nextStates = [];\n\n    for (var i = 0, l = states.length; i < l; i++) {\n      var state = states[i];\n\n      nextStates = nextStates.concat(state.match(ch));\n    }\n\n    return nextStates;\n  }\n\n  var oCreate = Object.create || function (proto) {\n    function F() {}\n    F.prototype = proto;\n    return new F();\n  };\n\n  function RecognizeResults(queryParams) {\n    this.queryParams = queryParams || {};\n  }\n  RecognizeResults.prototype = oCreate({\n    splice: Array.prototype.splice,\n    slice: Array.prototype.slice,\n    push: Array.prototype.push,\n    length: 0,\n    queryParams: null\n  });\n\n  function findHandler(state, path, queryParams) {\n    var handlers = state.handlers,\n        regex = state.regex;\n    var captures = path.match(regex),\n        currentCapture = 1;\n    var result = new RecognizeResults(queryParams);\n\n    for (var i = 0, l = handlers.length; i < l; i++) {\n      var handler = handlers[i],\n          names = handler.names,\n          params = {};\n\n      for (var j = 0, m = names.length; j < m; j++) {\n        params[names[j]] = captures[currentCapture++];\n      }\n\n      result.push({ handler: handler.handler, params: params, isDynamic: !!names.length });\n    }\n\n    return result;\n  }\n\n  function addSegment(currentState, segment) {\n    segment.eachChar(function (ch) {\n      var state;\n\n      currentState = currentState.put(ch);\n    });\n\n    return currentState;\n  }\n\n  function decodeQueryParamPart(part) {\n    // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n    part = part.replace(/\\+/gm, '%20');\n    return tryDecode(part, true);\n  }\n\n  // The main interface\n\n  var RouteRecognizer = function RouteRecognizer() {\n    this.rootState = new State();\n    this.names = {};\n  };\n\n  RouteRecognizer.prototype = {\n    add: function add(routes, options) {\n      var currentState = this.rootState,\n          regex = \"^\",\n          specificity = {},\n          handlers = [],\n          allSegments = [],\n          name;\n\n      var isEmpty = true;\n\n      for (var i = 0, l = routes.length; i < l; i++) {\n        var route = routes[i],\n            names = [];\n\n        var segments = parse(route.path, names, specificity);\n\n        allSegments = allSegments.concat(segments);\n\n        for (var j = 0, m = segments.length; j < m; j++) {\n          var segment = segments[j];\n\n          if (segment instanceof EpsilonSegment) {\n            continue;\n          }\n\n          isEmpty = false;\n\n          // Add a \"/\" for the new segment\n          currentState = currentState.put({ validChars: \"/\" });\n          regex += \"/\";\n\n          // Add a representation of the segment to the NFA and regex\n          currentState = addSegment(currentState, segment);\n          regex += segment.regex();\n        }\n\n        var handler = { handler: route.handler, names: names };\n        handlers.push(handler);\n      }\n\n      if (isEmpty) {\n        currentState = currentState.put({ validChars: \"/\" });\n        regex += \"/\";\n      }\n\n      currentState.handlers = handlers;\n      currentState.regex = new RegExp(regex + \"$\");\n      currentState.specificity = specificity;\n\n      if (name = options && options.as) {\n        this.names[name] = {\n          segments: allSegments,\n          handlers: handlers\n        };\n      }\n    },\n\n    handlersFor: function handlersFor(name) {\n      var route = this.names[name],\n          result = [];\n      if (!route) {\n        throw new Error(\"There is no route named \" + name);\n      }\n\n      for (var i = 0, l = route.handlers.length; i < l; i++) {\n        result.push(route.handlers[i]);\n      }\n\n      return result;\n    },\n\n    hasRoute: function hasRoute(name) {\n      return !!this.names[name];\n    },\n\n    generate: function generate(name, params) {\n      var route = this.names[name],\n          output = \"\";\n      if (!route) {\n        throw new Error(\"There is no route named \" + name);\n      }\n\n      var segments = route.segments;\n\n      for (var i = 0, l = segments.length; i < l; i++) {\n        var segment = segments[i];\n\n        if (segment instanceof EpsilonSegment) {\n          continue;\n        }\n\n        output += \"/\";\n        output += segment.generate(params);\n      }\n\n      if (output.charAt(0) !== '/') {\n        output = '/' + output;\n      }\n\n      if (params && params.queryParams) {\n        output += this.generateQueryString(params.queryParams);\n      }\n\n      return output;\n    },\n\n    generateQueryString: function generateQueryString(params) {\n      var pairs = [];\n      var keys = [];\n      for (var key in params) {\n        if (params.hasOwnProperty(key)) {\n          keys.push(key);\n        }\n      }\n      keys.sort();\n      for (var i = 0, len = keys.length; i < len; i++) {\n        key = keys[i];\n        var value = params[key];\n        if (value == null) {\n          continue;\n        }\n        var pair = encodeURIComponent(key);\n        if (isArray(value)) {\n          for (var j = 0, l = value.length; j < l; j++) {\n            var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);\n            pairs.push(arrayPair);\n          }\n        } else {\n          pair += \"=\" + encodeURIComponent(value);\n          pairs.push(pair);\n        }\n      }\n\n      if (pairs.length === 0) {\n        return '';\n      }\n\n      return \"?\" + pairs.join(\"&\");\n    },\n\n    parseQueryString: function parseQueryString(queryString) {\n      var pairs = queryString.split(\"&\"),\n          queryParams = {};\n      for (var i = 0; i < pairs.length; i++) {\n        var pair = pairs[i].split('='),\n            key = decodeQueryParamPart(pair[0]),\n            keyLength = key.length,\n            isArray = false,\n            value;\n        if (pair.length === 1) {\n          value = 'true';\n        } else {\n          //Handle arrays\n          if (keyLength > 2 && key.slice(keyLength - 2) === '[]') {\n            isArray = true;\n            key = key.slice(0, keyLength - 2);\n            if (!queryParams[key]) {\n              queryParams[key] = [];\n            }\n          }\n          value = pair[1] ? decodeQueryParamPart(pair[1]) : '';\n        }\n        if (isArray) {\n          queryParams[key].push(value);\n        } else {\n          queryParams[key] = value;\n        }\n      }\n      return queryParams;\n    },\n\n    recognize: function recognize(path, silent) {\n      noWarning = silent;\n      var states = [this.rootState],\n          pathLen,\n          i,\n          l,\n          queryStart,\n          queryParams = {},\n          isSlashDropped = false;\n\n      queryStart = path.indexOf('?');\n      if (queryStart !== -1) {\n        var queryString = path.substr(queryStart + 1, path.length);\n        path = path.substr(0, queryStart);\n        if (queryString) {\n          queryParams = this.parseQueryString(queryString);\n        }\n      }\n\n      path = tryDecode(path);\n      if (!path) return;\n\n      // DEBUG GROUP path\n\n      if (path.charAt(0) !== \"/\") {\n        path = \"/\" + path;\n      }\n\n      pathLen = path.length;\n      if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n        path = path.substr(0, pathLen - 1);\n        isSlashDropped = true;\n      }\n\n      for (i = 0, l = path.length; i < l; i++) {\n        states = recognizeChar(states, path.charAt(i));\n        if (!states.length) {\n          break;\n        }\n      }\n\n      // END DEBUG GROUP\n\n      var solutions = [];\n      for (i = 0, l = states.length; i < l; i++) {\n        if (states[i].handlers) {\n          solutions.push(states[i]);\n        }\n      }\n\n      states = sortSolutions(solutions);\n\n      var state = solutions[0];\n\n      if (state && state.handlers) {\n        // if a trailing slash was dropped and a star segment is the last segment\n        // specified, put the trailing slash back\n        if (isSlashDropped && state.regex.source.slice(-5) === \"(.+)$\") {\n          path = path + \"/\";\n        }\n        return findHandler(state, path, queryParams);\n      }\n    }\n  };\n\n  RouteRecognizer.prototype.map = map;\n\n  var genQuery = RouteRecognizer.prototype.generateQueryString;\n\n  // export default for holding the Vue reference\n  var exports$1 = {};\n  /**\n   * Warn stuff.\n   *\n   * @param {String} msg\n   */\n\n  function warn$1(msg) {\n    /* istanbul ignore next */\n    if (typeof console !== 'undefined') {\n      console.error('[vue-router] ' + msg);\n    }\n  }\n\n  /**\n   * Resolve a relative path.\n   *\n   * @param {String} base\n   * @param {String} relative\n   * @param {Boolean} append\n   * @return {String}\n   */\n\n  function resolvePath(base, relative, append) {\n    var query = base.match(/(\\?.*)$/);\n    if (query) {\n      query = query[1];\n      base = base.slice(0, -query.length);\n    }\n    // a query!\n    if (relative.charAt(0) === '?') {\n      return base + relative;\n    }\n    var stack = base.split('/');\n    // remove trailing segment if:\n    // - not appending\n    // - appending to trailing slash (last segment is empty)\n    if (!append || !stack[stack.length - 1]) {\n      stack.pop();\n    }\n    // resolve relative path\n    var segments = relative.replace(/^\\//, '').split('/');\n    for (var i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n      if (segment === '.') {\n        continue;\n      } else if (segment === '..') {\n        stack.pop();\n      } else {\n        stack.push(segment);\n      }\n    }\n    // ensure leading slash\n    if (stack[0] !== '') {\n      stack.unshift('');\n    }\n    return stack.join('/');\n  }\n\n  /**\n   * Forgiving check for a promise\n   *\n   * @param {Object} p\n   * @return {Boolean}\n   */\n\n  function isPromise(p) {\n    return p && typeof p.then === 'function';\n  }\n\n  /**\n   * Retrive a route config field from a component instance\n   * OR a component contructor.\n   *\n   * @param {Function|Vue} component\n   * @param {String} name\n   * @return {*}\n   */\n\n  function getRouteConfig(component, name) {\n    var options = component && (component.$options || component.options);\n    return options && options.route && options.route[name];\n  }\n\n  /**\n   * Resolve an async component factory. Have to do a dirty\n   * mock here because of Vue core's internal API depends on\n   * an ID check.\n   *\n   * @param {Object} handler\n   * @param {Function} cb\n   */\n\n  var resolver = undefined;\n\n  function resolveAsyncComponent(handler, cb) {\n    if (!resolver) {\n      resolver = {\n        resolve: exports$1.Vue.prototype._resolveComponent,\n        $options: {\n          components: {\n            _: handler.component\n          }\n        }\n      };\n    } else {\n      resolver.$options.components._ = handler.component;\n    }\n    resolver.resolve('_', function (Component) {\n      handler.component = Component;\n      cb(Component);\n    });\n  }\n\n  /**\n   * Map the dynamic segments in a path to params.\n   *\n   * @param {String} path\n   * @param {Object} params\n   * @param {Object} query\n   */\n\n  function mapParams(path, params, query) {\n    if (params === undefined) params = {};\n\n    path = path.replace(/:([^\\/]+)/g, function (_, key) {\n      var val = params[key];\n      /* istanbul ignore if */\n      if (!val) {\n        warn$1('param \"' + key + '\" not found when generating ' + 'path for \"' + path + '\" with params ' + JSON.stringify(params));\n      }\n      return val || '';\n    });\n    if (query) {\n      path += genQuery(query);\n    }\n    return path;\n  }\n\n  var hashRE = /#.*$/;\n\n  var HTML5History = (function () {\n    function HTML5History(_ref) {\n      var root = _ref.root;\n      var onChange = _ref.onChange;\n      babelHelpers.classCallCheck(this, HTML5History);\n\n      if (root && root !== '/') {\n        // make sure there's the starting slash\n        if (root.charAt(0) !== '/') {\n          root = '/' + root;\n        }\n        // remove trailing slash\n        this.root = root.replace(/\\/$/, '');\n        this.rootRE = new RegExp('^\\\\' + this.root);\n      } else {\n        this.root = null;\n      }\n      this.onChange = onChange;\n      // check base tag\n      var baseEl = document.querySelector('base');\n      this.base = baseEl && baseEl.getAttribute('href');\n    }\n\n    HTML5History.prototype.start = function start() {\n      var _this = this;\n\n      this.listener = function (e) {\n        var url = location.pathname + location.search;\n        if (_this.root) {\n          url = url.replace(_this.rootRE, '');\n        }\n        _this.onChange(url, e && e.state, location.hash);\n      };\n      window.addEventListener('popstate', this.listener);\n      this.listener();\n    };\n\n    HTML5History.prototype.stop = function stop() {\n      window.removeEventListener('popstate', this.listener);\n    };\n\n    HTML5History.prototype.go = function go(path, replace, append) {\n      var url = this.formatPath(path, append);\n      if (replace) {\n        history.replaceState({}, '', url);\n      } else {\n        // record scroll position by replacing current state\n        history.replaceState({\n          pos: {\n            x: window.pageXOffset,\n            y: window.pageYOffset\n          }\n        }, '', location.href);\n        // then push new state\n        history.pushState({}, '', url);\n      }\n      var hashMatch = path.match(hashRE);\n      var hash = hashMatch && hashMatch[0];\n      path = url\n      // strip hash so it doesn't mess up params\n      .replace(hashRE, '')\n      // remove root before matching\n      .replace(this.rootRE, '');\n      this.onChange(path, null, hash);\n    };\n\n    HTML5History.prototype.formatPath = function formatPath(path, append) {\n      return path.charAt(0) === '/'\n      // absolute path\n      ? this.root ? this.root + '/' + path.replace(/^\\//, '') : path : resolvePath(this.base || location.pathname, path, append);\n    };\n\n    return HTML5History;\n  })();\n\n  var HashHistory = (function () {\n    function HashHistory(_ref) {\n      var hashbang = _ref.hashbang;\n      var onChange = _ref.onChange;\n      babelHelpers.classCallCheck(this, HashHistory);\n\n      this.hashbang = hashbang;\n      this.onChange = onChange;\n    }\n\n    HashHistory.prototype.start = function start() {\n      var self = this;\n      this.listener = function () {\n        var path = location.hash;\n        var raw = path.replace(/^#!?/, '');\n        // always\n        if (raw.charAt(0) !== '/') {\n          raw = '/' + raw;\n        }\n        var formattedPath = self.formatPath(raw);\n        if (formattedPath !== path) {\n          location.replace(formattedPath);\n          return;\n        }\n        // determine query\n        // note it's possible to have queries in both the actual URL\n        // and the hash fragment itself.\n        var query = location.search && path.indexOf('?') > -1 ? '&' + location.search.slice(1) : location.search;\n        self.onChange(path.replace(/^#!?/, '') + query);\n      };\n      window.addEventListener('hashchange', this.listener);\n      this.listener();\n    };\n\n    HashHistory.prototype.stop = function stop() {\n      window.removeEventListener('hashchange', this.listener);\n    };\n\n    HashHistory.prototype.go = function go(path, replace, append) {\n      path = this.formatPath(path, append);\n      if (replace) {\n        location.replace(path);\n      } else {\n        location.hash = path;\n      }\n    };\n\n    HashHistory.prototype.formatPath = function formatPath(path, append) {\n      var isAbsoloute = path.charAt(0) === '/';\n      var prefix = '#' + (this.hashbang ? '!' : '');\n      return isAbsoloute ? prefix + path : prefix + resolvePath(location.hash.replace(/^#!?/, ''), path, append);\n    };\n\n    return HashHistory;\n  })();\n\n  var AbstractHistory = (function () {\n    function AbstractHistory(_ref) {\n      var onChange = _ref.onChange;\n      babelHelpers.classCallCheck(this, AbstractHistory);\n\n      this.onChange = onChange;\n      this.currentPath = '/';\n    }\n\n    AbstractHistory.prototype.start = function start() {\n      this.onChange('/');\n    };\n\n    AbstractHistory.prototype.stop = function stop() {\n      // noop\n    };\n\n    AbstractHistory.prototype.go = function go(path, replace, append) {\n      path = this.currentPath = this.formatPath(path, append);\n      this.onChange(path);\n    };\n\n    AbstractHistory.prototype.formatPath = function formatPath(path, append) {\n      return path.charAt(0) === '/' ? path : resolvePath(this.currentPath, path, append);\n    };\n\n    return AbstractHistory;\n  })();\n\n  /**\n   * Determine the reusability of an existing router view.\n   *\n   * @param {Directive} view\n   * @param {Object} handler\n   * @param {Transition} transition\n   */\n\n  function canReuse(view, handler, transition) {\n    var component = view.childVM;\n    if (!component || !handler) {\n      return false;\n    }\n    // important: check view.Component here because it may\n    // have been changed in activate hook\n    if (view.Component !== handler.component) {\n      return false;\n    }\n    var canReuseFn = getRouteConfig(component, 'canReuse');\n    return typeof canReuseFn === 'boolean' ? canReuseFn : canReuseFn ? canReuseFn.call(component, {\n      to: transition.to,\n      from: transition.from\n    }) : true; // defaults to true\n  }\n\n  /**\n   * Check if a component can deactivate.\n   *\n   * @param {Directive} view\n   * @param {Transition} transition\n   * @param {Function} next\n   */\n\n  function canDeactivate(view, transition, next) {\n    var fromComponent = view.childVM;\n    var hook = getRouteConfig(fromComponent, 'canDeactivate');\n    if (!hook) {\n      next();\n    } else {\n      transition.callHook(hook, fromComponent, next, {\n        expectBoolean: true\n      });\n    }\n  }\n\n  /**\n   * Check if a component can activate.\n   *\n   * @param {Object} handler\n   * @param {Transition} transition\n   * @param {Function} next\n   */\n\n  function canActivate(handler, transition, next) {\n    resolveAsyncComponent(handler, function (Component) {\n      // have to check due to async-ness\n      if (transition.aborted) {\n        return;\n      }\n      // determine if this component can be activated\n      var hook = getRouteConfig(Component, 'canActivate');\n      if (!hook) {\n        next();\n      } else {\n        transition.callHook(hook, null, next, {\n          expectBoolean: true\n        });\n      }\n    });\n  }\n\n  /**\n   * Call deactivate hooks for existing router-views.\n   *\n   * @param {Directive} view\n   * @param {Transition} transition\n   * @param {Function} next\n   */\n\n  function deactivate(view, transition, next) {\n    var component = view.childVM;\n    var hook = getRouteConfig(component, 'deactivate');\n    if (!hook) {\n      next();\n    } else {\n      transition.callHooks(hook, component, next);\n    }\n  }\n\n  /**\n   * Activate / switch component for a router-view.\n   *\n   * @param {Directive} view\n   * @param {Transition} transition\n   * @param {Number} depth\n   * @param {Function} [cb]\n   */\n\n  function activate(view, transition, depth, cb, reuse) {\n    var handler = transition.activateQueue[depth];\n    if (!handler) {\n      saveChildView(view);\n      if (view._bound) {\n        view.setComponent(null);\n      }\n      cb && cb();\n      return;\n    }\n\n    var Component = view.Component = handler.component;\n    var activateHook = getRouteConfig(Component, 'activate');\n    var dataHook = getRouteConfig(Component, 'data');\n    var waitForData = getRouteConfig(Component, 'waitForData');\n\n    view.depth = depth;\n    view.activated = false;\n\n    var component = undefined;\n    var loading = !!(dataHook && !waitForData);\n\n    // \"reuse\" is a flag passed down when the parent view is\n    // either reused via keep-alive or as a child of a kept-alive view.\n    // of course we can only reuse if the current kept-alive instance\n    // is of the correct type.\n    reuse = reuse && view.childVM && view.childVM.constructor === Component;\n\n    if (reuse) {\n      // just reuse\n      component = view.childVM;\n      component.$loadingRouteData = loading;\n    } else {\n      saveChildView(view);\n\n      // unbuild current component. this step also destroys\n      // and removes all nested child views.\n      view.unbuild(true);\n\n      // build the new component. this will also create the\n      // direct child view of the current one. it will register\n      // itself as view.childView.\n      component = view.build({\n        _meta: {\n          $loadingRouteData: loading\n        },\n        created: function created() {\n          this._routerView = view;\n        }\n      });\n\n      // handle keep-alive.\n      // when a kept-alive child vm is restored, we need to\n      // add its cached child views into the router's view list,\n      // and also properly update current view's child view.\n      if (view.keepAlive) {\n        component.$loadingRouteData = loading;\n        var cachedChildView = component._keepAliveRouterView;\n        if (cachedChildView) {\n          view.childView = cachedChildView;\n          component._keepAliveRouterView = null;\n        }\n      }\n    }\n\n    // cleanup the component in case the transition is aborted\n    // before the component is ever inserted.\n    var cleanup = function cleanup() {\n      component.$destroy();\n    };\n\n    // actually insert the component and trigger transition\n    var insert = function insert() {\n      if (reuse) {\n        cb && cb();\n        return;\n      }\n      var router = transition.router;\n      if (router._rendered || router._transitionOnLoad) {\n        view.transition(component);\n      } else {\n        // no transition on first render, manual transition\n        /* istanbul ignore if */\n        if (view.setCurrent) {\n          // 0.12 compat\n          view.setCurrent(component);\n        } else {\n          // 1.0\n          view.childVM = component;\n        }\n        component.$before(view.anchor, null, false);\n      }\n      cb && cb();\n    };\n\n    var afterData = function afterData() {\n      // activate the child view\n      if (view.childView) {\n        activate(view.childView, transition, depth + 1, null, reuse || view.keepAlive);\n      }\n      insert();\n    };\n\n    // called after activation hook is resolved\n    var afterActivate = function afterActivate() {\n      view.activated = true;\n      if (dataHook && waitForData) {\n        // wait until data loaded to insert\n        loadData(component, transition, dataHook, afterData, cleanup);\n      } else {\n        // load data and insert at the same time\n        if (dataHook) {\n          loadData(component, transition, dataHook);\n        }\n        afterData();\n      }\n    };\n\n    if (activateHook) {\n      transition.callHooks(activateHook, component, afterActivate, {\n        cleanup: cleanup,\n        postActivate: true\n      });\n    } else {\n      afterActivate();\n    }\n  }\n\n  /**\n   * Reuse a view, just reload data if necessary.\n   *\n   * @param {Directive} view\n   * @param {Transition} transition\n   */\n\n  function reuse(view, transition) {\n    var component = view.childVM;\n    var dataHook = getRouteConfig(component, 'data');\n    if (dataHook) {\n      loadData(component, transition, dataHook);\n    }\n  }\n\n  /**\n   * Asynchronously load and apply data to component.\n   *\n   * @param {Vue} component\n   * @param {Transition} transition\n   * @param {Function} hook\n   * @param {Function} cb\n   * @param {Function} cleanup\n   */\n\n  function loadData(component, transition, hook, cb, cleanup) {\n    component.$loadingRouteData = true;\n    transition.callHooks(hook, component, function () {\n      component.$loadingRouteData = false;\n      component.$emit('route-data-loaded', component);\n      cb && cb();\n    }, {\n      cleanup: cleanup,\n      postActivate: true,\n      processData: function processData(data) {\n        // handle promise sugar syntax\n        var promises = [];\n        if (isPlainObject(data)) {\n          Object.keys(data).forEach(function (key) {\n            var val = data[key];\n            if (isPromise(val)) {\n              promises.push(val.then(function (resolvedVal) {\n                component.$set(key, resolvedVal);\n              }));\n            } else {\n              component.$set(key, val);\n            }\n          });\n        }\n        if (promises.length) {\n          return promises[0].constructor.all(promises);\n        }\n      }\n    });\n  }\n\n  /**\n   * Save the child view for a kept-alive view so that\n   * we can restore it when it is switched back to.\n   *\n   * @param {Directive} view\n   */\n\n  function saveChildView(view) {\n    if (view.keepAlive && view.childVM && view.childView) {\n      view.childVM._keepAliveRouterView = view.childView;\n    }\n    view.childView = null;\n  }\n\n  /**\n   * Check plain object.\n   *\n   * @param {*} val\n   */\n\n  function isPlainObject(val) {\n    return Object.prototype.toString.call(val) === '[object Object]';\n  }\n\n  /**\n   * A RouteTransition object manages the pipeline of a\n   * router-view switching process. This is also the object\n   * passed into user route hooks.\n   *\n   * @param {Router} router\n   * @param {Route} to\n   * @param {Route} from\n   */\n\n  var RouteTransition = (function () {\n    function RouteTransition(router, to, from) {\n      babelHelpers.classCallCheck(this, RouteTransition);\n\n      this.router = router;\n      this.to = to;\n      this.from = from;\n      this.next = null;\n      this.aborted = false;\n      this.done = false;\n    }\n\n    /**\n     * Abort current transition and return to previous location.\n     */\n\n    RouteTransition.prototype.abort = function abort() {\n      if (!this.aborted) {\n        this.aborted = true;\n        // if the root path throws an error during validation\n        // on initial load, it gets caught in an infinite loop.\n        var abortingOnLoad = !this.from.path && this.to.path === '/';\n        if (!abortingOnLoad) {\n          this.router.replace(this.from.path || '/');\n        }\n      }\n    };\n\n    /**\n     * Abort current transition and redirect to a new location.\n     *\n     * @param {String} path\n     */\n\n    RouteTransition.prototype.redirect = function redirect(path) {\n      if (!this.aborted) {\n        this.aborted = true;\n        if (typeof path === 'string') {\n          path = mapParams(path, this.to.params, this.to.query);\n        } else {\n          path.params = path.params || this.to.params;\n          path.query = path.query || this.to.query;\n        }\n        this.router.replace(path);\n      }\n    };\n\n    /**\n     * A router view transition's pipeline can be described as\n     * follows, assuming we are transitioning from an existing\n     * <router-view> chain [Component A, Component B] to a new\n     * chain [Component A, Component C]:\n     *\n     *  A    A\n     *  | => |\n     *  B    C\n     *\n     * 1. Reusablity phase:\n     *   -> canReuse(A, A)\n     *   -> canReuse(B, C)\n     *   -> determine new queues:\n     *      - deactivation: [B]\n     *      - activation: [C]\n     *\n     * 2. Validation phase:\n     *   -> canDeactivate(B)\n     *   -> canActivate(C)\n     *\n     * 3. Activation phase:\n     *   -> deactivate(B)\n     *   -> activate(C)\n     *\n     * Each of these steps can be asynchronous, and any\n     * step can potentially abort the transition.\n     *\n     * @param {Function} cb\n     */\n\n    RouteTransition.prototype.start = function start(cb) {\n      var transition = this;\n\n      // determine the queue of views to deactivate\n      var deactivateQueue = [];\n      var view = this.router._rootView;\n      while (view) {\n        deactivateQueue.unshift(view);\n        view = view.childView;\n      }\n      var reverseDeactivateQueue = deactivateQueue.slice().reverse();\n\n      // determine the queue of route handlers to activate\n      var activateQueue = this.activateQueue = toArray(this.to.matched).map(function (match) {\n        return match.handler;\n      });\n\n      // 1. Reusability phase\n      var i = undefined,\n          reuseQueue = undefined;\n      for (i = 0; i < reverseDeactivateQueue.length; i++) {\n        if (!canReuse(reverseDeactivateQueue[i], activateQueue[i], transition)) {\n          break;\n        }\n      }\n      if (i > 0) {\n        reuseQueue = reverseDeactivateQueue.slice(0, i);\n        deactivateQueue = reverseDeactivateQueue.slice(i).reverse();\n        activateQueue = activateQueue.slice(i);\n      }\n\n      // 2. Validation phase\n      transition.runQueue(deactivateQueue, canDeactivate, function () {\n        transition.runQueue(activateQueue, canActivate, function () {\n          transition.runQueue(deactivateQueue, deactivate, function () {\n            // 3. Activation phase\n\n            // Update router current route\n            transition.router._onTransitionValidated(transition);\n\n            // trigger reuse for all reused views\n            reuseQueue && reuseQueue.forEach(function (view) {\n              return reuse(view, transition);\n            });\n\n            // the root of the chain that needs to be replaced\n            // is the top-most non-reusable view.\n            if (deactivateQueue.length) {\n              var _view = deactivateQueue[deactivateQueue.length - 1];\n              var depth = reuseQueue ? reuseQueue.length : 0;\n              activate(_view, transition, depth, cb);\n            } else {\n              cb();\n            }\n          });\n        });\n      });\n    };\n\n    /**\n     * Asynchronously and sequentially apply a function to a\n     * queue.\n     *\n     * @param {Array} queue\n     * @param {Function} fn\n     * @param {Function} cb\n     */\n\n    RouteTransition.prototype.runQueue = function runQueue(queue, fn, cb) {\n      var transition = this;\n      step(0);\n      function step(index) {\n        if (index >= queue.length) {\n          cb();\n        } else {\n          fn(queue[index], transition, function () {\n            step(index + 1);\n          });\n        }\n      }\n    };\n\n    /**\n     * Call a user provided route transition hook and handle\n     * the response (e.g. if the user returns a promise).\n     *\n     * If the user neither expects an argument nor returns a\n     * promise, the hook is assumed to be synchronous.\n     *\n     * @param {Function} hook\n     * @param {*} [context]\n     * @param {Function} [cb]\n     * @param {Object} [options]\n     *                 - {Boolean} expectBoolean\n     *                 - {Boolean} postActive\n     *                 - {Function} processData\n     *                 - {Function} cleanup\n     */\n\n    RouteTransition.prototype.callHook = function callHook(hook, context, cb) {\n      var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n      var _ref$expectBoolean = _ref.expectBoolean;\n      var expectBoolean = _ref$expectBoolean === undefined ? false : _ref$expectBoolean;\n      var _ref$postActivate = _ref.postActivate;\n      var postActivate = _ref$postActivate === undefined ? false : _ref$postActivate;\n      var processData = _ref.processData;\n      var cleanup = _ref.cleanup;\n\n      var transition = this;\n      var nextCalled = false;\n\n      // abort the transition\n      var abort = function abort() {\n        cleanup && cleanup();\n        transition.abort();\n      };\n\n      // handle errors\n      var onError = function onError(err) {\n        postActivate ? next() : abort();\n        if (err && !transition.router._suppress) {\n          warn$1('Uncaught error during transition: ');\n          throw err instanceof Error ? err : new Error(err);\n        }\n      };\n\n      // since promise swallows errors, we have to\n      // throw it in the next tick...\n      var onPromiseError = function onPromiseError(err) {\n        try {\n          onError(err);\n        } catch (e) {\n          setTimeout(function () {\n            throw e;\n          }, 0);\n        }\n      };\n\n      // advance the transition to the next step\n      var next = function next() {\n        if (nextCalled) {\n          warn$1('transition.next() should be called only once.');\n          return;\n        }\n        nextCalled = true;\n        if (transition.aborted) {\n          cleanup && cleanup();\n          return;\n        }\n        cb && cb();\n      };\n\n      var nextWithBoolean = function nextWithBoolean(res) {\n        if (typeof res === 'boolean') {\n          res ? next() : abort();\n        } else if (isPromise(res)) {\n          res.then(function (ok) {\n            ok ? next() : abort();\n          }, onPromiseError);\n        } else if (!hook.length) {\n          next();\n        }\n      };\n\n      var nextWithData = function nextWithData(data) {\n        var res = undefined;\n        try {\n          res = processData(data);\n        } catch (err) {\n          return onError(err);\n        }\n        if (isPromise(res)) {\n          res.then(next, onPromiseError);\n        } else {\n          next();\n        }\n      };\n\n      // expose a clone of the transition object, so that each\n      // hook gets a clean copy and prevent the user from\n      // messing with the internals.\n      var exposed = {\n        to: transition.to,\n        from: transition.from,\n        abort: abort,\n        next: processData ? nextWithData : next,\n        redirect: function redirect() {\n          transition.redirect.apply(transition, arguments);\n        }\n      };\n\n      // actually call the hook\n      var res = undefined;\n      try {\n        res = hook.call(context, exposed);\n      } catch (err) {\n        return onError(err);\n      }\n\n      if (expectBoolean) {\n        // boolean hooks\n        nextWithBoolean(res);\n      } else if (isPromise(res)) {\n        // promise\n        if (processData) {\n          res.then(nextWithData, onPromiseError);\n        } else {\n          res.then(next, onPromiseError);\n        }\n      } else if (processData && isPlainOjbect(res)) {\n        // data promise sugar\n        nextWithData(res);\n      } else if (!hook.length) {\n        next();\n      }\n    };\n\n    /**\n     * Call a single hook or an array of async hooks in series.\n     *\n     * @param {Array} hooks\n     * @param {*} context\n     * @param {Function} cb\n     * @param {Object} [options]\n     */\n\n    RouteTransition.prototype.callHooks = function callHooks(hooks, context, cb, options) {\n      var _this = this;\n\n      if (Array.isArray(hooks)) {\n        this.runQueue(hooks, function (hook, _, next) {\n          if (!_this.aborted) {\n            _this.callHook(hook, context, next, options);\n          }\n        }, cb);\n      } else {\n        this.callHook(hooks, context, cb, options);\n      }\n    };\n\n    return RouteTransition;\n  })();\n\n  function isPlainOjbect(val) {\n    return Object.prototype.toString.call(val) === '[object Object]';\n  }\n\n  function toArray(val) {\n    return val ? Array.prototype.slice.call(val) : [];\n  }\n\n  var internalKeysRE = /^(component|subRoutes|fullPath)$/;\n\n  /**\n   * Route Context Object\n   *\n   * @param {String} path\n   * @param {Router} router\n   */\n\n  var Route = function Route(path, router) {\n    var _this = this;\n\n    babelHelpers.classCallCheck(this, Route);\n\n    var matched = router._recognizer.recognize(path);\n    if (matched) {\n      // copy all custom fields from route configs\n      [].forEach.call(matched, function (match) {\n        for (var key in match.handler) {\n          if (!internalKeysRE.test(key)) {\n            _this[key] = match.handler[key];\n          }\n        }\n      });\n      // set query and params\n      this.query = matched.queryParams;\n      this.params = [].reduce.call(matched, function (prev, cur) {\n        if (cur.params) {\n          for (var key in cur.params) {\n            prev[key] = cur.params[key];\n          }\n        }\n        return prev;\n      }, {});\n    }\n    // expose path and router\n    this.path = path;\n    // for internal use\n    this.matched = matched || router._notFoundHandler;\n    // internal reference to router\n    Object.defineProperty(this, 'router', {\n      enumerable: false,\n      value: router\n    });\n    // Important: freeze self to prevent observation\n    Object.freeze(this);\n  };\n\n  function applyOverride (Vue) {\n    var _Vue$util = Vue.util;\n    var extend = _Vue$util.extend;\n    var isArray = _Vue$util.isArray;\n    var defineReactive = _Vue$util.defineReactive;\n\n    // override Vue's init and destroy process to keep track of router instances\n    var init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      options = options || {};\n      var root = options._parent || options.parent || this;\n      var router = root.$router;\n      var route = root.$route;\n      if (router) {\n        // expose router\n        this.$router = router;\n        router._children.push(this);\n        /* istanbul ignore if */\n        if (this._defineMeta) {\n          // 0.12\n          this._defineMeta('$route', route);\n        } else {\n          // 1.0\n          defineReactive(this, '$route', route);\n        }\n      }\n      init.call(this, options);\n    };\n\n    var destroy = Vue.prototype._destroy;\n    Vue.prototype._destroy = function () {\n      if (!this._isBeingDestroyed && this.$router) {\n        this.$router._children.$remove(this);\n      }\n      destroy.apply(this, arguments);\n    };\n\n    // 1.0 only: enable route mixins\n    var strats = Vue.config.optionMergeStrategies;\n    var hooksToMergeRE = /^(data|activate|deactivate)$/;\n\n    if (strats) {\n      strats.route = function (parentVal, childVal) {\n        if (!childVal) return parentVal;\n        if (!parentVal) return childVal;\n        var ret = {};\n        extend(ret, parentVal);\n        for (var key in childVal) {\n          var a = ret[key];\n          var b = childVal[key];\n          // for data, activate and deactivate, we need to merge them into\n          // arrays similar to lifecycle hooks.\n          if (a && hooksToMergeRE.test(key)) {\n            ret[key] = (isArray(a) ? a : [a]).concat(b);\n          } else {\n            ret[key] = b;\n          }\n        }\n        return ret;\n      };\n    }\n  }\n\n  function View (Vue) {\n\n    var _ = Vue.util;\n    var componentDef =\n    // 0.12\n    Vue.directive('_component') ||\n    // 1.0\n    Vue.internalDirectives.component;\n    // <router-view> extends the internal component directive\n    var viewDef = _.extend({}, componentDef);\n\n    // with some overrides\n    _.extend(viewDef, {\n\n      _isRouterView: true,\n\n      bind: function bind() {\n        var route = this.vm.$route;\n        /* istanbul ignore if */\n        if (!route) {\n          warn$1('<router-view> can only be used inside a ' + 'router-enabled app.');\n          return;\n        }\n        // force dynamic directive so v-component doesn't\n        // attempt to build right now\n        this._isDynamicLiteral = true;\n        // finally, init by delegating to v-component\n        componentDef.bind.call(this);\n\n        // locate the parent view\n        var parentView = undefined;\n        var parent = this.vm;\n        while (parent) {\n          if (parent._routerView) {\n            parentView = parent._routerView;\n            break;\n          }\n          parent = parent.$parent;\n        }\n        if (parentView) {\n          // register self as a child of the parent view,\n          // instead of activating now. This is so that the\n          // child's activate hook is called after the\n          // parent's has resolved.\n          this.parentView = parentView;\n          parentView.childView = this;\n        } else {\n          // this is the root view!\n          var router = route.router;\n          router._rootView = this;\n        }\n\n        // handle late-rendered view\n        // two possibilities:\n        // 1. root view rendered after transition has been\n        //    validated;\n        // 2. child view rendered after parent view has been\n        //    activated.\n        var transition = route.router._currentTransition;\n        if (!parentView && transition.done || parentView && parentView.activated) {\n          var depth = parentView ? parentView.depth + 1 : 0;\n          activate(this, transition, depth);\n        }\n      },\n\n      unbind: function unbind() {\n        if (this.parentView) {\n          this.parentView.childView = null;\n        }\n        componentDef.unbind.call(this);\n      }\n    });\n\n    Vue.elementDirective('router-view', viewDef);\n  }\n\n  var trailingSlashRE = /\\/$/;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n  var queryStringRE = /\\?.*$/;\n\n  // install v-link, which provides navigation support for\n  // HTML5 history mode\n  function Link (Vue) {\n    var _Vue$util = Vue.util;\n    var _bind = _Vue$util.bind;\n    var isObject = _Vue$util.isObject;\n    var addClass = _Vue$util.addClass;\n    var removeClass = _Vue$util.removeClass;\n\n    var onPriority = Vue.directive('on').priority;\n    var LINK_UPDATE = '__vue-router-link-update__';\n\n    var activeId = 0;\n\n    Vue.directive('link-active', {\n      priority: 9999,\n      bind: function bind() {\n        var _this = this;\n\n        var id = String(activeId++);\n        // collect v-links contained within this element.\n        // we need do this here before the parent-child relationship\n        // gets messed up by terminal directives (if, for, components)\n        var childLinks = this.el.querySelectorAll('[v-link]');\n        for (var i = 0, l = childLinks.length; i < l; i++) {\n          var link = childLinks[i];\n          var existingId = link.getAttribute(LINK_UPDATE);\n          var value = existingId ? existingId + ',' + id : id;\n          // leave a mark on the link element which can be persisted\n          // through fragment clones.\n          link.setAttribute(LINK_UPDATE, value);\n        }\n        this.vm.$on(LINK_UPDATE, this.cb = function (link, path) {\n          if (link.activeIds.indexOf(id) > -1) {\n            link.updateClasses(path, _this.el);\n          }\n        });\n      },\n      unbind: function unbind() {\n        this.vm.$off(LINK_UPDATE, this.cb);\n      }\n    });\n\n    Vue.directive('link', {\n      priority: onPriority - 2,\n\n      bind: function bind() {\n        var vm = this.vm;\n        /* istanbul ignore if */\n        if (!vm.$route) {\n          warn$1('v-link can only be used inside a router-enabled app.');\n          return;\n        }\n        this.router = vm.$route.router;\n        // update things when the route changes\n        this.unwatch = vm.$watch('$route', _bind(this.onRouteUpdate, this));\n        // check v-link-active ids\n        var activeIds = this.el.getAttribute(LINK_UPDATE);\n        if (activeIds) {\n          this.el.removeAttribute(LINK_UPDATE);\n          this.activeIds = activeIds.split(',');\n        }\n        // no need to handle click if link expects to be opened\n        // in a new window/tab.\n        /* istanbul ignore if */\n        if (this.el.tagName === 'A' && this.el.getAttribute('target') === '_blank') {\n          return;\n        }\n        // handle click\n        this.handler = _bind(this.onClick, this);\n        this.el.addEventListener('click', this.handler);\n      },\n\n      update: function update(target) {\n        this.target = target;\n        if (isObject(target)) {\n          this.append = target.append;\n          this.exact = target.exact;\n          this.prevActiveClass = this.activeClass;\n          this.activeClass = target.activeClass;\n        }\n        this.onRouteUpdate(this.vm.$route);\n      },\n\n      onClick: function onClick(e) {\n        // don't redirect with control keys\n        /* istanbul ignore if */\n        if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n        // don't redirect when preventDefault called\n        /* istanbul ignore if */\n        if (e.defaultPrevented) return;\n        // don't redirect on right click\n        /* istanbul ignore if */\n        if (e.button !== 0) return;\n\n        var target = this.target;\n        if (target) {\n          // v-link with expression, just go\n          e.preventDefault();\n          this.router.go(target);\n        } else {\n          // no expression, delegate for an <a> inside\n          var el = e.target;\n          while (el.tagName !== 'A' && el !== this.el) {\n            el = el.parentNode;\n          }\n          if (el.tagName === 'A' && sameOrigin(el)) {\n            e.preventDefault();\n            var path = el.pathname;\n            if (this.router.history.root) {\n              path = path.replace(this.router.history.rootRE, '');\n            }\n            this.router.go({\n              path: path,\n              replace: target && target.replace,\n              append: target && target.append\n            });\n          }\n        }\n      },\n\n      onRouteUpdate: function onRouteUpdate(route) {\n        // router.stringifyPath is dependent on current route\n        // and needs to be called again whenver route changes.\n        var newPath = this.router.stringifyPath(this.target);\n        if (this.path !== newPath) {\n          this.path = newPath;\n          this.updateActiveMatch();\n          this.updateHref();\n        }\n        if (this.activeIds) {\n          this.vm.$emit(LINK_UPDATE, this, route.path);\n        } else {\n          this.updateClasses(route.path, this.el);\n        }\n      },\n\n      updateActiveMatch: function updateActiveMatch() {\n        this.activeRE = this.path && !this.exact ? new RegExp('^' + this.path.replace(/\\/$/, '').replace(queryStringRE, '').replace(regexEscapeRE, '\\\\$&') + '(\\\\/|$)') : null;\n      },\n\n      updateHref: function updateHref() {\n        if (this.el.tagName !== 'A') {\n          return;\n        }\n        var path = this.path;\n        var router = this.router;\n        var isAbsolute = path.charAt(0) === '/';\n        // do not format non-hash relative paths\n        var href = path && (router.mode === 'hash' || isAbsolute) ? router.history.formatPath(path, this.append) : path;\n        if (href) {\n          this.el.href = href;\n        } else {\n          this.el.removeAttribute('href');\n        }\n      },\n\n      updateClasses: function updateClasses(path, el) {\n        var activeClass = this.activeClass || this.router._linkActiveClass;\n        // clear old class\n        if (this.prevActiveClass && this.prevActiveClass !== activeClass) {\n          toggleClasses(el, this.prevActiveClass, removeClass);\n        }\n        // remove query string before matching\n        var dest = this.path.replace(queryStringRE, '');\n        path = path.replace(queryStringRE, '');\n        // add new class\n        if (this.exact) {\n          if (dest === path ||\n          // also allow additional trailing slash\n          dest.charAt(dest.length - 1) !== '/' && dest === path.replace(trailingSlashRE, '')) {\n            toggleClasses(el, activeClass, addClass);\n          } else {\n            toggleClasses(el, activeClass, removeClass);\n          }\n        } else {\n          if (this.activeRE && this.activeRE.test(path)) {\n            toggleClasses(el, activeClass, addClass);\n          } else {\n            toggleClasses(el, activeClass, removeClass);\n          }\n        }\n      },\n\n      unbind: function unbind() {\n        this.el.removeEventListener('click', this.handler);\n        this.unwatch && this.unwatch();\n      }\n    });\n\n    function sameOrigin(link) {\n      return link.protocol === location.protocol && link.hostname === location.hostname && link.port === location.port;\n    }\n\n    // this function is copied from v-bind:class implementation until\n    // we properly expose it...\n    function toggleClasses(el, key, fn) {\n      key = key.trim();\n      if (key.indexOf(' ') === -1) {\n        fn(el, key);\n        return;\n      }\n      var keys = key.split(/\\s+/);\n      for (var i = 0, l = keys.length; i < l; i++) {\n        fn(el, keys[i]);\n      }\n    }\n  }\n\n  var historyBackends = {\n    abstract: AbstractHistory,\n    hash: HashHistory,\n    html5: HTML5History\n  };\n\n  // late bind during install\n  var Vue = undefined;\n\n  /**\n   * Router constructor\n   *\n   * @param {Object} [options]\n   */\n\n  var Router = (function () {\n    function Router() {\n      var _this = this;\n\n      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref$hashbang = _ref.hashbang;\n      var hashbang = _ref$hashbang === undefined ? true : _ref$hashbang;\n      var _ref$abstract = _ref.abstract;\n      var abstract = _ref$abstract === undefined ? false : _ref$abstract;\n      var _ref$history = _ref.history;\n      var history = _ref$history === undefined ? false : _ref$history;\n      var _ref$saveScrollPosition = _ref.saveScrollPosition;\n      var saveScrollPosition = _ref$saveScrollPosition === undefined ? false : _ref$saveScrollPosition;\n      var _ref$transitionOnLoad = _ref.transitionOnLoad;\n      var transitionOnLoad = _ref$transitionOnLoad === undefined ? false : _ref$transitionOnLoad;\n      var _ref$suppressTransitionError = _ref.suppressTransitionError;\n      var suppressTransitionError = _ref$suppressTransitionError === undefined ? false : _ref$suppressTransitionError;\n      var _ref$root = _ref.root;\n      var root = _ref$root === undefined ? null : _ref$root;\n      var _ref$linkActiveClass = _ref.linkActiveClass;\n      var linkActiveClass = _ref$linkActiveClass === undefined ? 'v-link-active' : _ref$linkActiveClass;\n      babelHelpers.classCallCheck(this, Router);\n\n      /* istanbul ignore if */\n      if (!Router.installed) {\n        throw new Error('Please install the Router with Vue.use() before ' + 'creating an instance.');\n      }\n\n      // Vue instances\n      this.app = null;\n      this._children = [];\n\n      // route recognizer\n      this._recognizer = new RouteRecognizer();\n      this._guardRecognizer = new RouteRecognizer();\n\n      // state\n      this._started = false;\n      this._startCb = null;\n      this._currentRoute = {};\n      this._currentTransition = null;\n      this._previousTransition = null;\n      this._notFoundHandler = null;\n      this._notFoundRedirect = null;\n      this._beforeEachHooks = [];\n      this._afterEachHooks = [];\n\n      // trigger transition on initial render?\n      this._rendered = false;\n      this._transitionOnLoad = transitionOnLoad;\n\n      // history mode\n      this._root = root;\n      this._abstract = abstract;\n      this._hashbang = hashbang;\n\n      // check if HTML5 history is available\n      var hasPushState = typeof window !== 'undefined' && window.history && window.history.pushState;\n      this._history = history && hasPushState;\n      this._historyFallback = history && !hasPushState;\n\n      // create history object\n      var inBrowser = Vue.util.inBrowser;\n      this.mode = !inBrowser || this._abstract ? 'abstract' : this._history ? 'html5' : 'hash';\n\n      var History = historyBackends[this.mode];\n      this.history = new History({\n        root: root,\n        hashbang: this._hashbang,\n        onChange: function onChange(path, state, anchor) {\n          _this._match(path, state, anchor);\n        }\n      });\n\n      // other options\n      this._saveScrollPosition = saveScrollPosition;\n      this._linkActiveClass = linkActiveClass;\n      this._suppress = suppressTransitionError;\n    }\n\n    /**\n     * Allow directly passing components to a route\n     * definition.\n     *\n     * @param {String} path\n     * @param {Object} handler\n     */\n\n    // API ===================================================\n\n    /**\n    * Register a map of top-level paths.\n    *\n    * @param {Object} map\n    */\n\n    Router.prototype.map = function map(_map) {\n      for (var route in _map) {\n        this.on(route, _map[route]);\n      }\n      return this;\n    };\n\n    /**\n     * Register a single root-level path\n     *\n     * @param {String} rootPath\n     * @param {Object} handler\n     *                 - {String} component\n     *                 - {Object} [subRoutes]\n     *                 - {Boolean} [forceRefresh]\n     *                 - {Function} [before]\n     *                 - {Function} [after]\n     */\n\n    Router.prototype.on = function on(rootPath, handler) {\n      if (rootPath === '*') {\n        this._notFound(handler);\n      } else {\n        this._addRoute(rootPath, handler, []);\n      }\n      return this;\n    };\n\n    /**\n     * Set redirects.\n     *\n     * @param {Object} map\n     */\n\n    Router.prototype.redirect = function redirect(map) {\n      for (var path in map) {\n        this._addRedirect(path, map[path]);\n      }\n      return this;\n    };\n\n    /**\n     * Set aliases.\n     *\n     * @param {Object} map\n     */\n\n    Router.prototype.alias = function alias(map) {\n      for (var path in map) {\n        this._addAlias(path, map[path]);\n      }\n      return this;\n    };\n\n    /**\n     * Set global before hook.\n     *\n     * @param {Function} fn\n     */\n\n    Router.prototype.beforeEach = function beforeEach(fn) {\n      this._beforeEachHooks.push(fn);\n      return this;\n    };\n\n    /**\n     * Set global after hook.\n     *\n     * @param {Function} fn\n     */\n\n    Router.prototype.afterEach = function afterEach(fn) {\n      this._afterEachHooks.push(fn);\n      return this;\n    };\n\n    /**\n     * Navigate to a given path.\n     * The path can be an object describing a named path in\n     * the format of { name: '...', params: {}, query: {}}\n     * The path is assumed to be already decoded, and will\n     * be resolved against root (if provided)\n     *\n     * @param {String|Object} path\n     * @param {Boolean} [replace]\n     */\n\n    Router.prototype.go = function go(path) {\n      var replace = false;\n      var append = false;\n      if (Vue.util.isObject(path)) {\n        replace = path.replace;\n        append = path.append;\n      }\n      path = this.stringifyPath(path);\n      if (path) {\n        this.history.go(path, replace, append);\n      }\n    };\n\n    /**\n     * Short hand for replacing current path\n     *\n     * @param {String} path\n     */\n\n    Router.prototype.replace = function replace(path) {\n      if (typeof path === 'string') {\n        path = { path: path };\n      }\n      path.replace = true;\n      this.go(path);\n    };\n\n    /**\n     * Start the router.\n     *\n     * @param {VueConstructor} App\n     * @param {String|Element} container\n     * @param {Function} [cb]\n     */\n\n    Router.prototype.start = function start(App, container, cb) {\n      /* istanbul ignore if */\n      if (this._started) {\n        warn$1('already started.');\n        return;\n      }\n      this._started = true;\n      this._startCb = cb;\n      if (!this.app) {\n        /* istanbul ignore if */\n        if (!App || !container) {\n          throw new Error('Must start vue-router with a component and a ' + 'root container.');\n        }\n        /* istanbul ignore if */\n        if (App instanceof Vue) {\n          throw new Error('Must start vue-router with a component, not a ' + 'Vue instance.');\n        }\n        this._appContainer = container;\n        var Ctor = this._appConstructor = typeof App === 'function' ? App : Vue.extend(App);\n        // give it a name for better debugging\n        Ctor.options.name = Ctor.options.name || 'RouterApp';\n      }\n\n      // handle history fallback in browsers that do not\n      // support HTML5 history API\n      if (this._historyFallback) {\n        var _location = window.location;\n        var _history = new HTML5History({ root: this._root });\n        var path = _history.root ? _location.pathname.replace(_history.rootRE, '') : _location.pathname;\n        if (path && path !== '/') {\n          _location.assign((_history.root || '') + '/' + this.history.formatPath(path) + _location.search);\n          return;\n        }\n      }\n\n      this.history.start();\n    };\n\n    /**\n     * Stop listening to route changes.\n     */\n\n    Router.prototype.stop = function stop() {\n      this.history.stop();\n      this._started = false;\n    };\n\n    /**\n     * Normalize named route object / string paths into\n     * a string.\n     *\n     * @param {Object|String|Number} path\n     * @return {String}\n     */\n\n    Router.prototype.stringifyPath = function stringifyPath(path) {\n      var generatedPath = '';\n      if (path && typeof path === 'object') {\n        if (path.name) {\n          var extend = Vue.util.extend;\n          var currentParams = this._currentTransition && this._currentTransition.to.params;\n          var targetParams = path.params || {};\n          var params = currentParams ? extend(extend({}, currentParams), targetParams) : targetParams;\n          generatedPath = encodeURI(this._recognizer.generate(path.name, params));\n        } else if (path.path) {\n          generatedPath = encodeURI(path.path);\n        }\n        if (path.query) {\n          // note: the generated query string is pre-URL-encoded by the recognizer\n          var query = this._recognizer.generateQueryString(path.query);\n          if (generatedPath.indexOf('?') > -1) {\n            generatedPath += '&' + query.slice(1);\n          } else {\n            generatedPath += query;\n          }\n        }\n      } else {\n        generatedPath = encodeURI(path ? path + '' : '');\n      }\n      return generatedPath;\n    };\n\n    // Internal methods ======================================\n\n    /**\n    * Add a route containing a list of segments to the internal\n    * route recognizer. Will be called recursively to add all\n    * possible sub-routes.\n    *\n    * @param {String} path\n    * @param {Object} handler\n    * @param {Array} segments\n    */\n\n    Router.prototype._addRoute = function _addRoute(path, handler, segments) {\n      guardComponent(path, handler);\n      handler.path = path;\n      handler.fullPath = (segments.reduce(function (path, segment) {\n        return path + segment.path;\n      }, '') + path).replace('//', '/');\n      segments.push({\n        path: path,\n        handler: handler\n      });\n      this._recognizer.add(segments, {\n        as: handler.name\n      });\n      // add sub routes\n      if (handler.subRoutes) {\n        for (var subPath in handler.subRoutes) {\n          // recursively walk all sub routes\n          this._addRoute(subPath, handler.subRoutes[subPath],\n          // pass a copy in recursion to avoid mutating\n          // across branches\n          segments.slice());\n        }\n      }\n    };\n\n    /**\n     * Set the notFound route handler.\n     *\n     * @param {Object} handler\n     */\n\n    Router.prototype._notFound = function _notFound(handler) {\n      guardComponent('*', handler);\n      this._notFoundHandler = [{ handler: handler }];\n    };\n\n    /**\n     * Add a redirect record.\n     *\n     * @param {String} path\n     * @param {String} redirectPath\n     */\n\n    Router.prototype._addRedirect = function _addRedirect(path, redirectPath) {\n      if (path === '*') {\n        this._notFoundRedirect = redirectPath;\n      } else {\n        this._addGuard(path, redirectPath, this.replace);\n      }\n    };\n\n    /**\n     * Add an alias record.\n     *\n     * @param {String} path\n     * @param {String} aliasPath\n     */\n\n    Router.prototype._addAlias = function _addAlias(path, aliasPath) {\n      this._addGuard(path, aliasPath, this._match);\n    };\n\n    /**\n     * Add a path guard.\n     *\n     * @param {String} path\n     * @param {String} mappedPath\n     * @param {Function} handler\n     */\n\n    Router.prototype._addGuard = function _addGuard(path, mappedPath, _handler) {\n      var _this2 = this;\n\n      this._guardRecognizer.add([{\n        path: path,\n        handler: function handler(match, query) {\n          var realPath = mapParams(mappedPath, match.params, query);\n          _handler.call(_this2, realPath);\n        }\n      }]);\n    };\n\n    /**\n     * Check if a path matches any redirect records.\n     *\n     * @param {String} path\n     * @return {Boolean} - if true, will skip normal match.\n     */\n\n    Router.prototype._checkGuard = function _checkGuard(path) {\n      var matched = this._guardRecognizer.recognize(path, true);\n      if (matched) {\n        matched[0].handler(matched[0], matched.queryParams);\n        return true;\n      } else if (this._notFoundRedirect) {\n        matched = this._recognizer.recognize(path);\n        if (!matched) {\n          this.replace(this._notFoundRedirect);\n          return true;\n        }\n      }\n    };\n\n    /**\n     * Match a URL path and set the route context on vm,\n     * triggering view updates.\n     *\n     * @param {String} path\n     * @param {Object} [state]\n     * @param {String} [anchor]\n     */\n\n    Router.prototype._match = function _match(path, state, anchor) {\n      var _this3 = this;\n\n      if (this._checkGuard(path)) {\n        return;\n      }\n\n      var currentRoute = this._currentRoute;\n      var currentTransition = this._currentTransition;\n\n      if (currentTransition) {\n        if (currentTransition.to.path === path) {\n          // do nothing if we have an active transition going to the same path\n          return;\n        } else if (currentRoute.path === path) {\n          // We are going to the same path, but we also have an ongoing but\n          // not-yet-validated transition. Abort that transition and reset to\n          // prev transition.\n          currentTransition.aborted = true;\n          this._currentTransition = this._prevTransition;\n          return;\n        } else {\n          // going to a totally different path. abort ongoing transition.\n          currentTransition.aborted = true;\n        }\n      }\n\n      // construct new route and transition context\n      var route = new Route(path, this);\n      var transition = new RouteTransition(this, route, currentRoute);\n\n      // current transition is updated right now.\n      // however, current route will only be updated after the transition has\n      // been validated.\n      this._prevTransition = currentTransition;\n      this._currentTransition = transition;\n\n      if (!this.app) {\n        (function () {\n          // initial render\n          var router = _this3;\n          _this3.app = new _this3._appConstructor({\n            el: _this3._appContainer,\n            created: function created() {\n              this.$router = router;\n            },\n            _meta: {\n              $route: route\n            }\n          });\n        })();\n      }\n\n      // check global before hook\n      var beforeHooks = this._beforeEachHooks;\n      var startTransition = function startTransition() {\n        transition.start(function () {\n          _this3._postTransition(route, state, anchor);\n        });\n      };\n\n      if (beforeHooks.length) {\n        transition.runQueue(beforeHooks, function (hook, _, next) {\n          if (transition === _this3._currentTransition) {\n            transition.callHook(hook, null, next, {\n              expectBoolean: true\n            });\n          }\n        }, startTransition);\n      } else {\n        startTransition();\n      }\n\n      if (!this._rendered && this._startCb) {\n        this._startCb.call(null);\n      }\n\n      // HACK:\n      // set rendered to true after the transition start, so\n      // that components that are acitvated synchronously know\n      // whether it is the initial render.\n      this._rendered = true;\n    };\n\n    /**\n     * Set current to the new transition.\n     * This is called by the transition object when the\n     * validation of a route has succeeded.\n     *\n     * @param {Transition} transition\n     */\n\n    Router.prototype._onTransitionValidated = function _onTransitionValidated(transition) {\n      // set current route\n      var route = this._currentRoute = transition.to;\n      // update route context for all children\n      if (this.app.$route !== route) {\n        this.app.$route = route;\n        this._children.forEach(function (child) {\n          child.$route = route;\n        });\n      }\n      // call global after hook\n      if (this._afterEachHooks.length) {\n        this._afterEachHooks.forEach(function (hook) {\n          return hook.call(null, {\n            to: transition.to,\n            from: transition.from\n          });\n        });\n      }\n      this._currentTransition.done = true;\n    };\n\n    /**\n     * Handle stuff after the transition.\n     *\n     * @param {Route} route\n     * @param {Object} [state]\n     * @param {String} [anchor]\n     */\n\n    Router.prototype._postTransition = function _postTransition(route, state, anchor) {\n      // handle scroll positions\n      // saved scroll positions take priority\n      // then we check if the path has an anchor\n      var pos = state && state.pos;\n      if (pos && this._saveScrollPosition) {\n        Vue.nextTick(function () {\n          window.scrollTo(pos.x, pos.y);\n        });\n      } else if (anchor) {\n        Vue.nextTick(function () {\n          var el = document.getElementById(anchor.slice(1));\n          if (el) {\n            window.scrollTo(window.scrollX, el.offsetTop);\n          }\n        });\n      }\n    };\n\n    return Router;\n  })();\n\n  function guardComponent(path, handler) {\n    var comp = handler.component;\n    if (Vue.util.isPlainObject(comp)) {\n      comp = handler.component = Vue.extend(comp);\n    }\n    /* istanbul ignore if */\n    if (typeof comp !== 'function') {\n      handler.component = null;\n      warn$1('invalid component for route \"' + path + '\".');\n    }\n  }\n\n  /* Installation */\n\n  Router.installed = false;\n\n  /**\n   * Installation interface.\n   * Install the necessary directives.\n   */\n\n  Router.install = function (externalVue) {\n    /* istanbul ignore if */\n    if (Router.installed) {\n      warn$1('already installed.');\n      return;\n    }\n    Vue = externalVue;\n    applyOverride(Vue);\n    View(Vue);\n    Link(Vue);\n    exports$1.Vue = Vue;\n    Router.installed = true;\n  };\n\n  // auto install\n  /* istanbul ignore if */\n  if (typeof window !== 'undefined' && window.Vue) {\n    window.Vue.use(Router);\n  }\n\n  return Router;\n\n}));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmpzP2U3MWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsc0VBQXNFLEtBQUs7O0FBRTNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5RUFBeUU7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0Qjs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogdnVlLXJvdXRlciB2MC43LjEzXG4gKiAoYykgMjAxNiBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIGdsb2JhbC5WdWVSb3V0ZXIgPSBmYWN0b3J5KCk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBiYWJlbEhlbHBlcnMgPSB7fTtcblxuICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBUYXJnZXQocGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMubWF0Y2hlciA9IG1hdGNoZXI7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICB9XG5cbiAgVGFyZ2V0LnByb3RvdHlwZSA9IHtcbiAgICB0bzogZnVuY3Rpb24gdG8odGFyZ2V0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIGRlbGVnYXRlID0gdGhpcy5kZWxlZ2F0ZTtcblxuICAgICAgaWYgKGRlbGVnYXRlICYmIGRlbGVnYXRlLndpbGxBZGRSb3V0ZSkge1xuICAgICAgICB0YXJnZXQgPSBkZWxlZ2F0ZS53aWxsQWRkUm91dGUodGhpcy5tYXRjaGVyLnRhcmdldCwgdGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYXRjaGVyLmFkZCh0aGlzLnBhdGgsIHRhcmdldCk7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgaGF2ZSBhbiBhcmd1bWVudCBpbiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGB0b2BcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXRjaGVyLmFkZENoaWxkKHRoaXMucGF0aCwgdGFyZ2V0LCBjYWxsYmFjaywgdGhpcy5kZWxlZ2F0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gTWF0Y2hlcih0YXJnZXQpIHtcbiAgICB0aGlzLnJvdXRlcyA9IHt9O1xuICAgIHRoaXMuY2hpbGRyZW4gPSB7fTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgfVxuXG4gIE1hdGNoZXIucHJvdG90eXBlID0ge1xuICAgIGFkZDogZnVuY3Rpb24gYWRkKHBhdGgsIGhhbmRsZXIpIHtcbiAgICAgIHRoaXMucm91dGVzW3BhdGhdID0gaGFuZGxlcjtcbiAgICB9LFxuXG4gICAgYWRkQ2hpbGQ6IGZ1bmN0aW9uIGFkZENoaWxkKHBhdGgsIHRhcmdldCwgY2FsbGJhY2ssIGRlbGVnYXRlKSB7XG4gICAgICB2YXIgbWF0Y2hlciA9IG5ldyBNYXRjaGVyKHRhcmdldCk7XG4gICAgICB0aGlzLmNoaWxkcmVuW3BhdGhdID0gbWF0Y2hlcjtcblxuICAgICAgdmFyIG1hdGNoID0gZ2VuZXJhdGVNYXRjaChwYXRoLCBtYXRjaGVyLCBkZWxlZ2F0ZSk7XG5cbiAgICAgIGlmIChkZWxlZ2F0ZSAmJiBkZWxlZ2F0ZS5jb250ZXh0RW50ZXJlZCkge1xuICAgICAgICBkZWxlZ2F0ZS5jb250ZXh0RW50ZXJlZCh0YXJnZXQsIG1hdGNoKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobWF0Y2gpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZU1hdGNoKHN0YXJ0aW5nUGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhdGgsIG5lc3RlZENhbGxiYWNrKSB7XG4gICAgICB2YXIgZnVsbFBhdGggPSBzdGFydGluZ1BhdGggKyBwYXRoO1xuXG4gICAgICBpZiAobmVzdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgbmVzdGVkQ2FsbGJhY2soZ2VuZXJhdGVNYXRjaChmdWxsUGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KHN0YXJ0aW5nUGF0aCArIHBhdGgsIG1hdGNoZXIsIGRlbGVnYXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkUm91dGUocm91dGVBcnJheSwgcGF0aCwgaGFuZGxlcikge1xuICAgIHZhciBsZW4gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gcm91dGVBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSByb3V0ZUFycmF5W2ldLnBhdGgubGVuZ3RoO1xuICAgIH1cblxuICAgIHBhdGggPSBwYXRoLnN1YnN0cihsZW4pO1xuICAgIHZhciByb3V0ZSA9IHsgcGF0aDogcGF0aCwgaGFuZGxlcjogaGFuZGxlciB9O1xuICAgIHJvdXRlQXJyYXkucHVzaChyb3V0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBlYWNoUm91dGUoYmFzZVJvdXRlLCBtYXRjaGVyLCBjYWxsYmFjaywgYmluZGluZykge1xuICAgIHZhciByb3V0ZXMgPSBtYXRjaGVyLnJvdXRlcztcblxuICAgIGZvciAodmFyIHBhdGggaW4gcm91dGVzKSB7XG4gICAgICBpZiAocm91dGVzLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgICAgIHZhciByb3V0ZUFycmF5ID0gYmFzZVJvdXRlLnNsaWNlKCk7XG4gICAgICAgIGFkZFJvdXRlKHJvdXRlQXJyYXksIHBhdGgsIHJvdXRlc1twYXRoXSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXIuY2hpbGRyZW5bcGF0aF0pIHtcbiAgICAgICAgICBlYWNoUm91dGUocm91dGVBcnJheSwgbWF0Y2hlci5jaGlsZHJlbltwYXRoXSwgY2FsbGJhY2ssIGJpbmRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoYmluZGluZywgcm91dGVBcnJheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXAgKGNhbGxiYWNrLCBhZGRSb3V0ZUNhbGxiYWNrKSB7XG4gICAgdmFyIG1hdGNoZXIgPSBuZXcgTWF0Y2hlcigpO1xuXG4gICAgY2FsbGJhY2soZ2VuZXJhdGVNYXRjaChcIlwiLCBtYXRjaGVyLCB0aGlzLmRlbGVnYXRlKSk7XG5cbiAgICBlYWNoUm91dGUoW10sIG1hdGNoZXIsIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgaWYgKGFkZFJvdXRlQ2FsbGJhY2spIHtcbiAgICAgICAgYWRkUm91dGVDYWxsYmFjayh0aGlzLCByb3V0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZChyb3V0ZSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICB2YXIgc3BlY2lhbHMgPSBbJy8nLCAnLicsICcqJywgJysnLCAnPycsICd8JywgJygnLCAnKScsICdbJywgJ10nLCAneycsICd9JywgJ1xcXFwnXTtcblxuICB2YXIgZXNjYXBlUmVnZXggPSBuZXcgUmVnRXhwKCcoXFxcXCcgKyBzcGVjaWFscy5qb2luKCd8XFxcXCcpICsgJyknLCAnZycpO1xuXG4gIHZhciBub1dhcm5pbmcgPSBmYWxzZTtcbiAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICBpZiAoIW5vV2FybmluZyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1t2dWUtcm91dGVyXSAnICsgbXNnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cnlEZWNvZGUodXJpLCBhc0NvbXBvbmVudCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXNDb21wb25lbnQgPyBkZWNvZGVVUklDb21wb25lbnQodXJpKSA6IGRlY29kZVVSSSh1cmkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oJ21hbGZvcm1lZCBVUkknICsgKGFzQ29tcG9uZW50ID8gJyBjb21wb25lbnQ6ICcgOiAnOiAnKSArIHVyaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNBcnJheSh0ZXN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0ZXN0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICB9XG5cbiAgLy8gQSBTZWdtZW50IHJlcHJlc2VudHMgYSBzZWdtZW50IGluIHRoZSBvcmlnaW5hbCByb3V0ZSBkZXNjcmlwdGlvbi5cbiAgLy8gRWFjaCBTZWdtZW50IHR5cGUgcHJvdmlkZXMgYW4gYGVhY2hDaGFyYCBhbmQgYHJlZ2V4YCBtZXRob2QuXG4gIC8vXG4gIC8vIFRoZSBgZWFjaENoYXJgIG1ldGhvZCBpbnZva2VzIHRoZSBjYWxsYmFjayB3aXRoIG9uZSBvciBtb3JlIGNoYXJhY3RlclxuICAvLyBzcGVjaWZpY2F0aW9ucy4gQSBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiBjb25zdW1lcyBvbmUgb3IgbW9yZSBpbnB1dFxuICAvLyBjaGFyYWN0ZXJzLlxuICAvL1xuICAvLyBUaGUgYHJlZ2V4YCBtZXRob2QgcmV0dXJucyBhIHJlZ2V4IGZyYWdtZW50IGZvciB0aGUgc2VnbWVudC4gSWYgdGhlXG4gIC8vIHNlZ21lbnQgaXMgYSBkeW5hbWljIG9mIHN0YXIgc2VnbWVudCwgdGhlIHJlZ2V4IGZyYWdtZW50IGFsc28gaW5jbHVkZXNcbiAgLy8gYSBjYXB0dXJlLlxuICAvL1xuICAvLyBBIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGNvbnRhaW5zOlxuICAvL1xuICAvLyAqIGB2YWxpZENoYXJzYDogYSBTdHJpbmcgd2l0aCBhIGxpc3Qgb2YgYWxsIHZhbGlkIGNoYXJhY3RlcnMsIG9yXG4gIC8vICogYGludmFsaWRDaGFyc2A6IGEgU3RyaW5nIHdpdGggYSBsaXN0IG9mIGFsbCBpbnZhbGlkIGNoYXJhY3RlcnNcbiAgLy8gKiBgcmVwZWF0YDogdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIHNwZWNpZmljYXRpb24gY2FuIHJlcGVhdFxuXG4gIGZ1bmN0aW9uIFN0YXRpY1NlZ21lbnQoc3RyaW5nKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gIH1cbiAgU3RhdGljU2VnbWVudC5wcm90b3R5cGUgPSB7XG4gICAgZWFjaENoYXI6IGZ1bmN0aW9uIGVhY2hDaGFyKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc3RyaW5nID0gdGhpcy5zdHJpbmcsXG4gICAgICAgICAgY2g7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjaCA9IHN0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgIGNhbGxiYWNrKHsgdmFsaWRDaGFyczogY2ggfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlZ2V4OiBmdW5jdGlvbiByZWdleCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmluZy5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnXFxcXCQxJyk7XG4gICAgfSxcblxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gRHluYW1pY1NlZ21lbnQobmFtZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cbiAgRHluYW1pY1NlZ21lbnQucHJvdG90eXBlID0ge1xuICAgIGVhY2hDaGFyOiBmdW5jdGlvbiBlYWNoQ2hhcihjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soeyBpbnZhbGlkQ2hhcnM6IFwiL1wiLCByZXBlYXQ6IHRydWUgfSk7XG4gICAgfSxcblxuICAgIHJlZ2V4OiBmdW5jdGlvbiByZWdleCgpIHtcbiAgICAgIHJldHVybiBcIihbXi9dKylcIjtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uIGdlbmVyYXRlKHBhcmFtcykge1xuICAgICAgdmFyIHZhbCA9IHBhcmFtc1t0aGlzLm5hbWVdO1xuICAgICAgcmV0dXJuIHZhbCA9PSBudWxsID8gXCI6XCIgKyB0aGlzLm5hbWUgOiB2YWw7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFN0YXJTZWdtZW50KG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG4gIFN0YXJTZWdtZW50LnByb3RvdHlwZSA9IHtcbiAgICBlYWNoQ2hhcjogZnVuY3Rpb24gZWFjaENoYXIoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKHsgaW52YWxpZENoYXJzOiBcIlwiLCByZXBlYXQ6IHRydWUgfSk7XG4gICAgfSxcblxuICAgIHJlZ2V4OiBmdW5jdGlvbiByZWdleCgpIHtcbiAgICAgIHJldHVybiBcIiguKylcIjtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uIGdlbmVyYXRlKHBhcmFtcykge1xuICAgICAgdmFyIHZhbCA9IHBhcmFtc1t0aGlzLm5hbWVdO1xuICAgICAgcmV0dXJuIHZhbCA9PSBudWxsID8gXCI6XCIgKyB0aGlzLm5hbWUgOiB2YWw7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEVwc2lsb25TZWdtZW50KCkge31cbiAgRXBzaWxvblNlZ21lbnQucHJvdG90eXBlID0ge1xuICAgIGVhY2hDaGFyOiBmdW5jdGlvbiBlYWNoQ2hhcigpIHt9LFxuICAgIHJlZ2V4OiBmdW5jdGlvbiByZWdleCgpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlKHJvdXRlLCBuYW1lcywgc3BlY2lmaWNpdHkpIHtcbiAgICAvLyBub3JtYWxpemUgcm91dGUgYXMgbm90IHN0YXJ0aW5nIHdpdGggYSBcIi9cIi4gUmVjb2duaXRpb24gd2lsbFxuICAgIC8vIGFsc28gbm9ybWFsaXplLlxuICAgIGlmIChyb3V0ZS5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XG4gICAgICByb3V0ZSA9IHJvdXRlLnN1YnN0cigxKTtcbiAgICB9XG5cbiAgICB2YXIgc2VnbWVudHMgPSByb3V0ZS5zcGxpdChcIi9cIiksXG4gICAgICAgIHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIEEgcm91dGVzIGhhcyBzcGVjaWZpY2l0eSBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGF0IGl0cyBkaWZmZXJlbnQgc2VnbWVudHNcbiAgICAvLyBhcHBlYXIgaW4uIFRoaXMgc3lzdGVtIG1pcnJvcnMgaG93IHRoZSBtYWduaXR1ZGUgb2YgbnVtYmVycyB3cml0dGVuIGFzIHN0cmluZ3NcbiAgICAvLyB3b3Jrcy5cbiAgICAvLyBDb25zaWRlciBhIG51bWJlciB3cml0dGVuIGFzOiBcImFiY1wiLiBBbiBleGFtcGxlIHdvdWxkIGJlIFwiMjAwXCIuIEFueSBvdGhlciBudW1iZXIgd3JpdHRlblxuICAgIC8vIFwieHl6XCIgd2lsbCBiZSBzbWFsbGVyIHRoYW4gXCJhYmNcIiBzbyBsb25nIGFzIGBhID4gemAuIEZvciBpbnN0YW5jZSwgXCIxOTlcIiBpcyBzbWFsbGVyXG4gICAgLy8gdGhlbiBcIjIwMFwiLCBldmVuIHRob3VnaCBcInlcIiBhbmQgXCJ6XCIgKHdoaWNoIGFyZSBib3RoIDkpIGFyZSBsYXJnZXIgdGhhbiBcIjBcIiAodGhlIHZhbHVlXG4gICAgLy8gb2YgKGBiYCBhbmQgYGNgKS4gVGhpcyBpcyBiZWNhdXNlIHRoZSBsZWFkaW5nIHN5bWJvbCwgXCIyXCIsIGlzIGxhcmdlciB0aGFuIHRoZSBvdGhlclxuICAgIC8vIGxlYWRpbmcgc3ltYm9sLCBcIjFcIi5cbiAgICAvLyBUaGUgcnVsZSBpcyB0aGF0IHN5bWJvbHMgdG8gdGhlIGxlZnQgY2FycnkgbW9yZSB3ZWlnaHQgdGhhbiBzeW1ib2xzIHRvIHRoZSByaWdodFxuICAgIC8vIHdoZW4gYSBudW1iZXIgaXMgd3JpdHRlbiBvdXQgYXMgYSBzdHJpbmcuIEluIHRoZSBhYm92ZSBzdHJpbmdzLCB0aGUgbGVhZGluZyBkaWdpdFxuICAgIC8vIHJlcHJlc2VudHMgaG93IG1hbnkgMTAwJ3MgYXJlIGluIHRoZSBudW1iZXIsIGFuZCBpdCBjYXJyaWVzIG1vcmUgd2VpZ2h0IHRoYW4gdGhlIG1pZGRsZVxuICAgIC8vIG51bWJlciB3aGljaCByZXByZXNlbnRzIGhvdyBtYW55IDEwJ3MgYXJlIGluIHRoZSBudW1iZXIuXG4gICAgLy8gVGhpcyBzeXN0ZW0gb2YgbnVtYmVyIG1hZ25pdHVkZSB3b3JrcyB3ZWxsIGZvciByb3V0ZSBzcGVjaWZpY2l0eSwgdG9vLiBBIHJvdXRlIHdyaXR0ZW4gYXNcbiAgICAvLyBgYS9iL2NgIHdpbGwgYmUgbW9yZSBzcGVjaWZpYyB0aGFuIGB4L3kvemAgYXMgbG9uZyBhcyBgYWAgaXMgbW9yZSBzcGVjaWZpYyB0aGFuXG4gICAgLy8gYHhgLCBpcnJlc3BlY3RpdmUgb2YgdGhlIG90aGVyIHBhcnRzLlxuICAgIC8vIEJlY2F1c2Ugb2YgdGhpcyBzaW1pbGFyaXR5LCB3ZSBhc3NpZ24gZWFjaCB0eXBlIG9mIHNlZ21lbnQgYSBudW1iZXIgdmFsdWUgd3JpdHRlbiBhcyBhXG4gICAgLy8gc3RyaW5nLiBXZSBjYW4gZmluZCB0aGUgc3BlY2lmaWNpdHkgb2YgY29tcG91bmQgcm91dGVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlc2Ugc3RyaW5nc1xuICAgIC8vIHRvZ2V0aGVyLCBmcm9tIGxlZnQgdG8gcmlnaHQuIEFmdGVyIHdlIGhhdmUgbG9vcGVkIHRocm91Z2ggYWxsIG9mIHRoZSBzZWdtZW50cyxcbiAgICAvLyB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gYSBudW1iZXIuXG4gICAgc3BlY2lmaWNpdHkudmFsID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXSxcbiAgICAgICAgICBtYXRjaDtcblxuICAgICAgaWYgKG1hdGNoID0gc2VnbWVudC5tYXRjaCgvXjooW15cXC9dKykkLykpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBEeW5hbWljU2VnbWVudChtYXRjaFsxXSkpO1xuICAgICAgICBuYW1lcy5wdXNoKG1hdGNoWzFdKTtcbiAgICAgICAgc3BlY2lmaWNpdHkudmFsICs9ICczJztcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eXFwqKFteXFwvXSspJC8pKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChuZXcgU3RhclNlZ21lbnQobWF0Y2hbMV0pKTtcbiAgICAgICAgc3BlY2lmaWNpdHkudmFsICs9ICcyJztcbiAgICAgICAgbmFtZXMucHVzaChtYXRjaFsxXSk7XG4gICAgICB9IGVsc2UgaWYgKHNlZ21lbnQgPT09IFwiXCIpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBFcHNpbG9uU2VnbWVudCgpKTtcbiAgICAgICAgc3BlY2lmaWNpdHkudmFsICs9ICcxJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChuZXcgU3RhdGljU2VnbWVudChzZWdtZW50KSk7XG4gICAgICAgIHNwZWNpZmljaXR5LnZhbCArPSAnNCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3BlY2lmaWNpdHkudmFsID0gK3NwZWNpZmljaXR5LnZhbDtcblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLy8gQSBTdGF0ZSBoYXMgYSBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiBhbmQgKGBjaGFyU3BlY2ApIGFuZCBhIGxpc3Qgb2YgcG9zc2libGVcbiAgLy8gc3Vic2VxdWVudCBzdGF0ZXMgKGBuZXh0U3RhdGVzYCkuXG4gIC8vXG4gIC8vIElmIGEgU3RhdGUgaXMgYW4gYWNjZXB0aW5nIHN0YXRlLCBpdCB3aWxsIGFsc28gaGF2ZSBzZXZlcmFsIGFkZGl0aW9uYWxcbiAgLy8gcHJvcGVydGllczpcbiAgLy9cbiAgLy8gKiBgcmVnZXhgOiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGlzIHVzZWQgdG8gZXh0cmFjdCBwYXJhbWV0ZXJzIGZyb20gcGF0aHNcbiAgLy8gICB0aGF0IHJlYWNoZWQgdGhpcyBhY2NlcHRpbmcgc3RhdGUuXG4gIC8vICogYGhhbmRsZXJzYDogSW5mb3JtYXRpb24gb24gaG93IHRvIGNvbnZlcnQgdGhlIGxpc3Qgb2YgY2FwdHVyZXMgaW50byBjYWxsc1xuICAvLyAgIHRvIHJlZ2lzdGVyZWQgaGFuZGxlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnNcbiAgLy8gKiBgdHlwZXNgOiBIb3cgbWFueSBzdGF0aWMsIGR5bmFtaWMgb3Igc3RhciBzZWdtZW50cyBpbiB0aGlzIHJvdXRlLiBVc2VkIHRvXG4gIC8vICAgZGVjaWRlIHdoaWNoIHJvdXRlIHRvIHVzZSBpZiBtdWx0aXBsZSByZWdpc3RlcmVkIHJvdXRlcyBtYXRjaCBhIHBhdGguXG4gIC8vXG4gIC8vIEN1cnJlbnRseSwgU3RhdGUgaXMgaW1wbGVtZW50ZWQgbmFpdmVseSBieSBsb29waW5nIG92ZXIgYG5leHRTdGF0ZXNgIGFuZFxuICAvLyBjb21wYXJpbmcgYSBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiBhZ2FpbnN0IGEgY2hhcmFjdGVyLiBBIG1vcmUgZWZmaWNpZW50XG4gIC8vIGltcGxlbWVudGF0aW9uIHdvdWxkIHVzZSBhIGhhc2ggb2Yga2V5cyBwb2ludGluZyBhdCBvbmUgb3IgbW9yZSBuZXh0IHN0YXRlcy5cblxuICBmdW5jdGlvbiBTdGF0ZShjaGFyU3BlYykge1xuICAgIHRoaXMuY2hhclNwZWMgPSBjaGFyU3BlYztcbiAgICB0aGlzLm5leHRTdGF0ZXMgPSBbXTtcbiAgfVxuXG4gIFN0YXRlLnByb3RvdHlwZSA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChjaGFyU3BlYykge1xuICAgICAgdmFyIG5leHRTdGF0ZXMgPSB0aGlzLm5leHRTdGF0ZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmV4dFN0YXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV4dFN0YXRlc1tpXTtcblxuICAgICAgICB2YXIgaXNFcXVhbCA9IGNoaWxkLmNoYXJTcGVjLnZhbGlkQ2hhcnMgPT09IGNoYXJTcGVjLnZhbGlkQ2hhcnM7XG4gICAgICAgIGlzRXF1YWwgPSBpc0VxdWFsICYmIGNoaWxkLmNoYXJTcGVjLmludmFsaWRDaGFycyA9PT0gY2hhclNwZWMuaW52YWxpZENoYXJzO1xuXG4gICAgICAgIGlmIChpc0VxdWFsKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1dDogZnVuY3Rpb24gcHV0KGNoYXJTcGVjKSB7XG4gICAgICB2YXIgc3RhdGU7XG5cbiAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiBhbHJlYWR5IGV4aXN0cyBpbiBhIGNoaWxkIG9mIHRoZSBjdXJyZW50XG4gICAgICAvLyBzdGF0ZSwganVzdCByZXR1cm4gdGhhdCBzdGF0ZS5cbiAgICAgIGlmIChzdGF0ZSA9IHRoaXMuZ2V0KGNoYXJTcGVjKSkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2UgYSBuZXcgc3RhdGUgZm9yIHRoZSBjaGFyYWN0ZXIgc3BlY1xuICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoY2hhclNwZWMpO1xuXG4gICAgICAvLyBJbnNlcnQgdGhlIG5ldyBzdGF0ZSBhcyBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICB0aGlzLm5leHRTdGF0ZXMucHVzaChzdGF0ZSk7XG5cbiAgICAgIC8vIElmIHRoaXMgY2hhcmFjdGVyIHNwZWNpZmljYXRpb24gcmVwZWF0cywgaW5zZXJ0IHRoZSBuZXcgc3RhdGUgYXMgYSBjaGlsZFxuICAgICAgLy8gb2YgaXRzZWxmLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCB0cmlnZ2VyIGFuIGluZmluaXRlIGxvb3AgYmVjYXVzZSBlYWNoXG4gICAgICAvLyB0cmFuc2l0aW9uIGR1cmluZyByZWNvZ25pdGlvbiBjb25zdW1lcyBhIGNoYXJhY3Rlci5cbiAgICAgIGlmIChjaGFyU3BlYy5yZXBlYXQpIHtcbiAgICAgICAgc3RhdGUubmV4dFN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHRoZSBuZXcgc3RhdGVcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCBhIGxpc3Qgb2YgY2hpbGQgc3RhdGVzIG1hdGNoaW5nIHRoZSBuZXh0IGNoYXJhY3RlclxuICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChjaCkge1xuICAgICAgLy8gREVCVUcgXCJQcm9jZXNzaW5nIGBcIiArIGNoICsgXCJgOlwiXG4gICAgICB2YXIgbmV4dFN0YXRlcyA9IHRoaXMubmV4dFN0YXRlcyxcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICBjaGFyU3BlYyxcbiAgICAgICAgICBjaGFycztcblxuICAgICAgLy8gREVCVUcgXCIgIFwiICsgZGVidWdTdGF0ZSh0aGlzKVxuICAgICAgdmFyIHJldHVybmVkID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmV4dFN0YXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2hpbGQgPSBuZXh0U3RhdGVzW2ldO1xuXG4gICAgICAgIGNoYXJTcGVjID0gY2hpbGQuY2hhclNwZWM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiAoY2hhcnMgPSBjaGFyU3BlYy52YWxpZENoYXJzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoY2hhcnMuaW5kZXhPZihjaCkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm5lZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChjaGFycyA9IGNoYXJTcGVjLmludmFsaWRDaGFycykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKGNoYXJzLmluZGV4T2YoY2gpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuZWQucHVzaChjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXR1cm5lZDtcbiAgICB9XG5cbiAgICAvKiogSUYgREVCVUdcbiAgICAsIGRlYnVnOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGFyU3BlYyA9IHRoaXMuY2hhclNwZWMsXG4gICAgICAgICAgZGVidWcgPSBcIltcIixcbiAgICAgICAgICBjaGFycyA9IGNoYXJTcGVjLnZhbGlkQ2hhcnMgfHwgY2hhclNwZWMuaW52YWxpZENoYXJzO1xuICAgICAgIGlmIChjaGFyU3BlYy5pbnZhbGlkQ2hhcnMpIHsgZGVidWcgKz0gXCJeXCI7IH1cbiAgICAgIGRlYnVnICs9IGNoYXJzO1xuICAgICAgZGVidWcgKz0gXCJdXCI7XG4gICAgICAgaWYgKGNoYXJTcGVjLnJlcGVhdCkgeyBkZWJ1ZyArPSBcIitcIjsgfVxuICAgICAgIHJldHVybiBkZWJ1ZztcbiAgICB9XG4gICAgRU5EIElGICoqL1xuICB9O1xuXG4gIC8qKiBJRiBERUJVR1xuICBmdW5jdGlvbiBkZWJ1Zyhsb2cpIHtcbiAgICBjb25zb2xlLmxvZyhsb2cpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVidWdTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5uZXh0U3RhdGVzLm1hcChmdW5jdGlvbihuKSB7XG4gICAgICBpZiAobi5uZXh0U3RhdGVzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gXCIoIFwiICsgbi5kZWJ1ZygpICsgXCIgW2FjY2VwdGluZ10gKVwiOyB9XG4gICAgICByZXR1cm4gXCIoIFwiICsgbi5kZWJ1ZygpICsgXCIgPHRoZW4+IFwiICsgbi5uZXh0U3RhdGVzLm1hcChmdW5jdGlvbihzKSB7IHJldHVybiBzLmRlYnVnKCkgfSkuam9pbihcIiBvciBcIikgKyBcIiApXCI7XG4gICAgfSkuam9pbihcIiwgXCIpXG4gIH1cbiAgRU5EIElGICoqL1xuXG4gIC8vIFNvcnQgdGhlIHJvdXRlcyBieSBzcGVjaWZpY2l0eVxuICBmdW5jdGlvbiBzb3J0U29sdXRpb25zKHN0YXRlcykge1xuICAgIHJldHVybiBzdGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGIuc3BlY2lmaWNpdHkudmFsIC0gYS5zcGVjaWZpY2l0eS52YWw7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvZ25pemVDaGFyKHN0YXRlcywgY2gpIHtcbiAgICB2YXIgbmV4dFN0YXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgc3RhdGUgPSBzdGF0ZXNbaV07XG5cbiAgICAgIG5leHRTdGF0ZXMgPSBuZXh0U3RhdGVzLmNvbmNhdChzdGF0ZS5tYXRjaChjaCkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGVzO1xuICB9XG5cbiAgdmFyIG9DcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90bykge1xuICAgIGZ1bmN0aW9uIEYoKSB7fVxuICAgIEYucHJvdG90eXBlID0gcHJvdG87XG4gICAgcmV0dXJuIG5ldyBGKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gUmVjb2duaXplUmVzdWx0cyhxdWVyeVBhcmFtcykge1xuICAgIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcyB8fCB7fTtcbiAgfVxuICBSZWNvZ25pemVSZXN1bHRzLnByb3RvdHlwZSA9IG9DcmVhdGUoe1xuICAgIHNwbGljZTogQXJyYXkucHJvdG90eXBlLnNwbGljZSxcbiAgICBzbGljZTogQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuICAgIHB1c2g6IEFycmF5LnByb3RvdHlwZS5wdXNoLFxuICAgIGxlbmd0aDogMCxcbiAgICBxdWVyeVBhcmFtczogbnVsbFxuICB9KTtcblxuICBmdW5jdGlvbiBmaW5kSGFuZGxlcihzdGF0ZSwgcGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSBzdGF0ZS5oYW5kbGVycyxcbiAgICAgICAgcmVnZXggPSBzdGF0ZS5yZWdleDtcbiAgICB2YXIgY2FwdHVyZXMgPSBwYXRoLm1hdGNoKHJlZ2V4KSxcbiAgICAgICAgY3VycmVudENhcHR1cmUgPSAxO1xuICAgIHZhciByZXN1bHQgPSBuZXcgUmVjb2duaXplUmVzdWx0cyhxdWVyeVBhcmFtcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tpXSxcbiAgICAgICAgICBuYW1lcyA9IGhhbmRsZXIubmFtZXMsXG4gICAgICAgICAgcGFyYW1zID0ge307XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBtID0gbmFtZXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICAgIHBhcmFtc1tuYW1lc1tqXV0gPSBjYXB0dXJlc1tjdXJyZW50Q2FwdHVyZSsrXTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnB1c2goeyBoYW5kbGVyOiBoYW5kbGVyLmhhbmRsZXIsIHBhcmFtczogcGFyYW1zLCBpc0R5bmFtaWM6ICEhbmFtZXMubGVuZ3RoIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRTZWdtZW50KGN1cnJlbnRTdGF0ZSwgc2VnbWVudCkge1xuICAgIHNlZ21lbnQuZWFjaENoYXIoZnVuY3Rpb24gKGNoKSB7XG4gICAgICB2YXIgc3RhdGU7XG5cbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5wdXQoY2gpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZVF1ZXJ5UGFyYW1QYXJ0KHBhcnQpIHtcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNDAxL2ludGVyYWN0L2Zvcm1zLmh0bWwjaC0xNy4xMy40LjFcbiAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKC9cXCsvZ20sICclMjAnKTtcbiAgICByZXR1cm4gdHJ5RGVjb2RlKHBhcnQsIHRydWUpO1xuICB9XG5cbiAgLy8gVGhlIG1haW4gaW50ZXJmYWNlXG5cbiAgdmFyIFJvdXRlUmVjb2duaXplciA9IGZ1bmN0aW9uIFJvdXRlUmVjb2duaXplcigpIHtcbiAgICB0aGlzLnJvb3RTdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgfTtcblxuICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlID0ge1xuICAgIGFkZDogZnVuY3Rpb24gYWRkKHJvdXRlcywgb3B0aW9ucykge1xuICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMucm9vdFN0YXRlLFxuICAgICAgICAgIHJlZ2V4ID0gXCJeXCIsXG4gICAgICAgICAgc3BlY2lmaWNpdHkgPSB7fSxcbiAgICAgICAgICBoYW5kbGVycyA9IFtdLFxuICAgICAgICAgIGFsbFNlZ21lbnRzID0gW10sXG4gICAgICAgICAgbmFtZTtcblxuICAgICAgdmFyIGlzRW1wdHkgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJvdXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHJvdXRlID0gcm91dGVzW2ldLFxuICAgICAgICAgICAgbmFtZXMgPSBbXTtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSBwYXJzZShyb3V0ZS5wYXRoLCBuYW1lcywgc3BlY2lmaWNpdHkpO1xuXG4gICAgICAgIGFsbFNlZ21lbnRzID0gYWxsU2VnbWVudHMuY29uY2F0KHNlZ21lbnRzKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHNlZ21lbnRzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbal07XG5cbiAgICAgICAgICBpZiAoc2VnbWVudCBpbnN0YW5jZW9mIEVwc2lsb25TZWdtZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpc0VtcHR5ID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBBZGQgYSBcIi9cIiBmb3IgdGhlIG5ldyBzZWdtZW50XG4gICAgICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFN0YXRlLnB1dCh7IHZhbGlkQ2hhcnM6IFwiL1wiIH0pO1xuICAgICAgICAgIHJlZ2V4ICs9IFwiL1wiO1xuXG4gICAgICAgICAgLy8gQWRkIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlZ21lbnQgdG8gdGhlIE5GQSBhbmQgcmVnZXhcbiAgICAgICAgICBjdXJyZW50U3RhdGUgPSBhZGRTZWdtZW50KGN1cnJlbnRTdGF0ZSwgc2VnbWVudCk7XG4gICAgICAgICAgcmVnZXggKz0gc2VnbWVudC5yZWdleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXIgPSB7IGhhbmRsZXI6IHJvdXRlLmhhbmRsZXIsIG5hbWVzOiBuYW1lcyB9O1xuICAgICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50U3RhdGUucHV0KHsgdmFsaWRDaGFyczogXCIvXCIgfSk7XG4gICAgICAgIHJlZ2V4ICs9IFwiL1wiO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50U3RhdGUuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICAgIGN1cnJlbnRTdGF0ZS5yZWdleCA9IG5ldyBSZWdFeHAocmVnZXggKyBcIiRcIik7XG4gICAgICBjdXJyZW50U3RhdGUuc3BlY2lmaWNpdHkgPSBzcGVjaWZpY2l0eTtcblxuICAgICAgaWYgKG5hbWUgPSBvcHRpb25zICYmIG9wdGlvbnMuYXMpIHtcbiAgICAgICAgdGhpcy5uYW1lc1tuYW1lXSA9IHtcbiAgICAgICAgICBzZWdtZW50czogYWxsU2VnbWVudHMsXG4gICAgICAgICAgaGFuZGxlcnM6IGhhbmRsZXJzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZXJzRm9yOiBmdW5jdGlvbiBoYW5kbGVyc0ZvcihuYW1lKSB7XG4gICAgICB2YXIgcm91dGUgPSB0aGlzLm5hbWVzW25hbWVdLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCFyb3V0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyByb3V0ZSBuYW1lZCBcIiArIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJvdXRlLmhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChyb3V0ZS5oYW5kbGVyc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGhhc1JvdXRlOiBmdW5jdGlvbiBoYXNSb3V0ZShuYW1lKSB7XG4gICAgICByZXR1cm4gISF0aGlzLm5hbWVzW25hbWVdO1xuICAgIH0sXG5cbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24gZ2VuZXJhdGUobmFtZSwgcGFyYW1zKSB7XG4gICAgICB2YXIgcm91dGUgPSB0aGlzLm5hbWVzW25hbWVdLFxuICAgICAgICAgIG91dHB1dCA9IFwiXCI7XG4gICAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIHJvdXRlIG5hbWVkIFwiICsgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdtZW50cyA9IHJvdXRlLnNlZ21lbnRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXG4gICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgRXBzaWxvblNlZ21lbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dCArPSBcIi9cIjtcbiAgICAgICAgb3V0cHV0ICs9IHNlZ21lbnQuZ2VuZXJhdGUocGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG91dHB1dC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgICBvdXRwdXQgPSAnLycgKyBvdXRwdXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIG91dHB1dCArPSB0aGlzLmdlbmVyYXRlUXVlcnlTdHJpbmcocGFyYW1zLnF1ZXJ5UGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGVRdWVyeVN0cmluZzogZnVuY3Rpb24gZ2VuZXJhdGVRdWVyeVN0cmluZyhwYXJhbXMpIHtcbiAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtleXMuc29ydCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhaXIgPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBhcnJheVBhaXIgPSBrZXkgKyAnW10nICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlW2pdKTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goYXJyYXlQYWlyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFpciArPSBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgICAgcGFpcnMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFpcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiP1wiICsgcGFpcnMuam9pbihcIiZcIik7XG4gICAgfSxcblxuICAgIHBhcnNlUXVlcnlTdHJpbmc6IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmcocXVlcnlTdHJpbmcpIHtcbiAgICAgIHZhciBwYWlycyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KFwiJlwiKSxcbiAgICAgICAgICBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9JyksXG4gICAgICAgICAgICBrZXkgPSBkZWNvZGVRdWVyeVBhcmFtUGFydChwYWlyWzBdKSxcbiAgICAgICAgICAgIGtleUxlbmd0aCA9IGtleS5sZW5ndGgsXG4gICAgICAgICAgICBpc0FycmF5ID0gZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTtcbiAgICAgICAgaWYgKHBhaXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdmFsdWUgPSAndHJ1ZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9IYW5kbGUgYXJyYXlzXG4gICAgICAgICAgaWYgKGtleUxlbmd0aCA+IDIgJiYga2V5LnNsaWNlKGtleUxlbmd0aCAtIDIpID09PSAnW10nKSB7XG4gICAgICAgICAgICBpc0FycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGtleSA9IGtleS5zbGljZSgwLCBrZXlMZW5ndGggLSAyKTtcbiAgICAgICAgICAgIGlmICghcXVlcnlQYXJhbXNba2V5XSkge1xuICAgICAgICAgICAgICBxdWVyeVBhcmFtc1trZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gcGFpclsxXSA/IGRlY29kZVF1ZXJ5UGFyYW1QYXJ0KHBhaXJbMV0pIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICBxdWVyeVBhcmFtc1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHF1ZXJ5UGFyYW1zO1xuICAgIH0sXG5cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uIHJlY29nbml6ZShwYXRoLCBzaWxlbnQpIHtcbiAgICAgIG5vV2FybmluZyA9IHNpbGVudDtcbiAgICAgIHZhciBzdGF0ZXMgPSBbdGhpcy5yb290U3RhdGVdLFxuICAgICAgICAgIHBhdGhMZW4sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIHF1ZXJ5U3RhcnQsXG4gICAgICAgICAgcXVlcnlQYXJhbXMgPSB7fSxcbiAgICAgICAgICBpc1NsYXNoRHJvcHBlZCA9IGZhbHNlO1xuXG4gICAgICBxdWVyeVN0YXJ0ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gICAgICBpZiAocXVlcnlTdGFydCAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gcGF0aC5zdWJzdHIocXVlcnlTdGFydCArIDEsIHBhdGgubGVuZ3RoKTtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHF1ZXJ5U3RhcnQpO1xuICAgICAgICBpZiAocXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICBxdWVyeVBhcmFtcyA9IHRoaXMucGFyc2VRdWVyeVN0cmluZyhxdWVyeVN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGF0aCA9IHRyeURlY29kZShwYXRoKTtcbiAgICAgIGlmICghcGF0aCkgcmV0dXJuO1xuXG4gICAgICAvLyBERUJVRyBHUk9VUCBwYXRoXG5cbiAgICAgIGlmIChwYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aCA9IFwiL1wiICsgcGF0aDtcbiAgICAgIH1cblxuICAgICAgcGF0aExlbiA9IHBhdGgubGVuZ3RoO1xuICAgICAgaWYgKHBhdGhMZW4gPiAxICYmIHBhdGguY2hhckF0KHBhdGhMZW4gLSAxKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHBhdGhMZW4gLSAxKTtcbiAgICAgICAgaXNTbGFzaERyb3BwZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gcGF0aC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgc3RhdGVzID0gcmVjb2duaXplQ2hhcihzdGF0ZXMsIHBhdGguY2hhckF0KGkpKTtcbiAgICAgICAgaWYgKCFzdGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRU5EIERFQlVHIEdST1VQXG5cbiAgICAgIHZhciBzb2x1dGlvbnMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBzdGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChzdGF0ZXNbaV0uaGFuZGxlcnMpIHtcbiAgICAgICAgICBzb2x1dGlvbnMucHVzaChzdGF0ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlcyA9IHNvcnRTb2x1dGlvbnMoc29sdXRpb25zKTtcblxuICAgICAgdmFyIHN0YXRlID0gc29sdXRpb25zWzBdO1xuXG4gICAgICBpZiAoc3RhdGUgJiYgc3RhdGUuaGFuZGxlcnMpIHtcbiAgICAgICAgLy8gaWYgYSB0cmFpbGluZyBzbGFzaCB3YXMgZHJvcHBlZCBhbmQgYSBzdGFyIHNlZ21lbnQgaXMgdGhlIGxhc3Qgc2VnbWVudFxuICAgICAgICAvLyBzcGVjaWZpZWQsIHB1dCB0aGUgdHJhaWxpbmcgc2xhc2ggYmFja1xuICAgICAgICBpZiAoaXNTbGFzaERyb3BwZWQgJiYgc3RhdGUucmVnZXguc291cmNlLnNsaWNlKC01KSA9PT0gXCIoLispJFwiKSB7XG4gICAgICAgICAgcGF0aCA9IHBhdGggKyBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZEhhbmRsZXIoc3RhdGUsIHBhdGgsIHF1ZXJ5UGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5tYXAgPSBtYXA7XG5cbiAgdmFyIGdlblF1ZXJ5ID0gUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5nZW5lcmF0ZVF1ZXJ5U3RyaW5nO1xuXG4gIC8vIGV4cG9ydCBkZWZhdWx0IGZvciBob2xkaW5nIHRoZSBWdWUgcmVmZXJlbmNlXG4gIHZhciBleHBvcnRzJDEgPSB7fTtcbiAgLyoqXG4gICAqIFdhcm4gc3R1ZmYuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2dcbiAgICovXG5cbiAgZnVuY3Rpb24gd2FybiQxKG1zZykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcignW3Z1ZS1yb3V0ZXJdICcgKyBtc2cpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGEgcmVsYXRpdmUgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJhc2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYXBwZW5kXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVBhdGgoYmFzZSwgcmVsYXRpdmUsIGFwcGVuZCkge1xuICAgIHZhciBxdWVyeSA9IGJhc2UubWF0Y2goLyhcXD8uKikkLyk7XG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5WzFdO1xuICAgICAgYmFzZSA9IGJhc2Uuc2xpY2UoMCwgLXF1ZXJ5Lmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIGEgcXVlcnkhXG4gICAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSA9PT0gJz8nKSB7XG4gICAgICByZXR1cm4gYmFzZSArIHJlbGF0aXZlO1xuICAgIH1cbiAgICB2YXIgc3RhY2sgPSBiYXNlLnNwbGl0KCcvJyk7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNlZ21lbnQgaWY6XG4gICAgLy8gLSBub3QgYXBwZW5kaW5nXG4gICAgLy8gLSBhcHBlbmRpbmcgdG8gdHJhaWxpbmcgc2xhc2ggKGxhc3Qgc2VnbWVudCBpcyBlbXB0eSlcbiAgICBpZiAoIWFwcGVuZCB8fCAhc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICAvLyByZXNvbHZlIHJlbGF0aXZlIHBhdGhcbiAgICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgIGlmIChzZWdtZW50ID09PSAnLicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFjay5wdXNoKHNlZ21lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBlbnN1cmUgbGVhZGluZyBzbGFzaFxuICAgIGlmIChzdGFja1swXSAhPT0gJycpIHtcbiAgICAgIHN0YWNrLnVuc2hpZnQoJycpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2suam9pbignLycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmdpdmluZyBjaGVjayBmb3IgYSBwcm9taXNlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGlzUHJvbWlzZShwKSB7XG4gICAgcmV0dXJuIHAgJiYgdHlwZW9mIHAudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaXZlIGEgcm91dGUgY29uZmlnIGZpZWxkIGZyb20gYSBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogT1IgYSBjb21wb25lbnQgY29udHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxWdWV9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRSb3V0ZUNvbmZpZyhjb21wb25lbnQsIG5hbWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGNvbXBvbmVudCAmJiAoY29tcG9uZW50LiRvcHRpb25zIHx8IGNvbXBvbmVudC5vcHRpb25zKTtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGVbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeS4gSGF2ZSB0byBkbyBhIGRpcnR5XG4gICAqIG1vY2sgaGVyZSBiZWNhdXNlIG9mIFZ1ZSBjb3JlJ3MgaW50ZXJuYWwgQVBJIGRlcGVuZHMgb25cbiAgICogYW4gSUQgY2hlY2suXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqL1xuXG4gIHZhciByZXNvbHZlciA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQoaGFuZGxlciwgY2IpIHtcbiAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICByZXNvbHZlciA9IHtcbiAgICAgICAgcmVzb2x2ZTogZXhwb3J0cyQxLlZ1ZS5wcm90b3R5cGUuX3Jlc29sdmVDb21wb25lbnQsXG4gICAgICAgICRvcHRpb25zOiB7XG4gICAgICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAgICAgXzogaGFuZGxlci5jb21wb25lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVyLiRvcHRpb25zLmNvbXBvbmVudHMuXyA9IGhhbmRsZXIuY29tcG9uZW50O1xuICAgIH1cbiAgICByZXNvbHZlci5yZXNvbHZlKCdfJywgZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgICAgaGFuZGxlci5jb21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgICBjYihDb21wb25lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcCB0aGUgZHluYW1pYyBzZWdtZW50cyBpbiBhIHBhdGggdG8gcGFyYW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBxdWVyeVxuICAgKi9cblxuICBmdW5jdGlvbiBtYXBQYXJhbXMocGF0aCwgcGFyYW1zLCBxdWVyeSkge1xuICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkgcGFyYW1zID0ge307XG5cbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC86KFteXFwvXSspL2csIGZ1bmN0aW9uIChfLCBrZXkpIHtcbiAgICAgIHZhciB2YWwgPSBwYXJhbXNba2V5XTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgd2FybiQxKCdwYXJhbSBcIicgKyBrZXkgKyAnXCIgbm90IGZvdW5kIHdoZW4gZ2VuZXJhdGluZyAnICsgJ3BhdGggZm9yIFwiJyArIHBhdGggKyAnXCIgd2l0aCBwYXJhbXMgJyArIEpTT04uc3RyaW5naWZ5KHBhcmFtcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbCB8fCAnJztcbiAgICB9KTtcbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHBhdGggKz0gZ2VuUXVlcnkocXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIHZhciBoYXNoUkUgPSAvIy4qJC87XG5cbiAgdmFyIEhUTUw1SGlzdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSFRNTDVIaXN0b3J5KF9yZWYpIHtcbiAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgICAgdmFyIG9uQ2hhbmdlID0gX3JlZi5vbkNoYW5nZTtcbiAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBIVE1MNUhpc3RvcnkpO1xuXG4gICAgICBpZiAocm9vdCAmJiByb290ICE9PSAnLycpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlJ3MgdGhlIHN0YXJ0aW5nIHNsYXNoXG4gICAgICAgIGlmIChyb290LmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgICAgcm9vdCA9ICcvJyArIHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgICAgdGhpcy5yb290UkUgPSBuZXcgUmVnRXhwKCdeXFxcXCcgKyB0aGlzLnJvb3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICAgIC8vIGNoZWNrIGJhc2UgdGFnXG4gICAgICB2YXIgYmFzZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgICAgdGhpcy5iYXNlID0gYmFzZUVsICYmIGJhc2VFbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICB9XG5cbiAgICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHVybCA9IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoO1xuICAgICAgICBpZiAoX3RoaXMucm9vdCkge1xuICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKF90aGlzLnJvb3RSRSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlKHVybCwgZSAmJiBlLnN0YXRlLCBsb2NhdGlvbi5oYXNoKTtcbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIHRoaXMubGlzdGVuZXIoKTtcbiAgICB9O1xuXG4gICAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMubGlzdGVuZXIpO1xuICAgIH07XG5cbiAgICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28ocGF0aCwgcmVwbGFjZSwgYXBwZW5kKSB7XG4gICAgICB2YXIgdXJsID0gdGhpcy5mb3JtYXRQYXRoKHBhdGgsIGFwcGVuZCk7XG4gICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJycsIHVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWNvcmQgc2Nyb2xsIHBvc2l0aW9uIGJ5IHJlcGxhY2luZyBjdXJyZW50IHN0YXRlXG4gICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHtcbiAgICAgICAgICBwb3M6IHtcbiAgICAgICAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgICAgICAgIH1cbiAgICAgICAgfSwgJycsIGxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAvLyB0aGVuIHB1c2ggbmV3IHN0YXRlXG4gICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgdXJsKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoTWF0Y2ggPSBwYXRoLm1hdGNoKGhhc2hSRSk7XG4gICAgICB2YXIgaGFzaCA9IGhhc2hNYXRjaCAmJiBoYXNoTWF0Y2hbMF07XG4gICAgICBwYXRoID0gdXJsXG4gICAgICAvLyBzdHJpcCBoYXNoIHNvIGl0IGRvZXNuJ3QgbWVzcyB1cCBwYXJhbXNcbiAgICAgIC5yZXBsYWNlKGhhc2hSRSwgJycpXG4gICAgICAvLyByZW1vdmUgcm9vdCBiZWZvcmUgbWF0Y2hpbmdcbiAgICAgIC5yZXBsYWNlKHRoaXMucm9vdFJFLCAnJyk7XG4gICAgICB0aGlzLm9uQ2hhbmdlKHBhdGgsIG51bGwsIGhhc2gpO1xuICAgIH07XG5cbiAgICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmZvcm1hdFBhdGggPSBmdW5jdGlvbiBmb3JtYXRQYXRoKHBhdGgsIGFwcGVuZCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLydcbiAgICAgIC8vIGFic29sdXRlIHBhdGhcbiAgICAgID8gdGhpcy5yb290ID8gdGhpcy5yb290ICsgJy8nICsgcGF0aC5yZXBsYWNlKC9eXFwvLywgJycpIDogcGF0aCA6IHJlc29sdmVQYXRoKHRoaXMuYmFzZSB8fCBsb2NhdGlvbi5wYXRobmFtZSwgcGF0aCwgYXBwZW5kKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEhUTUw1SGlzdG9yeTtcbiAgfSkoKTtcblxuICB2YXIgSGFzaEhpc3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhhc2hIaXN0b3J5KF9yZWYpIHtcbiAgICAgIHZhciBoYXNoYmFuZyA9IF9yZWYuaGFzaGJhbmc7XG4gICAgICB2YXIgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlO1xuICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIEhhc2hIaXN0b3J5KTtcblxuICAgICAgdGhpcy5oYXNoYmFuZyA9IGhhc2hiYW5nO1xuICAgICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgIH1cblxuICAgIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBsb2NhdGlvbi5oYXNoO1xuICAgICAgICB2YXIgcmF3ID0gcGF0aC5yZXBsYWNlKC9eIyE/LywgJycpO1xuICAgICAgICAvLyBhbHdheXNcbiAgICAgICAgaWYgKHJhdy5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgICAgIHJhdyA9ICcvJyArIHJhdztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9ybWF0dGVkUGF0aCA9IHNlbGYuZm9ybWF0UGF0aChyYXcpO1xuICAgICAgICBpZiAoZm9ybWF0dGVkUGF0aCAhPT0gcGF0aCkge1xuICAgICAgICAgIGxvY2F0aW9uLnJlcGxhY2UoZm9ybWF0dGVkUGF0aCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRldGVybWluZSBxdWVyeVxuICAgICAgICAvLyBub3RlIGl0J3MgcG9zc2libGUgdG8gaGF2ZSBxdWVyaWVzIGluIGJvdGggdGhlIGFjdHVhbCBVUkxcbiAgICAgICAgLy8gYW5kIHRoZSBoYXNoIGZyYWdtZW50IGl0c2VsZi5cbiAgICAgICAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24uc2VhcmNoICYmIHBhdGguaW5kZXhPZignPycpID4gLTEgPyAnJicgKyBsb2NhdGlvbi5zZWFyY2guc2xpY2UoMSkgOiBsb2NhdGlvbi5zZWFyY2g7XG4gICAgICAgIHNlbGYub25DaGFuZ2UocGF0aC5yZXBsYWNlKC9eIyE/LywgJycpICsgcXVlcnkpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgICB0aGlzLmxpc3RlbmVyKCk7XG4gICAgfTtcblxuICAgIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgfTtcblxuICAgIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvKHBhdGgsIHJlcGxhY2UsIGFwcGVuZCkge1xuICAgICAgcGF0aCA9IHRoaXMuZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpO1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY2F0aW9uLmhhc2ggPSBwYXRoO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZm9ybWF0UGF0aCA9IGZ1bmN0aW9uIGZvcm1hdFBhdGgocGF0aCwgYXBwZW5kKSB7XG4gICAgICB2YXIgaXNBYnNvbG91dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICAgICAgdmFyIHByZWZpeCA9ICcjJyArICh0aGlzLmhhc2hiYW5nID8gJyEnIDogJycpO1xuICAgICAgcmV0dXJuIGlzQWJzb2xvdXRlID8gcHJlZml4ICsgcGF0aCA6IHByZWZpeCArIHJlc29sdmVQYXRoKGxvY2F0aW9uLmhhc2gucmVwbGFjZSgvXiMhPy8sICcnKSwgcGF0aCwgYXBwZW5kKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEhhc2hIaXN0b3J5O1xuICB9KSgpO1xuXG4gIHZhciBBYnN0cmFjdEhpc3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0SGlzdG9yeShfcmVmKSB7XG4gICAgICB2YXIgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlO1xuICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIEFic3RyYWN0SGlzdG9yeSk7XG5cbiAgICAgIHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICAgIHRoaXMuY3VycmVudFBhdGggPSAnLyc7XG4gICAgfVxuXG4gICAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdGhpcy5vbkNoYW5nZSgnLycpO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgLy8gbm9vcFxuICAgIH07XG5cbiAgICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28ocGF0aCwgcmVwbGFjZSwgYXBwZW5kKSB7XG4gICAgICBwYXRoID0gdGhpcy5jdXJyZW50UGF0aCA9IHRoaXMuZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpO1xuICAgICAgdGhpcy5vbkNoYW5nZShwYXRoKTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5mb3JtYXRQYXRoID0gZnVuY3Rpb24gZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6IHJlc29sdmVQYXRoKHRoaXMuY3VycmVudFBhdGgsIHBhdGgsIGFwcGVuZCk7XG4gICAgfTtcblxuICAgIHJldHVybiBBYnN0cmFjdEhpc3Rvcnk7XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgcmV1c2FiaWxpdHkgb2YgYW4gZXhpc3Rpbmcgcm91dGVyIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSB7RGlyZWN0aXZlfSB2aWV3XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7VHJhbnNpdGlvbn0gdHJhbnNpdGlvblxuICAgKi9cblxuICBmdW5jdGlvbiBjYW5SZXVzZSh2aWV3LCBoYW5kbGVyLCB0cmFuc2l0aW9uKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHZpZXcuY2hpbGRWTTtcbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhaGFuZGxlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBpbXBvcnRhbnQ6IGNoZWNrIHZpZXcuQ29tcG9uZW50IGhlcmUgYmVjYXVzZSBpdCBtYXlcbiAgICAvLyBoYXZlIGJlZW4gY2hhbmdlZCBpbiBhY3RpdmF0ZSBob29rXG4gICAgaWYgKHZpZXcuQ29tcG9uZW50ICE9PSBoYW5kbGVyLmNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY2FuUmV1c2VGbiA9IGdldFJvdXRlQ29uZmlnKGNvbXBvbmVudCwgJ2NhblJldXNlJyk7XG4gICAgcmV0dXJuIHR5cGVvZiBjYW5SZXVzZUZuID09PSAnYm9vbGVhbicgPyBjYW5SZXVzZUZuIDogY2FuUmV1c2VGbiA/IGNhblJldXNlRm4uY2FsbChjb21wb25lbnQsIHtcbiAgICAgIHRvOiB0cmFuc2l0aW9uLnRvLFxuICAgICAgZnJvbTogdHJhbnNpdGlvbi5mcm9tXG4gICAgfSkgOiB0cnVlOyAvLyBkZWZhdWx0cyB0byB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBjb21wb25lbnQgY2FuIGRlYWN0aXZhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RGlyZWN0aXZlfSB2aWV3XG4gICAqIEBwYXJhbSB7VHJhbnNpdGlvbn0gdHJhbnNpdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhbkRlYWN0aXZhdGUodmlldywgdHJhbnNpdGlvbiwgbmV4dCkge1xuICAgIHZhciBmcm9tQ29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICAgIHZhciBob29rID0gZ2V0Um91dGVDb25maWcoZnJvbUNvbXBvbmVudCwgJ2NhbkRlYWN0aXZhdGUnKTtcbiAgICBpZiAoIWhvb2spIHtcbiAgICAgIG5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNpdGlvbi5jYWxsSG9vayhob29rLCBmcm9tQ29tcG9uZW50LCBuZXh0LCB7XG4gICAgICAgIGV4cGVjdEJvb2xlYW46IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGNvbXBvbmVudCBjYW4gYWN0aXZhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7VHJhbnNpdGlvbn0gdHJhbnNpdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhbkFjdGl2YXRlKGhhbmRsZXIsIHRyYW5zaXRpb24sIG5leHQpIHtcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnQoaGFuZGxlciwgZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgICAgLy8gaGF2ZSB0byBjaGVjayBkdWUgdG8gYXN5bmMtbmVzc1xuICAgICAgaWYgKHRyYW5zaXRpb24uYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBkZXRlcm1pbmUgaWYgdGhpcyBjb21wb25lbnQgY2FuIGJlIGFjdGl2YXRlZFxuICAgICAgdmFyIGhvb2sgPSBnZXRSb3V0ZUNvbmZpZyhDb21wb25lbnQsICdjYW5BY3RpdmF0ZScpO1xuICAgICAgaWYgKCFob29rKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb24uY2FsbEhvb2soaG9vaywgbnVsbCwgbmV4dCwge1xuICAgICAgICAgIGV4cGVjdEJvb2xlYW46IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBkZWFjdGl2YXRlIGhvb2tzIGZvciBleGlzdGluZyByb3V0ZXItdmlld3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RGlyZWN0aXZlfSB2aWV3XG4gICAqIEBwYXJhbSB7VHJhbnNpdGlvbn0gdHJhbnNpdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGRlYWN0aXZhdGUodmlldywgdHJhbnNpdGlvbiwgbmV4dCkge1xuICAgIHZhciBjb21wb25lbnQgPSB2aWV3LmNoaWxkVk07XG4gICAgdmFyIGhvb2sgPSBnZXRSb3V0ZUNvbmZpZyhjb21wb25lbnQsICdkZWFjdGl2YXRlJyk7XG4gICAgaWYgKCFob29rKSB7XG4gICAgICBuZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zaXRpb24uY2FsbEhvb2tzKGhvb2ssIGNvbXBvbmVudCwgbmV4dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIC8gc3dpdGNoIGNvbXBvbmVudCBmb3IgYSByb3V0ZXItdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXdcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFjdGl2YXRlKHZpZXcsIHRyYW5zaXRpb24sIGRlcHRoLCBjYiwgcmV1c2UpIHtcbiAgICB2YXIgaGFuZGxlciA9IHRyYW5zaXRpb24uYWN0aXZhdGVRdWV1ZVtkZXB0aF07XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBzYXZlQ2hpbGRWaWV3KHZpZXcpO1xuICAgICAgaWYgKHZpZXcuX2JvdW5kKSB7XG4gICAgICAgIHZpZXcuc2V0Q29tcG9uZW50KG51bGwpO1xuICAgICAgfVxuICAgICAgY2IgJiYgY2IoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gdmlldy5Db21wb25lbnQgPSBoYW5kbGVyLmNvbXBvbmVudDtcbiAgICB2YXIgYWN0aXZhdGVIb29rID0gZ2V0Um91dGVDb25maWcoQ29tcG9uZW50LCAnYWN0aXZhdGUnKTtcbiAgICB2YXIgZGF0YUhvb2sgPSBnZXRSb3V0ZUNvbmZpZyhDb21wb25lbnQsICdkYXRhJyk7XG4gICAgdmFyIHdhaXRGb3JEYXRhID0gZ2V0Um91dGVDb25maWcoQ29tcG9uZW50LCAnd2FpdEZvckRhdGEnKTtcblxuICAgIHZpZXcuZGVwdGggPSBkZXB0aDtcbiAgICB2aWV3LmFjdGl2YXRlZCA9IGZhbHNlO1xuXG4gICAgdmFyIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgbG9hZGluZyA9ICEhKGRhdGFIb29rICYmICF3YWl0Rm9yRGF0YSk7XG5cbiAgICAvLyBcInJldXNlXCIgaXMgYSBmbGFnIHBhc3NlZCBkb3duIHdoZW4gdGhlIHBhcmVudCB2aWV3IGlzXG4gICAgLy8gZWl0aGVyIHJldXNlZCB2aWEga2VlcC1hbGl2ZSBvciBhcyBhIGNoaWxkIG9mIGEga2VwdC1hbGl2ZSB2aWV3LlxuICAgIC8vIG9mIGNvdXJzZSB3ZSBjYW4gb25seSByZXVzZSBpZiB0aGUgY3VycmVudCBrZXB0LWFsaXZlIGluc3RhbmNlXG4gICAgLy8gaXMgb2YgdGhlIGNvcnJlY3QgdHlwZS5cbiAgICByZXVzZSA9IHJldXNlICYmIHZpZXcuY2hpbGRWTSAmJiB2aWV3LmNoaWxkVk0uY29uc3RydWN0b3IgPT09IENvbXBvbmVudDtcblxuICAgIGlmIChyZXVzZSkge1xuICAgICAgLy8ganVzdCByZXVzZVxuICAgICAgY29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICAgICAgY29tcG9uZW50LiRsb2FkaW5nUm91dGVEYXRhID0gbG9hZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgc2F2ZUNoaWxkVmlldyh2aWV3KTtcblxuICAgICAgLy8gdW5idWlsZCBjdXJyZW50IGNvbXBvbmVudC4gdGhpcyBzdGVwIGFsc28gZGVzdHJveXNcbiAgICAgIC8vIGFuZCByZW1vdmVzIGFsbCBuZXN0ZWQgY2hpbGQgdmlld3MuXG4gICAgICB2aWV3LnVuYnVpbGQodHJ1ZSk7XG5cbiAgICAgIC8vIGJ1aWxkIHRoZSBuZXcgY29tcG9uZW50LiB0aGlzIHdpbGwgYWxzbyBjcmVhdGUgdGhlXG4gICAgICAvLyBkaXJlY3QgY2hpbGQgdmlldyBvZiB0aGUgY3VycmVudCBvbmUuIGl0IHdpbGwgcmVnaXN0ZXJcbiAgICAgIC8vIGl0c2VsZiBhcyB2aWV3LmNoaWxkVmlldy5cbiAgICAgIGNvbXBvbmVudCA9IHZpZXcuYnVpbGQoe1xuICAgICAgICBfbWV0YToge1xuICAgICAgICAgICRsb2FkaW5nUm91dGVEYXRhOiBsb2FkaW5nXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICAgICAgdGhpcy5fcm91dGVyVmlldyA9IHZpZXc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBoYW5kbGUga2VlcC1hbGl2ZS5cbiAgICAgIC8vIHdoZW4gYSBrZXB0LWFsaXZlIGNoaWxkIHZtIGlzIHJlc3RvcmVkLCB3ZSBuZWVkIHRvXG4gICAgICAvLyBhZGQgaXRzIGNhY2hlZCBjaGlsZCB2aWV3cyBpbnRvIHRoZSByb3V0ZXIncyB2aWV3IGxpc3QsXG4gICAgICAvLyBhbmQgYWxzbyBwcm9wZXJseSB1cGRhdGUgY3VycmVudCB2aWV3J3MgY2hpbGQgdmlldy5cbiAgICAgIGlmICh2aWV3LmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnQuJGxvYWRpbmdSb3V0ZURhdGEgPSBsb2FkaW5nO1xuICAgICAgICB2YXIgY2FjaGVkQ2hpbGRWaWV3ID0gY29tcG9uZW50Ll9rZWVwQWxpdmVSb3V0ZXJWaWV3O1xuICAgICAgICBpZiAoY2FjaGVkQ2hpbGRWaWV3KSB7XG4gICAgICAgICAgdmlldy5jaGlsZFZpZXcgPSBjYWNoZWRDaGlsZFZpZXc7XG4gICAgICAgICAgY29tcG9uZW50Ll9rZWVwQWxpdmVSb3V0ZXJWaWV3ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFudXAgdGhlIGNvbXBvbmVudCBpbiBjYXNlIHRoZSB0cmFuc2l0aW9uIGlzIGFib3J0ZWRcbiAgICAvLyBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBldmVyIGluc2VydGVkLlxuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIGNvbXBvbmVudC4kZGVzdHJveSgpO1xuICAgIH07XG5cbiAgICAvLyBhY3R1YWxseSBpbnNlcnQgdGhlIGNvbXBvbmVudCBhbmQgdHJpZ2dlciB0cmFuc2l0aW9uXG4gICAgdmFyIGluc2VydCA9IGZ1bmN0aW9uIGluc2VydCgpIHtcbiAgICAgIGlmIChyZXVzZSkge1xuICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcm91dGVyID0gdHJhbnNpdGlvbi5yb3V0ZXI7XG4gICAgICBpZiAocm91dGVyLl9yZW5kZXJlZCB8fCByb3V0ZXIuX3RyYW5zaXRpb25PbkxvYWQpIHtcbiAgICAgICAgdmlldy50cmFuc2l0aW9uKGNvbXBvbmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyB0cmFuc2l0aW9uIG9uIGZpcnN0IHJlbmRlciwgbWFudWFsIHRyYW5zaXRpb25cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh2aWV3LnNldEN1cnJlbnQpIHtcbiAgICAgICAgICAvLyAwLjEyIGNvbXBhdFxuICAgICAgICAgIHZpZXcuc2V0Q3VycmVudChjb21wb25lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDEuMFxuICAgICAgICAgIHZpZXcuY2hpbGRWTSA9IGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnQuJGJlZm9yZSh2aWV3LmFuY2hvciwgbnVsbCwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgY2IgJiYgY2IoKTtcbiAgICB9O1xuXG4gICAgdmFyIGFmdGVyRGF0YSA9IGZ1bmN0aW9uIGFmdGVyRGF0YSgpIHtcbiAgICAgIC8vIGFjdGl2YXRlIHRoZSBjaGlsZCB2aWV3XG4gICAgICBpZiAodmlldy5jaGlsZFZpZXcpIHtcbiAgICAgICAgYWN0aXZhdGUodmlldy5jaGlsZFZpZXcsIHRyYW5zaXRpb24sIGRlcHRoICsgMSwgbnVsbCwgcmV1c2UgfHwgdmlldy5rZWVwQWxpdmUpO1xuICAgICAgfVxuICAgICAgaW5zZXJ0KCk7XG4gICAgfTtcblxuICAgIC8vIGNhbGxlZCBhZnRlciBhY3RpdmF0aW9uIGhvb2sgaXMgcmVzb2x2ZWRcbiAgICB2YXIgYWZ0ZXJBY3RpdmF0ZSA9IGZ1bmN0aW9uIGFmdGVyQWN0aXZhdGUoKSB7XG4gICAgICB2aWV3LmFjdGl2YXRlZCA9IHRydWU7XG4gICAgICBpZiAoZGF0YUhvb2sgJiYgd2FpdEZvckRhdGEpIHtcbiAgICAgICAgLy8gd2FpdCB1bnRpbCBkYXRhIGxvYWRlZCB0byBpbnNlcnRcbiAgICAgICAgbG9hZERhdGEoY29tcG9uZW50LCB0cmFuc2l0aW9uLCBkYXRhSG9vaywgYWZ0ZXJEYXRhLCBjbGVhbnVwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxvYWQgZGF0YSBhbmQgaW5zZXJ0IGF0IHRoZSBzYW1lIHRpbWVcbiAgICAgICAgaWYgKGRhdGFIb29rKSB7XG4gICAgICAgICAgbG9hZERhdGEoY29tcG9uZW50LCB0cmFuc2l0aW9uLCBkYXRhSG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgYWZ0ZXJEYXRhKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChhY3RpdmF0ZUhvb2spIHtcbiAgICAgIHRyYW5zaXRpb24uY2FsbEhvb2tzKGFjdGl2YXRlSG9vaywgY29tcG9uZW50LCBhZnRlckFjdGl2YXRlLCB7XG4gICAgICAgIGNsZWFudXA6IGNsZWFudXAsXG4gICAgICAgIHBvc3RBY3RpdmF0ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyQWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV1c2UgYSB2aWV3LCBqdXN0IHJlbG9hZCBkYXRhIGlmIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXdcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJldXNlKHZpZXcsIHRyYW5zaXRpb24pIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICAgIHZhciBkYXRhSG9vayA9IGdldFJvdXRlQ29uZmlnKGNvbXBvbmVudCwgJ2RhdGEnKTtcbiAgICBpZiAoZGF0YUhvb2spIHtcbiAgICAgIGxvYWREYXRhKGNvbXBvbmVudCwgdHJhbnNpdGlvbiwgZGF0YUhvb2spO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBsb2FkIGFuZCBhcHBseSBkYXRhIHRvIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1RyYW5zaXRpb259IHRyYW5zaXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGVhbnVwXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGxvYWREYXRhKGNvbXBvbmVudCwgdHJhbnNpdGlvbiwgaG9vaywgY2IsIGNsZWFudXApIHtcbiAgICBjb21wb25lbnQuJGxvYWRpbmdSb3V0ZURhdGEgPSB0cnVlO1xuICAgIHRyYW5zaXRpb24uY2FsbEhvb2tzKGhvb2ssIGNvbXBvbmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgY29tcG9uZW50LiRsb2FkaW5nUm91dGVEYXRhID0gZmFsc2U7XG4gICAgICBjb21wb25lbnQuJGVtaXQoJ3JvdXRlLWRhdGEtbG9hZGVkJywgY29tcG9uZW50KTtcbiAgICAgIGNiICYmIGNiKCk7XG4gICAgfSwge1xuICAgICAgY2xlYW51cDogY2xlYW51cCxcbiAgICAgIHBvc3RBY3RpdmF0ZTogdHJ1ZSxcbiAgICAgIHByb2Nlc3NEYXRhOiBmdW5jdGlvbiBwcm9jZXNzRGF0YShkYXRhKSB7XG4gICAgICAgIC8vIGhhbmRsZSBwcm9taXNlIHN1Z2FyIHN5bnRheFxuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBkYXRhW2tleV07XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKHZhbCkpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh2YWwudGhlbihmdW5jdGlvbiAocmVzb2x2ZWRWYWwpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuJHNldChrZXksIHJlc29sdmVkVmFsKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50LiRzZXQoa2V5LCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZXNbMF0uY29uc3RydWN0b3IuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmUgdGhlIGNoaWxkIHZpZXcgZm9yIGEga2VwdC1hbGl2ZSB2aWV3IHNvIHRoYXRcbiAgICogd2UgY2FuIHJlc3RvcmUgaXQgd2hlbiBpdCBpcyBzd2l0Y2hlZCBiYWNrIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICAgKi9cblxuICBmdW5jdGlvbiBzYXZlQ2hpbGRWaWV3KHZpZXcpIHtcbiAgICBpZiAodmlldy5rZWVwQWxpdmUgJiYgdmlldy5jaGlsZFZNICYmIHZpZXcuY2hpbGRWaWV3KSB7XG4gICAgICB2aWV3LmNoaWxkVk0uX2tlZXBBbGl2ZVJvdXRlclZpZXcgPSB2aWV3LmNoaWxkVmlldztcbiAgICB9XG4gICAgdmlldy5jaGlsZFZpZXcgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHBsYWluIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWxcbiAgICovXG5cbiAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgUm91dGVUcmFuc2l0aW9uIG9iamVjdCBtYW5hZ2VzIHRoZSBwaXBlbGluZSBvZiBhXG4gICAqIHJvdXRlci12aWV3IHN3aXRjaGluZyBwcm9jZXNzLiBUaGlzIGlzIGFsc28gdGhlIG9iamVjdFxuICAgKiBwYXNzZWQgaW50byB1c2VyIHJvdXRlIGhvb2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JvdXRlcn0gcm91dGVyXG4gICAqIEBwYXJhbSB7Um91dGV9IHRvXG4gICAqIEBwYXJhbSB7Um91dGV9IGZyb21cbiAgICovXG5cbiAgdmFyIFJvdXRlVHJhbnNpdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm91dGVUcmFuc2l0aW9uKHJvdXRlciwgdG8sIGZyb20pIHtcbiAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3V0ZVRyYW5zaXRpb24pO1xuXG4gICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYm9ydCBjdXJyZW50IHRyYW5zaXRpb24gYW5kIHJldHVybiB0byBwcmV2aW91cyBsb2NhdGlvbi5cbiAgICAgKi9cblxuICAgIFJvdXRlVHJhbnNpdGlvbi5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIGlmICghdGhpcy5hYm9ydGVkKSB7XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGlmIHRoZSByb290IHBhdGggdGhyb3dzIGFuIGVycm9yIGR1cmluZyB2YWxpZGF0aW9uXG4gICAgICAgIC8vIG9uIGluaXRpYWwgbG9hZCwgaXQgZ2V0cyBjYXVnaHQgaW4gYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgdmFyIGFib3J0aW5nT25Mb2FkID0gIXRoaXMuZnJvbS5wYXRoICYmIHRoaXMudG8ucGF0aCA9PT0gJy8nO1xuICAgICAgICBpZiAoIWFib3J0aW5nT25Mb2FkKSB7XG4gICAgICAgICAgdGhpcy5yb3V0ZXIucmVwbGFjZSh0aGlzLmZyb20ucGF0aCB8fCAnLycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFib3J0IGN1cnJlbnQgdHJhbnNpdGlvbiBhbmQgcmVkaXJlY3QgdG8gYSBuZXcgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqL1xuXG4gICAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5yZWRpcmVjdCA9IGZ1bmN0aW9uIHJlZGlyZWN0KHBhdGgpIHtcbiAgICAgIGlmICghdGhpcy5hYm9ydGVkKSB7XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwYXRoID0gbWFwUGFyYW1zKHBhdGgsIHRoaXMudG8ucGFyYW1zLCB0aGlzLnRvLnF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnBhcmFtcyA9IHBhdGgucGFyYW1zIHx8IHRoaXMudG8ucGFyYW1zO1xuICAgICAgICAgIHBhdGgucXVlcnkgPSBwYXRoLnF1ZXJ5IHx8IHRoaXMudG8ucXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3V0ZXIucmVwbGFjZShwYXRoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSByb3V0ZXIgdmlldyB0cmFuc2l0aW9uJ3MgcGlwZWxpbmUgY2FuIGJlIGRlc2NyaWJlZCBhc1xuICAgICAqIGZvbGxvd3MsIGFzc3VtaW5nIHdlIGFyZSB0cmFuc2l0aW9uaW5nIGZyb20gYW4gZXhpc3RpbmdcbiAgICAgKiA8cm91dGVyLXZpZXc+IGNoYWluIFtDb21wb25lbnQgQSwgQ29tcG9uZW50IEJdIHRvIGEgbmV3XG4gICAgICogY2hhaW4gW0NvbXBvbmVudCBBLCBDb21wb25lbnQgQ106XG4gICAgICpcbiAgICAgKiAgQSAgICBBXG4gICAgICogIHwgPT4gfFxuICAgICAqICBCICAgIENcbiAgICAgKlxuICAgICAqIDEuIFJldXNhYmxpdHkgcGhhc2U6XG4gICAgICogICAtPiBjYW5SZXVzZShBLCBBKVxuICAgICAqICAgLT4gY2FuUmV1c2UoQiwgQylcbiAgICAgKiAgIC0+IGRldGVybWluZSBuZXcgcXVldWVzOlxuICAgICAqICAgICAgLSBkZWFjdGl2YXRpb246IFtCXVxuICAgICAqICAgICAgLSBhY3RpdmF0aW9uOiBbQ11cbiAgICAgKlxuICAgICAqIDIuIFZhbGlkYXRpb24gcGhhc2U6XG4gICAgICogICAtPiBjYW5EZWFjdGl2YXRlKEIpXG4gICAgICogICAtPiBjYW5BY3RpdmF0ZShDKVxuICAgICAqXG4gICAgICogMy4gQWN0aXZhdGlvbiBwaGFzZTpcbiAgICAgKiAgIC0+IGRlYWN0aXZhdGUoQilcbiAgICAgKiAgIC0+IGFjdGl2YXRlKEMpXG4gICAgICpcbiAgICAgKiBFYWNoIG9mIHRoZXNlIHN0ZXBzIGNhbiBiZSBhc3luY2hyb25vdXMsIGFuZCBhbnlcbiAgICAgKiBzdGVwIGNhbiBwb3RlbnRpYWxseSBhYm9ydCB0aGUgdHJhbnNpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICovXG5cbiAgICBSb3V0ZVRyYW5zaXRpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoY2IpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcztcblxuICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBxdWV1ZSBvZiB2aWV3cyB0byBkZWFjdGl2YXRlXG4gICAgICB2YXIgZGVhY3RpdmF0ZVF1ZXVlID0gW107XG4gICAgICB2YXIgdmlldyA9IHRoaXMucm91dGVyLl9yb290VmlldztcbiAgICAgIHdoaWxlICh2aWV3KSB7XG4gICAgICAgIGRlYWN0aXZhdGVRdWV1ZS51bnNoaWZ0KHZpZXcpO1xuICAgICAgICB2aWV3ID0gdmlldy5jaGlsZFZpZXc7XG4gICAgICB9XG4gICAgICB2YXIgcmV2ZXJzZURlYWN0aXZhdGVRdWV1ZSA9IGRlYWN0aXZhdGVRdWV1ZS5zbGljZSgpLnJldmVyc2UoKTtcblxuICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBxdWV1ZSBvZiByb3V0ZSBoYW5kbGVycyB0byBhY3RpdmF0ZVxuICAgICAgdmFyIGFjdGl2YXRlUXVldWUgPSB0aGlzLmFjdGl2YXRlUXVldWUgPSB0b0FycmF5KHRoaXMudG8ubWF0Y2hlZCkubWFwKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gbWF0Y2guaGFuZGxlcjtcbiAgICAgIH0pO1xuXG4gICAgICAvLyAxLiBSZXVzYWJpbGl0eSBwaGFzZVxuICAgICAgdmFyIGkgPSB1bmRlZmluZWQsXG4gICAgICAgICAgcmV1c2VRdWV1ZSA9IHVuZGVmaW5lZDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXZlcnNlRGVhY3RpdmF0ZVF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghY2FuUmV1c2UocmV2ZXJzZURlYWN0aXZhdGVRdWV1ZVtpXSwgYWN0aXZhdGVRdWV1ZVtpXSwgdHJhbnNpdGlvbikpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHJldXNlUXVldWUgPSByZXZlcnNlRGVhY3RpdmF0ZVF1ZXVlLnNsaWNlKDAsIGkpO1xuICAgICAgICBkZWFjdGl2YXRlUXVldWUgPSByZXZlcnNlRGVhY3RpdmF0ZVF1ZXVlLnNsaWNlKGkpLnJldmVyc2UoKTtcbiAgICAgICAgYWN0aXZhdGVRdWV1ZSA9IGFjdGl2YXRlUXVldWUuc2xpY2UoaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFZhbGlkYXRpb24gcGhhc2VcbiAgICAgIHRyYW5zaXRpb24ucnVuUXVldWUoZGVhY3RpdmF0ZVF1ZXVlLCBjYW5EZWFjdGl2YXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyYW5zaXRpb24ucnVuUXVldWUoYWN0aXZhdGVRdWV1ZSwgY2FuQWN0aXZhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uLnJ1blF1ZXVlKGRlYWN0aXZhdGVRdWV1ZSwgZGVhY3RpdmF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gMy4gQWN0aXZhdGlvbiBwaGFzZVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgcm91dGVyIGN1cnJlbnQgcm91dGVcbiAgICAgICAgICAgIHRyYW5zaXRpb24ucm91dGVyLl9vblRyYW5zaXRpb25WYWxpZGF0ZWQodHJhbnNpdGlvbik7XG5cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgcmV1c2UgZm9yIGFsbCByZXVzZWQgdmlld3NcbiAgICAgICAgICAgIHJldXNlUXVldWUgJiYgcmV1c2VRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXVzZSh2aWV3LCB0cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB0aGUgcm9vdCBvZiB0aGUgY2hhaW4gdGhhdCBuZWVkcyB0byBiZSByZXBsYWNlZFxuICAgICAgICAgICAgLy8gaXMgdGhlIHRvcC1tb3N0IG5vbi1yZXVzYWJsZSB2aWV3LlxuICAgICAgICAgICAgaWYgKGRlYWN0aXZhdGVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIF92aWV3ID0gZGVhY3RpdmF0ZVF1ZXVlW2RlYWN0aXZhdGVRdWV1ZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgdmFyIGRlcHRoID0gcmV1c2VRdWV1ZSA/IHJldXNlUXVldWUubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgYWN0aXZhdGUoX3ZpZXcsIHRyYW5zaXRpb24sIGRlcHRoLCBjYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSBhbmQgc2VxdWVudGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gdG8gYVxuICAgICAqIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcXVldWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICovXG5cbiAgICBSb3V0ZVRyYW5zaXRpb24ucHJvdG90eXBlLnJ1blF1ZXVlID0gZnVuY3Rpb24gcnVuUXVldWUocXVldWUsIGZuLCBjYikge1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzO1xuICAgICAgc3RlcCgwKTtcbiAgICAgIGZ1bmN0aW9uIHN0ZXAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm4ocXVldWVbaW5kZXhdLCB0cmFuc2l0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbCBhIHVzZXIgcHJvdmlkZWQgcm91dGUgdHJhbnNpdGlvbiBob29rIGFuZCBoYW5kbGVcbiAgICAgKiB0aGUgcmVzcG9uc2UgKGUuZy4gaWYgdGhlIHVzZXIgcmV0dXJucyBhIHByb21pc2UpLlxuICAgICAqXG4gICAgICogSWYgdGhlIHVzZXIgbmVpdGhlciBleHBlY3RzIGFuIGFyZ3VtZW50IG5vciByZXR1cm5zIGFcbiAgICAgKiBwcm9taXNlLCB0aGUgaG9vayBpcyBhc3N1bWVkIHRvIGJlIHN5bmNocm9ub3VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va1xuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZXhwZWN0Qm9vbGVhblxuICAgICAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBwb3N0QWN0aXZlXG4gICAgICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBwcm9jZXNzRGF0YVxuICAgICAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gY2xlYW51cFxuICAgICAqL1xuXG4gICAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5jYWxsSG9vayA9IGZ1bmN0aW9uIGNhbGxIb29rKGhvb2ssIGNvbnRleHQsIGNiKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzNdO1xuXG4gICAgICB2YXIgX3JlZiRleHBlY3RCb29sZWFuID0gX3JlZi5leHBlY3RCb29sZWFuO1xuICAgICAgdmFyIGV4cGVjdEJvb2xlYW4gPSBfcmVmJGV4cGVjdEJvb2xlYW4gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRleHBlY3RCb29sZWFuO1xuICAgICAgdmFyIF9yZWYkcG9zdEFjdGl2YXRlID0gX3JlZi5wb3N0QWN0aXZhdGU7XG4gICAgICB2YXIgcG9zdEFjdGl2YXRlID0gX3JlZiRwb3N0QWN0aXZhdGUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRwb3N0QWN0aXZhdGU7XG4gICAgICB2YXIgcHJvY2Vzc0RhdGEgPSBfcmVmLnByb2Nlc3NEYXRhO1xuICAgICAgdmFyIGNsZWFudXAgPSBfcmVmLmNsZWFudXA7XG5cbiAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcztcbiAgICAgIHZhciBuZXh0Q2FsbGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIGFib3J0IHRoZSB0cmFuc2l0aW9uXG4gICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgY2xlYW51cCAmJiBjbGVhbnVwKCk7XG4gICAgICAgIHRyYW5zaXRpb24uYWJvcnQoKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGhhbmRsZSBlcnJvcnNcbiAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICAgICAgcG9zdEFjdGl2YXRlID8gbmV4dCgpIDogYWJvcnQoKTtcbiAgICAgICAgaWYgKGVyciAmJiAhdHJhbnNpdGlvbi5yb3V0ZXIuX3N1cHByZXNzKSB7XG4gICAgICAgICAgd2FybiQxKCdVbmNhdWdodCBlcnJvciBkdXJpbmcgdHJhbnNpdGlvbjogJyk7XG4gICAgICAgICAgdGhyb3cgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gc2luY2UgcHJvbWlzZSBzd2FsbG93cyBlcnJvcnMsIHdlIGhhdmUgdG9cbiAgICAgIC8vIHRocm93IGl0IGluIHRoZSBuZXh0IHRpY2suLi5cbiAgICAgIHZhciBvblByb21pc2VFcnJvciA9IGZ1bmN0aW9uIG9uUHJvbWlzZUVycm9yKGVycikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gYWR2YW5jZSB0aGUgdHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGVwXG4gICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmIChuZXh0Q2FsbGVkKSB7XG4gICAgICAgICAgd2FybiQxKCd0cmFuc2l0aW9uLm5leHQoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV4dENhbGxlZCA9IHRydWU7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uLmFib3J0ZWQpIHtcbiAgICAgICAgICBjbGVhbnVwICYmIGNsZWFudXAoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBuZXh0V2l0aEJvb2xlYW4gPSBmdW5jdGlvbiBuZXh0V2l0aEJvb2xlYW4ocmVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXMgPyBuZXh0KCkgOiBhYm9ydCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgICAgcmVzLnRoZW4oZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgICAgICBvayA/IG5leHQoKSA6IGFib3J0KCk7XG4gICAgICAgICAgfSwgb25Qcm9taXNlRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFob29rLmxlbmd0aCkge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG5leHRXaXRoRGF0YSA9IGZ1bmN0aW9uIG5leHRXaXRoRGF0YShkYXRhKSB7XG4gICAgICAgIHZhciByZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gcHJvY2Vzc0RhdGEoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBvbkVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgICAgcmVzLnRoZW4obmV4dCwgb25Qcm9taXNlRXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gZXhwb3NlIGEgY2xvbmUgb2YgdGhlIHRyYW5zaXRpb24gb2JqZWN0LCBzbyB0aGF0IGVhY2hcbiAgICAgIC8vIGhvb2sgZ2V0cyBhIGNsZWFuIGNvcHkgYW5kIHByZXZlbnQgdGhlIHVzZXIgZnJvbVxuICAgICAgLy8gbWVzc2luZyB3aXRoIHRoZSBpbnRlcm5hbHMuXG4gICAgICB2YXIgZXhwb3NlZCA9IHtcbiAgICAgICAgdG86IHRyYW5zaXRpb24udG8sXG4gICAgICAgIGZyb206IHRyYW5zaXRpb24uZnJvbSxcbiAgICAgICAgYWJvcnQ6IGFib3J0LFxuICAgICAgICBuZXh0OiBwcm9jZXNzRGF0YSA/IG5leHRXaXRoRGF0YSA6IG5leHQsXG4gICAgICAgIHJlZGlyZWN0OiBmdW5jdGlvbiByZWRpcmVjdCgpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uLnJlZGlyZWN0LmFwcGx5KHRyYW5zaXRpb24sIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGFjdHVhbGx5IGNhbGwgdGhlIGhvb2tcbiAgICAgIHZhciByZXMgPSB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBob29rLmNhbGwoY29udGV4dCwgZXhwb3NlZCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4cGVjdEJvb2xlYW4pIHtcbiAgICAgICAgLy8gYm9vbGVhbiBob29rc1xuICAgICAgICBuZXh0V2l0aEJvb2xlYW4ocmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgLy8gcHJvbWlzZVxuICAgICAgICBpZiAocHJvY2Vzc0RhdGEpIHtcbiAgICAgICAgICByZXMudGhlbihuZXh0V2l0aERhdGEsIG9uUHJvbWlzZUVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMudGhlbihuZXh0LCBvblByb21pc2VFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzc0RhdGEgJiYgaXNQbGFpbk9qYmVjdChyZXMpKSB7XG4gICAgICAgIC8vIGRhdGEgcHJvbWlzZSBzdWdhclxuICAgICAgICBuZXh0V2l0aERhdGEocmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoIWhvb2subGVuZ3RoKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbCBhIHNpbmdsZSBob29rIG9yIGFuIGFycmF5IG9mIGFzeW5jIGhvb2tzIGluIHNlcmllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvb2tzXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICovXG5cbiAgICBSb3V0ZVRyYW5zaXRpb24ucHJvdG90eXBlLmNhbGxIb29rcyA9IGZ1bmN0aW9uIGNhbGxIb29rcyhob29rcywgY29udGV4dCwgY2IsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGhvb2tzKSkge1xuICAgICAgICB0aGlzLnJ1blF1ZXVlKGhvb2tzLCBmdW5jdGlvbiAoaG9vaywgXywgbmV4dCkge1xuICAgICAgICAgIGlmICghX3RoaXMuYWJvcnRlZCkge1xuICAgICAgICAgICAgX3RoaXMuY2FsbEhvb2soaG9vaywgY29udGV4dCwgbmV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBjYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhbGxIb29rKGhvb2tzLCBjb250ZXh0LCBjYiwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBSb3V0ZVRyYW5zaXRpb247XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gaXNQbGFpbk9qYmVjdCh2YWwpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9BcnJheSh2YWwpIHtcbiAgICByZXR1cm4gdmFsID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmFsKSA6IFtdO1xuICB9XG5cbiAgdmFyIGludGVybmFsS2V5c1JFID0gL14oY29tcG9uZW50fHN1YlJvdXRlc3xmdWxsUGF0aCkkLztcblxuICAvKipcbiAgICogUm91dGUgQ29udGV4dCBPYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQHBhcmFtIHtSb3V0ZXJ9IHJvdXRlclxuICAgKi9cblxuICB2YXIgUm91dGUgPSBmdW5jdGlvbiBSb3V0ZShwYXRoLCByb3V0ZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlKTtcblxuICAgIHZhciBtYXRjaGVkID0gcm91dGVyLl9yZWNvZ25pemVyLnJlY29nbml6ZShwYXRoKTtcbiAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgLy8gY29weSBhbGwgY3VzdG9tIGZpZWxkcyBmcm9tIHJvdXRlIGNvbmZpZ3NcbiAgICAgIFtdLmZvckVhY2guY2FsbChtYXRjaGVkLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG1hdGNoLmhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIWludGVybmFsS2V5c1JFLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgX3RoaXNba2V5XSA9IG1hdGNoLmhhbmRsZXJba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gc2V0IHF1ZXJ5IGFuZCBwYXJhbXNcbiAgICAgIHRoaXMucXVlcnkgPSBtYXRjaGVkLnF1ZXJ5UGFyYW1zO1xuICAgICAgdGhpcy5wYXJhbXMgPSBbXS5yZWR1Y2UuY2FsbChtYXRjaGVkLCBmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgICAgIGlmIChjdXIucGFyYW1zKSB7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGN1ci5wYXJhbXMpIHtcbiAgICAgICAgICAgIHByZXZba2V5XSA9IGN1ci5wYXJhbXNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8vIGV4cG9zZSBwYXRoIGFuZCByb3V0ZXJcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIC8vIGZvciBpbnRlcm5hbCB1c2VcbiAgICB0aGlzLm1hdGNoZWQgPSBtYXRjaGVkIHx8IHJvdXRlci5fbm90Rm91bmRIYW5kbGVyO1xuICAgIC8vIGludGVybmFsIHJlZmVyZW5jZSB0byByb3V0ZXJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JvdXRlcicsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHJvdXRlclxuICAgIH0pO1xuICAgIC8vIEltcG9ydGFudDogZnJlZXplIHNlbGYgdG8gcHJldmVudCBvYnNlcnZhdGlvblxuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gYXBwbHlPdmVycmlkZSAoVnVlKSB7XG4gICAgdmFyIF9WdWUkdXRpbCA9IFZ1ZS51dGlsO1xuICAgIHZhciBleHRlbmQgPSBfVnVlJHV0aWwuZXh0ZW5kO1xuICAgIHZhciBpc0FycmF5ID0gX1Z1ZSR1dGlsLmlzQXJyYXk7XG4gICAgdmFyIGRlZmluZVJlYWN0aXZlID0gX1Z1ZSR1dGlsLmRlZmluZVJlYWN0aXZlO1xuXG4gICAgLy8gb3ZlcnJpZGUgVnVlJ3MgaW5pdCBhbmQgZGVzdHJveSBwcm9jZXNzIHRvIGtlZXAgdHJhY2sgb2Ygcm91dGVyIGluc3RhbmNlc1xuICAgIHZhciBpbml0ID0gVnVlLnByb3RvdHlwZS5faW5pdDtcbiAgICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIHJvb3QgPSBvcHRpb25zLl9wYXJlbnQgfHwgb3B0aW9ucy5wYXJlbnQgfHwgdGhpcztcbiAgICAgIHZhciByb3V0ZXIgPSByb290LiRyb3V0ZXI7XG4gICAgICB2YXIgcm91dGUgPSByb290LiRyb3V0ZTtcbiAgICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgICAgLy8gZXhwb3NlIHJvdXRlclxuICAgICAgICB0aGlzLiRyb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHJvdXRlci5fY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLl9kZWZpbmVNZXRhKSB7XG4gICAgICAgICAgLy8gMC4xMlxuICAgICAgICAgIHRoaXMuX2RlZmluZU1ldGEoJyRyb3V0ZScsIHJvdXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAxLjBcbiAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSh0aGlzLCAnJHJvdXRlJywgcm91dGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHZhciBkZXN0cm95ID0gVnVlLnByb3RvdHlwZS5fZGVzdHJveTtcbiAgICBWdWUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc0JlaW5nRGVzdHJveWVkICYmIHRoaXMuJHJvdXRlcikge1xuICAgICAgICB0aGlzLiRyb3V0ZXIuX2NoaWxkcmVuLiRyZW1vdmUodGhpcyk7XG4gICAgICB9XG4gICAgICBkZXN0cm95LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIC8vIDEuMCBvbmx5OiBlbmFibGUgcm91dGUgbWl4aW5zXG4gICAgdmFyIHN0cmF0cyA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuICAgIHZhciBob29rc1RvTWVyZ2VSRSA9IC9eKGRhdGF8YWN0aXZhdGV8ZGVhY3RpdmF0ZSkkLztcblxuICAgIGlmIChzdHJhdHMpIHtcbiAgICAgIHN0cmF0cy5yb3V0ZSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICAgIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICAgIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWw7XG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgICAgICAgdmFyIGEgPSByZXRba2V5XTtcbiAgICAgICAgICB2YXIgYiA9IGNoaWxkVmFsW2tleV07XG4gICAgICAgICAgLy8gZm9yIGRhdGEsIGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlLCB3ZSBuZWVkIHRvIG1lcmdlIHRoZW0gaW50b1xuICAgICAgICAgIC8vIGFycmF5cyBzaW1pbGFyIHRvIGxpZmVjeWNsZSBob29rcy5cbiAgICAgICAgICBpZiAoYSAmJiBob29rc1RvTWVyZ2VSRS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIHJldFtrZXldID0gKGlzQXJyYXkoYSkgPyBhIDogW2FdKS5jb25jYXQoYik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldFtrZXldID0gYjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gVmlldyAoVnVlKSB7XG5cbiAgICB2YXIgXyA9IFZ1ZS51dGlsO1xuICAgIHZhciBjb21wb25lbnREZWYgPVxuICAgIC8vIDAuMTJcbiAgICBWdWUuZGlyZWN0aXZlKCdfY29tcG9uZW50JykgfHxcbiAgICAvLyAxLjBcbiAgICBWdWUuaW50ZXJuYWxEaXJlY3RpdmVzLmNvbXBvbmVudDtcbiAgICAvLyA8cm91dGVyLXZpZXc+IGV4dGVuZHMgdGhlIGludGVybmFsIGNvbXBvbmVudCBkaXJlY3RpdmVcbiAgICB2YXIgdmlld0RlZiA9IF8uZXh0ZW5kKHt9LCBjb21wb25lbnREZWYpO1xuXG4gICAgLy8gd2l0aCBzb21lIG92ZXJyaWRlc1xuICAgIF8uZXh0ZW5kKHZpZXdEZWYsIHtcblxuICAgICAgX2lzUm91dGVyVmlldzogdHJ1ZSxcblxuICAgICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgICAgdmFyIHJvdXRlID0gdGhpcy52bS4kcm91dGU7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgICAgd2FybiQxKCc8cm91dGVyLXZpZXc+IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgJyArICdyb3V0ZXItZW5hYmxlZCBhcHAuJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvcmNlIGR5bmFtaWMgZGlyZWN0aXZlIHNvIHYtY29tcG9uZW50IGRvZXNuJ3RcbiAgICAgICAgLy8gYXR0ZW1wdCB0byBidWlsZCByaWdodCBub3dcbiAgICAgICAgdGhpcy5faXNEeW5hbWljTGl0ZXJhbCA9IHRydWU7XG4gICAgICAgIC8vIGZpbmFsbHksIGluaXQgYnkgZGVsZWdhdGluZyB0byB2LWNvbXBvbmVudFxuICAgICAgICBjb21wb25lbnREZWYuYmluZC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIC8vIGxvY2F0ZSB0aGUgcGFyZW50IHZpZXdcbiAgICAgICAgdmFyIHBhcmVudFZpZXcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnZtO1xuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5fcm91dGVyVmlldykge1xuICAgICAgICAgICAgcGFyZW50VmlldyA9IHBhcmVudC5fcm91dGVyVmlldztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Vmlldykge1xuICAgICAgICAgIC8vIHJlZ2lzdGVyIHNlbGYgYXMgYSBjaGlsZCBvZiB0aGUgcGFyZW50IHZpZXcsXG4gICAgICAgICAgLy8gaW5zdGVhZCBvZiBhY3RpdmF0aW5nIG5vdy4gVGhpcyBpcyBzbyB0aGF0IHRoZVxuICAgICAgICAgIC8vIGNoaWxkJ3MgYWN0aXZhdGUgaG9vayBpcyBjYWxsZWQgYWZ0ZXIgdGhlXG4gICAgICAgICAgLy8gcGFyZW50J3MgaGFzIHJlc29sdmVkLlxuICAgICAgICAgIHRoaXMucGFyZW50VmlldyA9IHBhcmVudFZpZXc7XG4gICAgICAgICAgcGFyZW50Vmlldy5jaGlsZFZpZXcgPSB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHJvb3QgdmlldyFcbiAgICAgICAgICB2YXIgcm91dGVyID0gcm91dGUucm91dGVyO1xuICAgICAgICAgIHJvdXRlci5fcm9vdFZpZXcgPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIGxhdGUtcmVuZGVyZWQgdmlld1xuICAgICAgICAvLyB0d28gcG9zc2liaWxpdGllczpcbiAgICAgICAgLy8gMS4gcm9vdCB2aWV3IHJlbmRlcmVkIGFmdGVyIHRyYW5zaXRpb24gaGFzIGJlZW5cbiAgICAgICAgLy8gICAgdmFsaWRhdGVkO1xuICAgICAgICAvLyAyLiBjaGlsZCB2aWV3IHJlbmRlcmVkIGFmdGVyIHBhcmVudCB2aWV3IGhhcyBiZWVuXG4gICAgICAgIC8vICAgIGFjdGl2YXRlZC5cbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSByb3V0ZS5yb3V0ZXIuX2N1cnJlbnRUcmFuc2l0aW9uO1xuICAgICAgICBpZiAoIXBhcmVudFZpZXcgJiYgdHJhbnNpdGlvbi5kb25lIHx8IHBhcmVudFZpZXcgJiYgcGFyZW50Vmlldy5hY3RpdmF0ZWQpIHtcbiAgICAgICAgICB2YXIgZGVwdGggPSBwYXJlbnRWaWV3ID8gcGFyZW50Vmlldy5kZXB0aCArIDEgOiAwO1xuICAgICAgICAgIGFjdGl2YXRlKHRoaXMsIHRyYW5zaXRpb24sIGRlcHRoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudFZpZXcpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudFZpZXcuY2hpbGRWaWV3ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnREZWYudW5iaW5kLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBWdWUuZWxlbWVudERpcmVjdGl2ZSgncm91dGVyLXZpZXcnLCB2aWV3RGVmKTtcbiAgfVxuXG4gIHZhciB0cmFpbGluZ1NsYXNoUkUgPSAvXFwvJC87XG4gIHZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcbiAgdmFyIHF1ZXJ5U3RyaW5nUkUgPSAvXFw/LiokLztcblxuICAvLyBpbnN0YWxsIHYtbGluaywgd2hpY2ggcHJvdmlkZXMgbmF2aWdhdGlvbiBzdXBwb3J0IGZvclxuICAvLyBIVE1MNSBoaXN0b3J5IG1vZGVcbiAgZnVuY3Rpb24gTGluayAoVnVlKSB7XG4gICAgdmFyIF9WdWUkdXRpbCA9IFZ1ZS51dGlsO1xuICAgIHZhciBfYmluZCA9IF9WdWUkdXRpbC5iaW5kO1xuICAgIHZhciBpc09iamVjdCA9IF9WdWUkdXRpbC5pc09iamVjdDtcbiAgICB2YXIgYWRkQ2xhc3MgPSBfVnVlJHV0aWwuYWRkQ2xhc3M7XG4gICAgdmFyIHJlbW92ZUNsYXNzID0gX1Z1ZSR1dGlsLnJlbW92ZUNsYXNzO1xuXG4gICAgdmFyIG9uUHJpb3JpdHkgPSBWdWUuZGlyZWN0aXZlKCdvbicpLnByaW9yaXR5O1xuICAgIHZhciBMSU5LX1VQREFURSA9ICdfX3Z1ZS1yb3V0ZXItbGluay11cGRhdGVfXyc7XG5cbiAgICB2YXIgYWN0aXZlSWQgPSAwO1xuXG4gICAgVnVlLmRpcmVjdGl2ZSgnbGluay1hY3RpdmUnLCB7XG4gICAgICBwcmlvcml0eTogOTk5OSxcbiAgICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGlkID0gU3RyaW5nKGFjdGl2ZUlkKyspO1xuICAgICAgICAvLyBjb2xsZWN0IHYtbGlua3MgY29udGFpbmVkIHdpdGhpbiB0aGlzIGVsZW1lbnQuXG4gICAgICAgIC8vIHdlIG5lZWQgZG8gdGhpcyBoZXJlIGJlZm9yZSB0aGUgcGFyZW50LWNoaWxkIHJlbGF0aW9uc2hpcFxuICAgICAgICAvLyBnZXRzIG1lc3NlZCB1cCBieSB0ZXJtaW5hbCBkaXJlY3RpdmVzIChpZiwgZm9yLCBjb21wb25lbnRzKVxuICAgICAgICB2YXIgY2hpbGRMaW5rcyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnW3YtbGlua10nKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZExpbmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBsaW5rID0gY2hpbGRMaW5rc1tpXTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmdJZCA9IGxpbmsuZ2V0QXR0cmlidXRlKExJTktfVVBEQVRFKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBleGlzdGluZ0lkID8gZXhpc3RpbmdJZCArICcsJyArIGlkIDogaWQ7XG4gICAgICAgICAgLy8gbGVhdmUgYSBtYXJrIG9uIHRoZSBsaW5rIGVsZW1lbnQgd2hpY2ggY2FuIGJlIHBlcnNpc3RlZFxuICAgICAgICAgIC8vIHRocm91Z2ggZnJhZ21lbnQgY2xvbmVzLlxuICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKExJTktfVVBEQVRFLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52bS4kb24oTElOS19VUERBVEUsIHRoaXMuY2IgPSBmdW5jdGlvbiAobGluaywgcGF0aCkge1xuICAgICAgICAgIGlmIChsaW5rLmFjdGl2ZUlkcy5pbmRleE9mKGlkKSA+IC0xKSB7XG4gICAgICAgICAgICBsaW5rLnVwZGF0ZUNsYXNzZXMocGF0aCwgX3RoaXMuZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICAgIHRoaXMudm0uJG9mZihMSU5LX1VQREFURSwgdGhpcy5jYik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBWdWUuZGlyZWN0aXZlKCdsaW5rJywge1xuICAgICAgcHJpb3JpdHk6IG9uUHJpb3JpdHkgLSAyLFxuXG4gICAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgICB2YXIgdm0gPSB0aGlzLnZtO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF2bS4kcm91dGUpIHtcbiAgICAgICAgICB3YXJuJDEoJ3YtbGluayBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhIHJvdXRlci1lbmFibGVkIGFwcC4nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3V0ZXIgPSB2bS4kcm91dGUucm91dGVyO1xuICAgICAgICAvLyB1cGRhdGUgdGhpbmdzIHdoZW4gdGhlIHJvdXRlIGNoYW5nZXNcbiAgICAgICAgdGhpcy51bndhdGNoID0gdm0uJHdhdGNoKCckcm91dGUnLCBfYmluZCh0aGlzLm9uUm91dGVVcGRhdGUsIHRoaXMpKTtcbiAgICAgICAgLy8gY2hlY2sgdi1saW5rLWFjdGl2ZSBpZHNcbiAgICAgICAgdmFyIGFjdGl2ZUlkcyA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKExJTktfVVBEQVRFKTtcbiAgICAgICAgaWYgKGFjdGl2ZUlkcykge1xuICAgICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKExJTktfVVBEQVRFKTtcbiAgICAgICAgICB0aGlzLmFjdGl2ZUlkcyA9IGFjdGl2ZUlkcy5zcGxpdCgnLCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gaGFuZGxlIGNsaWNrIGlmIGxpbmsgZXhwZWN0cyB0byBiZSBvcGVuZWRcbiAgICAgICAgLy8gaW4gYSBuZXcgd2luZG93L3RhYi5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLmVsLnRhZ05hbWUgPT09ICdBJyAmJiB0aGlzLmVsLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykgPT09ICdfYmxhbmsnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBjbGlja1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBfYmluZCh0aGlzLm9uQ2xpY2ssIHRoaXMpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVyKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHRhcmdldCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZCA9IHRhcmdldC5hcHBlbmQ7XG4gICAgICAgICAgdGhpcy5leGFjdCA9IHRhcmdldC5leGFjdDtcbiAgICAgICAgICB0aGlzLnByZXZBY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3M7XG4gICAgICAgICAgdGhpcy5hY3RpdmVDbGFzcyA9IHRhcmdldC5hY3RpdmVDbGFzcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uUm91dGVVcGRhdGUodGhpcy52bS4kcm91dGUpO1xuICAgICAgfSxcblxuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSByZXR1cm47XG4gICAgICAgIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICAgIC8vIGRvbid0IHJlZGlyZWN0IG9uIHJpZ2h0IGNsaWNrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZS5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAvLyB2LWxpbmsgd2l0aCBleHByZXNzaW9uLCBqdXN0IGdvXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMucm91dGVyLmdvKHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gZXhwcmVzc2lvbiwgZGVsZWdhdGUgZm9yIGFuIDxhPiBpbnNpZGVcbiAgICAgICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgICAgICB3aGlsZSAoZWwudGFnTmFtZSAhPT0gJ0EnICYmIGVsICE9PSB0aGlzLmVsKSB7XG4gICAgICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC50YWdOYW1lID09PSAnQScgJiYgc2FtZU9yaWdpbihlbCkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gZWwucGF0aG5hbWU7XG4gICAgICAgICAgICBpZiAodGhpcy5yb3V0ZXIuaGlzdG9yeS5yb290KSB7XG4gICAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UodGhpcy5yb3V0ZXIuaGlzdG9yeS5yb290UkUsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucm91dGVyLmdvKHtcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgcmVwbGFjZTogdGFyZ2V0ICYmIHRhcmdldC5yZXBsYWNlLFxuICAgICAgICAgICAgICBhcHBlbmQ6IHRhcmdldCAmJiB0YXJnZXQuYXBwZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG9uUm91dGVVcGRhdGU6IGZ1bmN0aW9uIG9uUm91dGVVcGRhdGUocm91dGUpIHtcbiAgICAgICAgLy8gcm91dGVyLnN0cmluZ2lmeVBhdGggaXMgZGVwZW5kZW50IG9uIGN1cnJlbnQgcm91dGVcbiAgICAgICAgLy8gYW5kIG5lZWRzIHRvIGJlIGNhbGxlZCBhZ2FpbiB3aGVudmVyIHJvdXRlIGNoYW5nZXMuXG4gICAgICAgIHZhciBuZXdQYXRoID0gdGhpcy5yb3V0ZXIuc3RyaW5naWZ5UGF0aCh0aGlzLnRhcmdldCk7XG4gICAgICAgIGlmICh0aGlzLnBhdGggIT09IG5ld1BhdGgpIHtcbiAgICAgICAgICB0aGlzLnBhdGggPSBuZXdQYXRoO1xuICAgICAgICAgIHRoaXMudXBkYXRlQWN0aXZlTWF0Y2goKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUhyZWYoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY3RpdmVJZHMpIHtcbiAgICAgICAgICB0aGlzLnZtLiRlbWl0KExJTktfVVBEQVRFLCB0aGlzLCByb3V0ZS5wYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNsYXNzZXMocm91dGUucGF0aCwgdGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZUFjdGl2ZU1hdGNoOiBmdW5jdGlvbiB1cGRhdGVBY3RpdmVNYXRjaCgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSRSA9IHRoaXMucGF0aCAmJiAhdGhpcy5leGFjdCA/IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5wYXRoLnJlcGxhY2UoL1xcLyQvLCAnJykucmVwbGFjZShxdWVyeVN0cmluZ1JFLCAnJykucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJykgKyAnKFxcXFwvfCQpJykgOiBudWxsO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlSHJlZjogZnVuY3Rpb24gdXBkYXRlSHJlZigpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwudGFnTmFtZSAhPT0gJ0EnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XG4gICAgICAgIHZhciBpc0Fic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgICAgICAgLy8gZG8gbm90IGZvcm1hdCBub24taGFzaCByZWxhdGl2ZSBwYXRoc1xuICAgICAgICB2YXIgaHJlZiA9IHBhdGggJiYgKHJvdXRlci5tb2RlID09PSAnaGFzaCcgfHwgaXNBYnNvbHV0ZSkgPyByb3V0ZXIuaGlzdG9yeS5mb3JtYXRQYXRoKHBhdGgsIHRoaXMuYXBwZW5kKSA6IHBhdGg7XG4gICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgdGhpcy5lbC5ocmVmID0gaHJlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGVDbGFzc2VzOiBmdW5jdGlvbiB1cGRhdGVDbGFzc2VzKHBhdGgsIGVsKSB7XG4gICAgICAgIHZhciBhY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3MgfHwgdGhpcy5yb3V0ZXIuX2xpbmtBY3RpdmVDbGFzcztcbiAgICAgICAgLy8gY2xlYXIgb2xkIGNsYXNzXG4gICAgICAgIGlmICh0aGlzLnByZXZBY3RpdmVDbGFzcyAmJiB0aGlzLnByZXZBY3RpdmVDbGFzcyAhPT0gYWN0aXZlQ2xhc3MpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzc2VzKGVsLCB0aGlzLnByZXZBY3RpdmVDbGFzcywgcmVtb3ZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBxdWVyeSBzdHJpbmcgYmVmb3JlIG1hdGNoaW5nXG4gICAgICAgIHZhciBkZXN0ID0gdGhpcy5wYXRoLnJlcGxhY2UocXVlcnlTdHJpbmdSRSwgJycpO1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKHF1ZXJ5U3RyaW5nUkUsICcnKTtcbiAgICAgICAgLy8gYWRkIG5ldyBjbGFzc1xuICAgICAgICBpZiAodGhpcy5leGFjdCkge1xuICAgICAgICAgIGlmIChkZXN0ID09PSBwYXRoIHx8XG4gICAgICAgICAgLy8gYWxzbyBhbGxvdyBhZGRpdGlvbmFsIHRyYWlsaW5nIHNsYXNoXG4gICAgICAgICAgZGVzdC5jaGFyQXQoZGVzdC5sZW5ndGggLSAxKSAhPT0gJy8nICYmIGRlc3QgPT09IHBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSkge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3NlcyhlbCwgYWN0aXZlQ2xhc3MsIGFkZENsYXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3NlcyhlbCwgYWN0aXZlQ2xhc3MsIHJlbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWN0aXZlUkUgJiYgdGhpcy5hY3RpdmVSRS50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzc2VzKGVsLCBhY3RpdmVDbGFzcywgYWRkQ2xhc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzc2VzKGVsLCBhY3RpdmVDbGFzcywgcmVtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZXIpO1xuICAgICAgICB0aGlzLnVud2F0Y2ggJiYgdGhpcy51bndhdGNoKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzYW1lT3JpZ2luKGxpbmspIHtcbiAgICAgIHJldHVybiBsaW5rLnByb3RvY29sID09PSBsb2NhdGlvbi5wcm90b2NvbCAmJiBsaW5rLmhvc3RuYW1lID09PSBsb2NhdGlvbi5ob3N0bmFtZSAmJiBsaW5rLnBvcnQgPT09IGxvY2F0aW9uLnBvcnQ7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBmdW5jdGlvbiBpcyBjb3BpZWQgZnJvbSB2LWJpbmQ6Y2xhc3MgaW1wbGVtZW50YXRpb24gdW50aWxcbiAgICAvLyB3ZSBwcm9wZXJseSBleHBvc2UgaXQuLi5cbiAgICBmdW5jdGlvbiB0b2dnbGVDbGFzc2VzKGVsLCBrZXksIGZuKSB7XG4gICAgICBrZXkgPSBrZXkudHJpbSgpO1xuICAgICAgaWYgKGtleS5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgICAgIGZuKGVsLCBrZXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgvXFxzKy8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBmbihlbCwga2V5c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGhpc3RvcnlCYWNrZW5kcyA9IHtcbiAgICBhYnN0cmFjdDogQWJzdHJhY3RIaXN0b3J5LFxuICAgIGhhc2g6IEhhc2hIaXN0b3J5LFxuICAgIGh0bWw1OiBIVE1MNUhpc3RvcnlcbiAgfTtcblxuICAvLyBsYXRlIGJpbmQgZHVyaW5nIGluc3RhbGxcbiAgdmFyIFZ1ZSA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogUm91dGVyIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG5cbiAgdmFyIFJvdXRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm91dGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgdmFyIF9yZWYkaGFzaGJhbmcgPSBfcmVmLmhhc2hiYW5nO1xuICAgICAgdmFyIGhhc2hiYW5nID0gX3JlZiRoYXNoYmFuZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkaGFzaGJhbmc7XG4gICAgICB2YXIgX3JlZiRhYnN0cmFjdCA9IF9yZWYuYWJzdHJhY3Q7XG4gICAgICB2YXIgYWJzdHJhY3QgPSBfcmVmJGFic3RyYWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkYWJzdHJhY3Q7XG4gICAgICB2YXIgX3JlZiRoaXN0b3J5ID0gX3JlZi5oaXN0b3J5O1xuICAgICAgdmFyIGhpc3RvcnkgPSBfcmVmJGhpc3RvcnkgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRoaXN0b3J5O1xuICAgICAgdmFyIF9yZWYkc2F2ZVNjcm9sbFBvc2l0aW9uID0gX3JlZi5zYXZlU2Nyb2xsUG9zaXRpb247XG4gICAgICB2YXIgc2F2ZVNjcm9sbFBvc2l0aW9uID0gX3JlZiRzYXZlU2Nyb2xsUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRzYXZlU2Nyb2xsUG9zaXRpb247XG4gICAgICB2YXIgX3JlZiR0cmFuc2l0aW9uT25Mb2FkID0gX3JlZi50cmFuc2l0aW9uT25Mb2FkO1xuICAgICAgdmFyIHRyYW5zaXRpb25PbkxvYWQgPSBfcmVmJHRyYW5zaXRpb25PbkxvYWQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiR0cmFuc2l0aW9uT25Mb2FkO1xuICAgICAgdmFyIF9yZWYkc3VwcHJlc3NUcmFuc2l0aW9uRXJyb3IgPSBfcmVmLnN1cHByZXNzVHJhbnNpdGlvbkVycm9yO1xuICAgICAgdmFyIHN1cHByZXNzVHJhbnNpdGlvbkVycm9yID0gX3JlZiRzdXBwcmVzc1RyYW5zaXRpb25FcnJvciA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHN1cHByZXNzVHJhbnNpdGlvbkVycm9yO1xuICAgICAgdmFyIF9yZWYkcm9vdCA9IF9yZWYucm9vdDtcbiAgICAgIHZhciByb290ID0gX3JlZiRyb290ID09PSB1bmRlZmluZWQgPyBudWxsIDogX3JlZiRyb290O1xuICAgICAgdmFyIF9yZWYkbGlua0FjdGl2ZUNsYXNzID0gX3JlZi5saW5rQWN0aXZlQ2xhc3M7XG4gICAgICB2YXIgbGlua0FjdGl2ZUNsYXNzID0gX3JlZiRsaW5rQWN0aXZlQ2xhc3MgPT09IHVuZGVmaW5lZCA/ICd2LWxpbmstYWN0aXZlJyA6IF9yZWYkbGlua0FjdGl2ZUNsYXNzO1xuICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlcik7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFSb3V0ZXIuaW5zdGFsbGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGluc3RhbGwgdGhlIFJvdXRlciB3aXRoIFZ1ZS51c2UoKSBiZWZvcmUgJyArICdjcmVhdGluZyBhbiBpbnN0YW5jZS4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gVnVlIGluc3RhbmNlc1xuICAgICAgdGhpcy5hcHAgPSBudWxsO1xuICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgICAgLy8gcm91dGUgcmVjb2duaXplclxuICAgICAgdGhpcy5fcmVjb2duaXplciA9IG5ldyBSb3V0ZVJlY29nbml6ZXIoKTtcbiAgICAgIHRoaXMuX2d1YXJkUmVjb2duaXplciA9IG5ldyBSb3V0ZVJlY29nbml6ZXIoKTtcblxuICAgICAgLy8gc3RhdGVcbiAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3N0YXJ0Q2IgPSBudWxsO1xuICAgICAgdGhpcy5fY3VycmVudFJvdXRlID0ge307XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLl9wcmV2aW91c1RyYW5zaXRpb24gPSBudWxsO1xuICAgICAgdGhpcy5fbm90Rm91bmRIYW5kbGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX25vdEZvdW5kUmVkaXJlY3QgPSBudWxsO1xuICAgICAgdGhpcy5fYmVmb3JlRWFjaEhvb2tzID0gW107XG4gICAgICB0aGlzLl9hZnRlckVhY2hIb29rcyA9IFtdO1xuXG4gICAgICAvLyB0cmlnZ2VyIHRyYW5zaXRpb24gb24gaW5pdGlhbCByZW5kZXI/XG4gICAgICB0aGlzLl9yZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fdHJhbnNpdGlvbk9uTG9hZCA9IHRyYW5zaXRpb25PbkxvYWQ7XG5cbiAgICAgIC8vIGhpc3RvcnkgbW9kZVxuICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgICB0aGlzLl9hYnN0cmFjdCA9IGFic3RyYWN0O1xuICAgICAgdGhpcy5faGFzaGJhbmcgPSBoYXNoYmFuZztcblxuICAgICAgLy8gY2hlY2sgaWYgSFRNTDUgaGlzdG9yeSBpcyBhdmFpbGFibGVcbiAgICAgIHZhciBoYXNQdXNoU3RhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGU7XG4gICAgICB0aGlzLl9oaXN0b3J5ID0gaGlzdG9yeSAmJiBoYXNQdXNoU3RhdGU7XG4gICAgICB0aGlzLl9oaXN0b3J5RmFsbGJhY2sgPSBoaXN0b3J5ICYmICFoYXNQdXNoU3RhdGU7XG5cbiAgICAgIC8vIGNyZWF0ZSBoaXN0b3J5IG9iamVjdFxuICAgICAgdmFyIGluQnJvd3NlciA9IFZ1ZS51dGlsLmluQnJvd3NlcjtcbiAgICAgIHRoaXMubW9kZSA9ICFpbkJyb3dzZXIgfHwgdGhpcy5fYWJzdHJhY3QgPyAnYWJzdHJhY3QnIDogdGhpcy5faGlzdG9yeSA/ICdodG1sNScgOiAnaGFzaCc7XG5cbiAgICAgIHZhciBIaXN0b3J5ID0gaGlzdG9yeUJhY2tlbmRzW3RoaXMubW9kZV07XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeSh7XG4gICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgIGhhc2hiYW5nOiB0aGlzLl9oYXNoYmFuZyxcbiAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHBhdGgsIHN0YXRlLCBhbmNob3IpIHtcbiAgICAgICAgICBfdGhpcy5fbWF0Y2gocGF0aCwgc3RhdGUsIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBvdGhlciBvcHRpb25zXG4gICAgICB0aGlzLl9zYXZlU2Nyb2xsUG9zaXRpb24gPSBzYXZlU2Nyb2xsUG9zaXRpb247XG4gICAgICB0aGlzLl9saW5rQWN0aXZlQ2xhc3MgPSBsaW5rQWN0aXZlQ2xhc3M7XG4gICAgICB0aGlzLl9zdXBwcmVzcyA9IHN1cHByZXNzVHJhbnNpdGlvbkVycm9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbG93IGRpcmVjdGx5IHBhc3NpbmcgY29tcG9uZW50cyB0byBhIHJvdXRlXG4gICAgICogZGVmaW5pdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICAgKi9cblxuICAgIC8vIEFQSSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8qKlxuICAgICogUmVnaXN0ZXIgYSBtYXAgb2YgdG9wLWxldmVsIHBhdGhzLlxuICAgICpcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBcbiAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAoX21hcCkge1xuICAgICAgZm9yICh2YXIgcm91dGUgaW4gX21hcCkge1xuICAgICAgICB0aGlzLm9uKHJvdXRlLCBfbWFwW3JvdXRlXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBzaW5nbGUgcm9vdC1sZXZlbCBwYXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm9vdFBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICAgICAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGNvbXBvbmVudFxuICAgICAqICAgICAgICAgICAgICAgICAtIHtPYmplY3R9IFtzdWJSb3V0ZXNdXG4gICAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtmb3JjZVJlZnJlc2hdXG4gICAgICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbYmVmb3JlXVxuICAgICAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gW2FmdGVyXVxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKHJvb3RQYXRoLCBoYW5kbGVyKSB7XG4gICAgICBpZiAocm9vdFBhdGggPT09ICcqJykge1xuICAgICAgICB0aGlzLl9ub3RGb3VuZChoYW5kbGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2FkZFJvdXRlKHJvb3RQYXRoLCBoYW5kbGVyLCBbXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHJlZGlyZWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBcbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUucmVkaXJlY3QgPSBmdW5jdGlvbiByZWRpcmVjdChtYXApIHtcbiAgICAgIGZvciAodmFyIHBhdGggaW4gbWFwKSB7XG4gICAgICAgIHRoaXMuX2FkZFJlZGlyZWN0KHBhdGgsIG1hcFtwYXRoXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGFsaWFzZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24gYWxpYXMobWFwKSB7XG4gICAgICBmb3IgKHZhciBwYXRoIGluIG1hcCkge1xuICAgICAgICB0aGlzLl9hZGRBbGlhcyhwYXRoLCBtYXBbcGF0aF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBnbG9iYWwgYmVmb3JlIGhvb2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaChmbikge1xuICAgICAgdGhpcy5fYmVmb3JlRWFjaEhvb2tzLnB1c2goZm4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBnbG9iYWwgYWZ0ZXIgaG9vay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uIGFmdGVyRWFjaChmbikge1xuICAgICAgdGhpcy5fYWZ0ZXJFYWNoSG9va3MucHVzaChmbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTmF2aWdhdGUgdG8gYSBnaXZlbiBwYXRoLlxuICAgICAqIFRoZSBwYXRoIGNhbiBiZSBhbiBvYmplY3QgZGVzY3JpYmluZyBhIG5hbWVkIHBhdGggaW5cbiAgICAgKiB0aGUgZm9ybWF0IG9mIHsgbmFtZTogJy4uLicsIHBhcmFtczoge30sIHF1ZXJ5OiB7fX1cbiAgICAgKiBUaGUgcGF0aCBpcyBhc3N1bWVkIHRvIGJlIGFscmVhZHkgZGVjb2RlZCwgYW5kIHdpbGxcbiAgICAgKiBiZSByZXNvbHZlZCBhZ2FpbnN0IHJvb3QgKGlmIHByb3ZpZGVkKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwYXRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVwbGFjZV1cbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyhwYXRoKSB7XG4gICAgICB2YXIgcmVwbGFjZSA9IGZhbHNlO1xuICAgICAgdmFyIGFwcGVuZCA9IGZhbHNlO1xuICAgICAgaWYgKFZ1ZS51dGlsLmlzT2JqZWN0KHBhdGgpKSB7XG4gICAgICAgIHJlcGxhY2UgPSBwYXRoLnJlcGxhY2U7XG4gICAgICAgIGFwcGVuZCA9IHBhdGguYXBwZW5kO1xuICAgICAgfVxuICAgICAgcGF0aCA9IHRoaXMuc3RyaW5naWZ5UGF0aChwYXRoKTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeS5nbyhwYXRoLCByZXBsYWNlLCBhcHBlbmQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG9ydCBoYW5kIGZvciByZXBsYWNpbmcgY3VycmVudCBwYXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggPSB7IHBhdGg6IHBhdGggfTtcbiAgICAgIH1cbiAgICAgIHBhdGgucmVwbGFjZSA9IHRydWU7XG4gICAgICB0aGlzLmdvKHBhdGgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgcm91dGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtWdWVDb25zdHJ1Y3Rvcn0gQXBwXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KEFwcCwgY29udGFpbmVyLCBjYikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5fc3RhcnRlZCkge1xuICAgICAgICB3YXJuJDEoJ2FscmVhZHkgc3RhcnRlZC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLl9zdGFydENiID0gY2I7XG4gICAgICBpZiAoIXRoaXMuYXBwKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIUFwcCB8fCAhY29udGFpbmVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHN0YXJ0IHZ1ZS1yb3V0ZXIgd2l0aCBhIGNvbXBvbmVudCBhbmQgYSAnICsgJ3Jvb3QgY29udGFpbmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoQXBwIGluc3RhbmNlb2YgVnVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHN0YXJ0IHZ1ZS1yb3V0ZXIgd2l0aCBhIGNvbXBvbmVudCwgbm90IGEgJyArICdWdWUgaW5zdGFuY2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXBwQ29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB2YXIgQ3RvciA9IHRoaXMuX2FwcENvbnN0cnVjdG9yID0gdHlwZW9mIEFwcCA9PT0gJ2Z1bmN0aW9uJyA/IEFwcCA6IFZ1ZS5leHRlbmQoQXBwKTtcbiAgICAgICAgLy8gZ2l2ZSBpdCBhIG5hbWUgZm9yIGJldHRlciBkZWJ1Z2dpbmdcbiAgICAgICAgQ3Rvci5vcHRpb25zLm5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCAnUm91dGVyQXBwJztcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIGhpc3RvcnkgZmFsbGJhY2sgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3RcbiAgICAgIC8vIHN1cHBvcnQgSFRNTDUgaGlzdG9yeSBBUElcbiAgICAgIGlmICh0aGlzLl9oaXN0b3J5RmFsbGJhY2spIHtcbiAgICAgICAgdmFyIF9sb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgdmFyIF9oaXN0b3J5ID0gbmV3IEhUTUw1SGlzdG9yeSh7IHJvb3Q6IHRoaXMuX3Jvb3QgfSk7XG4gICAgICAgIHZhciBwYXRoID0gX2hpc3Rvcnkucm9vdCA/IF9sb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKF9oaXN0b3J5LnJvb3RSRSwgJycpIDogX2xvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICBpZiAocGF0aCAmJiBwYXRoICE9PSAnLycpIHtcbiAgICAgICAgICBfbG9jYXRpb24uYXNzaWduKChfaGlzdG9yeS5yb290IHx8ICcnKSArICcvJyArIHRoaXMuaGlzdG9yeS5mb3JtYXRQYXRoKHBhdGgpICsgX2xvY2F0aW9uLnNlYXJjaCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGlzdG9yeS5zdGFydCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGxpc3RlbmluZyB0byByb3V0ZSBjaGFuZ2VzLlxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuaGlzdG9yeS5zdG9wKCk7XG4gICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBuYW1lZCByb3V0ZSBvYmplY3QgLyBzdHJpbmcgcGF0aHMgaW50b1xuICAgICAqIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfE51bWJlcn0gcGF0aFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuc3RyaW5naWZ5UGF0aCA9IGZ1bmN0aW9uIHN0cmluZ2lmeVBhdGgocGF0aCkge1xuICAgICAgdmFyIGdlbmVyYXRlZFBhdGggPSAnJztcbiAgICAgIGlmIChwYXRoICYmIHR5cGVvZiBwYXRoID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocGF0aC5uYW1lKSB7XG4gICAgICAgICAgdmFyIGV4dGVuZCA9IFZ1ZS51dGlsLmV4dGVuZDtcbiAgICAgICAgICB2YXIgY3VycmVudFBhcmFtcyA9IHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uICYmIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uLnRvLnBhcmFtcztcbiAgICAgICAgICB2YXIgdGFyZ2V0UGFyYW1zID0gcGF0aC5wYXJhbXMgfHwge307XG4gICAgICAgICAgdmFyIHBhcmFtcyA9IGN1cnJlbnRQYXJhbXMgPyBleHRlbmQoZXh0ZW5kKHt9LCBjdXJyZW50UGFyYW1zKSwgdGFyZ2V0UGFyYW1zKSA6IHRhcmdldFBhcmFtcztcbiAgICAgICAgICBnZW5lcmF0ZWRQYXRoID0gZW5jb2RlVVJJKHRoaXMuX3JlY29nbml6ZXIuZ2VuZXJhdGUocGF0aC5uYW1lLCBwYXJhbXMpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXRoLnBhdGgpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRQYXRoID0gZW5jb2RlVVJJKHBhdGgucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgucXVlcnkpIHtcbiAgICAgICAgICAvLyBub3RlOiB0aGUgZ2VuZXJhdGVkIHF1ZXJ5IHN0cmluZyBpcyBwcmUtVVJMLWVuY29kZWQgYnkgdGhlIHJlY29nbml6ZXJcbiAgICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLl9yZWNvZ25pemVyLmdlbmVyYXRlUXVlcnlTdHJpbmcocGF0aC5xdWVyeSk7XG4gICAgICAgICAgaWYgKGdlbmVyYXRlZFBhdGguaW5kZXhPZignPycpID4gLTEpIHtcbiAgICAgICAgICAgIGdlbmVyYXRlZFBhdGggKz0gJyYnICsgcXVlcnkuc2xpY2UoMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdlbmVyYXRlZFBhdGggKz0gcXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWRQYXRoID0gZW5jb2RlVVJJKHBhdGggPyBwYXRoICsgJycgOiAnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2VuZXJhdGVkUGF0aDtcbiAgICB9O1xuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLyoqXG4gICAgKiBBZGQgYSByb3V0ZSBjb250YWluaW5nIGEgbGlzdCBvZiBzZWdtZW50cyB0byB0aGUgaW50ZXJuYWxcbiAgICAqIHJvdXRlIHJlY29nbml6ZXIuIFdpbGwgYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5IHRvIGFkZCBhbGxcbiAgICAqIHBvc3NpYmxlIHN1Yi1yb3V0ZXMuXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAgKiBAcGFyYW0ge0FycmF5fSBzZWdtZW50c1xuICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLl9hZGRSb3V0ZSA9IGZ1bmN0aW9uIF9hZGRSb3V0ZShwYXRoLCBoYW5kbGVyLCBzZWdtZW50cykge1xuICAgICAgZ3VhcmRDb21wb25lbnQocGF0aCwgaGFuZGxlcik7XG4gICAgICBoYW5kbGVyLnBhdGggPSBwYXRoO1xuICAgICAgaGFuZGxlci5mdWxsUGF0aCA9IChzZWdtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHBhdGgsIHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhdGggKyBzZWdtZW50LnBhdGg7XG4gICAgICB9LCAnJykgKyBwYXRoKS5yZXBsYWNlKCcvLycsICcvJyk7XG4gICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgfSk7XG4gICAgICB0aGlzLl9yZWNvZ25pemVyLmFkZChzZWdtZW50cywge1xuICAgICAgICBhczogaGFuZGxlci5uYW1lXG4gICAgICB9KTtcbiAgICAgIC8vIGFkZCBzdWIgcm91dGVzXG4gICAgICBpZiAoaGFuZGxlci5zdWJSb3V0ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgc3ViUGF0aCBpbiBoYW5kbGVyLnN1YlJvdXRlcykge1xuICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHdhbGsgYWxsIHN1YiByb3V0ZXNcbiAgICAgICAgICB0aGlzLl9hZGRSb3V0ZShzdWJQYXRoLCBoYW5kbGVyLnN1YlJvdXRlc1tzdWJQYXRoXSxcbiAgICAgICAgICAvLyBwYXNzIGEgY29weSBpbiByZWN1cnNpb24gdG8gYXZvaWQgbXV0YXRpbmdcbiAgICAgICAgICAvLyBhY3Jvc3MgYnJhbmNoZXNcbiAgICAgICAgICBzZWdtZW50cy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG5vdEZvdW5kIHJvdXRlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5fbm90Rm91bmQgPSBmdW5jdGlvbiBfbm90Rm91bmQoaGFuZGxlcikge1xuICAgICAgZ3VhcmRDb21wb25lbnQoJyonLCBoYW5kbGVyKTtcbiAgICAgIHRoaXMuX25vdEZvdW5kSGFuZGxlciA9IFt7IGhhbmRsZXI6IGhhbmRsZXIgfV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHJlZGlyZWN0IHJlY29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlZGlyZWN0UGF0aFxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5fYWRkUmVkaXJlY3QgPSBmdW5jdGlvbiBfYWRkUmVkaXJlY3QocGF0aCwgcmVkaXJlY3RQYXRoKSB7XG4gICAgICBpZiAocGF0aCA9PT0gJyonKSB7XG4gICAgICAgIHRoaXMuX25vdEZvdW5kUmVkaXJlY3QgPSByZWRpcmVjdFBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hZGRHdWFyZChwYXRoLCByZWRpcmVjdFBhdGgsIHRoaXMucmVwbGFjZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBhbGlhcyByZWNvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhc1BhdGhcbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuX2FkZEFsaWFzID0gZnVuY3Rpb24gX2FkZEFsaWFzKHBhdGgsIGFsaWFzUGF0aCkge1xuICAgICAgdGhpcy5fYWRkR3VhcmQocGF0aCwgYWxpYXNQYXRoLCB0aGlzLl9tYXRjaCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHBhdGggZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtYXBwZWRQYXRoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5fYWRkR3VhcmQgPSBmdW5jdGlvbiBfYWRkR3VhcmQocGF0aCwgbWFwcGVkUGF0aCwgX2hhbmRsZXIpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9ndWFyZFJlY29nbml6ZXIuYWRkKFt7XG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIobWF0Y2gsIHF1ZXJ5KSB7XG4gICAgICAgICAgdmFyIHJlYWxQYXRoID0gbWFwUGFyYW1zKG1hcHBlZFBhdGgsIG1hdGNoLnBhcmFtcywgcXVlcnkpO1xuICAgICAgICAgIF9oYW5kbGVyLmNhbGwoX3RoaXMyLCByZWFsUGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBwYXRoIG1hdGNoZXMgYW55IHJlZGlyZWN0IHJlY29yZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gaWYgdHJ1ZSwgd2lsbCBza2lwIG5vcm1hbCBtYXRjaC5cbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuX2NoZWNrR3VhcmQgPSBmdW5jdGlvbiBfY2hlY2tHdWFyZChwYXRoKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IHRoaXMuX2d1YXJkUmVjb2duaXplci5yZWNvZ25pemUocGF0aCwgdHJ1ZSk7XG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICBtYXRjaGVkWzBdLmhhbmRsZXIobWF0Y2hlZFswXSwgbWF0Y2hlZC5xdWVyeVBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ub3RGb3VuZFJlZGlyZWN0KSB7XG4gICAgICAgIG1hdGNoZWQgPSB0aGlzLl9yZWNvZ25pemVyLnJlY29nbml6ZShwYXRoKTtcbiAgICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgICAgdGhpcy5yZXBsYWNlKHRoaXMuX25vdEZvdW5kUmVkaXJlY3QpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1hdGNoIGEgVVJMIHBhdGggYW5kIHNldCB0aGUgcm91dGUgY29udGV4dCBvbiB2bSxcbiAgICAgKiB0cmlnZ2VyaW5nIHZpZXcgdXBkYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGF0ZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2FuY2hvcl1cbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuX21hdGNoID0gZnVuY3Rpb24gX21hdGNoKHBhdGgsIHN0YXRlLCBhbmNob3IpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fY2hlY2tHdWFyZChwYXRoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50Um91dGUgPSB0aGlzLl9jdXJyZW50Um91dGU7XG4gICAgICB2YXIgY3VycmVudFRyYW5zaXRpb24gPSB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbjtcblxuICAgICAgaWYgKGN1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICAgIGlmIChjdXJyZW50VHJhbnNpdGlvbi50by5wYXRoID09PSBwYXRoKSB7XG4gICAgICAgICAgLy8gZG8gbm90aGluZyBpZiB3ZSBoYXZlIGFuIGFjdGl2ZSB0cmFuc2l0aW9uIGdvaW5nIHRvIHRoZSBzYW1lIHBhdGhcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJvdXRlLnBhdGggPT09IHBhdGgpIHtcbiAgICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gdGhlIHNhbWUgcGF0aCwgYnV0IHdlIGFsc28gaGF2ZSBhbiBvbmdvaW5nIGJ1dFxuICAgICAgICAgIC8vIG5vdC15ZXQtdmFsaWRhdGVkIHRyYW5zaXRpb24uIEFib3J0IHRoYXQgdHJhbnNpdGlvbiBhbmQgcmVzZXQgdG9cbiAgICAgICAgICAvLyBwcmV2IHRyYW5zaXRpb24uXG4gICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRyYW5zaXRpb24gPSB0aGlzLl9wcmV2VHJhbnNpdGlvbjtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ29pbmcgdG8gYSB0b3RhbGx5IGRpZmZlcmVudCBwYXRoLiBhYm9ydCBvbmdvaW5nIHRyYW5zaXRpb24uXG4gICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY29uc3RydWN0IG5ldyByb3V0ZSBhbmQgdHJhbnNpdGlvbiBjb250ZXh0XG4gICAgICB2YXIgcm91dGUgPSBuZXcgUm91dGUocGF0aCwgdGhpcyk7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IG5ldyBSb3V0ZVRyYW5zaXRpb24odGhpcywgcm91dGUsIGN1cnJlbnRSb3V0ZSk7XG5cbiAgICAgIC8vIGN1cnJlbnQgdHJhbnNpdGlvbiBpcyB1cGRhdGVkIHJpZ2h0IG5vdy5cbiAgICAgIC8vIGhvd2V2ZXIsIGN1cnJlbnQgcm91dGUgd2lsbCBvbmx5IGJlIHVwZGF0ZWQgYWZ0ZXIgdGhlIHRyYW5zaXRpb24gaGFzXG4gICAgICAvLyBiZWVuIHZhbGlkYXRlZC5cbiAgICAgIHRoaXMuX3ByZXZUcmFuc2l0aW9uID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG5cbiAgICAgIGlmICghdGhpcy5hcHApIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgICAgIHZhciByb3V0ZXIgPSBfdGhpczM7XG4gICAgICAgICAgX3RoaXMzLmFwcCA9IG5ldyBfdGhpczMuX2FwcENvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGVsOiBfdGhpczMuX2FwcENvbnRhaW5lcixcbiAgICAgICAgICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICAgICAgICAgIHRoaXMuJHJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWV0YToge1xuICAgICAgICAgICAgICAkcm91dGU6IHJvdXRlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGdsb2JhbCBiZWZvcmUgaG9va1xuICAgICAgdmFyIGJlZm9yZUhvb2tzID0gdGhpcy5fYmVmb3JlRWFjaEhvb2tzO1xuICAgICAgdmFyIHN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbigpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5zdGFydChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLl9wb3N0VHJhbnNpdGlvbihyb3V0ZSwgc3RhdGUsIGFuY2hvcik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgaWYgKGJlZm9yZUhvb2tzLmxlbmd0aCkge1xuICAgICAgICB0cmFuc2l0aW9uLnJ1blF1ZXVlKGJlZm9yZUhvb2tzLCBmdW5jdGlvbiAoaG9vaywgXywgbmV4dCkge1xuICAgICAgICAgIGlmICh0cmFuc2l0aW9uID09PSBfdGhpczMuX2N1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLmNhbGxIb29rKGhvb2ssIG51bGwsIG5leHQsIHtcbiAgICAgICAgICAgICAgZXhwZWN0Qm9vbGVhbjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBzdGFydFRyYW5zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fcmVuZGVyZWQgJiYgdGhpcy5fc3RhcnRDYikge1xuICAgICAgICB0aGlzLl9zdGFydENiLmNhbGwobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhBQ0s6XG4gICAgICAvLyBzZXQgcmVuZGVyZWQgdG8gdHJ1ZSBhZnRlciB0aGUgdHJhbnNpdGlvbiBzdGFydCwgc29cbiAgICAgIC8vIHRoYXQgY29tcG9uZW50cyB0aGF0IGFyZSBhY2l0dmF0ZWQgc3luY2hyb25vdXNseSBrbm93XG4gICAgICAvLyB3aGV0aGVyIGl0IGlzIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgIHRoaXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGN1cnJlbnQgdG8gdGhlIG5ldyB0cmFuc2l0aW9uLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSB0cmFuc2l0aW9uIG9iamVjdCB3aGVuIHRoZVxuICAgICAqIHZhbGlkYXRpb24gb2YgYSByb3V0ZSBoYXMgc3VjY2VlZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLl9vblRyYW5zaXRpb25WYWxpZGF0ZWQgPSBmdW5jdGlvbiBfb25UcmFuc2l0aW9uVmFsaWRhdGVkKHRyYW5zaXRpb24pIHtcbiAgICAgIC8vIHNldCBjdXJyZW50IHJvdXRlXG4gICAgICB2YXIgcm91dGUgPSB0aGlzLl9jdXJyZW50Um91dGUgPSB0cmFuc2l0aW9uLnRvO1xuICAgICAgLy8gdXBkYXRlIHJvdXRlIGNvbnRleHQgZm9yIGFsbCBjaGlsZHJlblxuICAgICAgaWYgKHRoaXMuYXBwLiRyb3V0ZSAhPT0gcm91dGUpIHtcbiAgICAgICAgdGhpcy5hcHAuJHJvdXRlID0gcm91dGU7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgY2hpbGQuJHJvdXRlID0gcm91dGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gY2FsbCBnbG9iYWwgYWZ0ZXIgaG9va1xuICAgICAgaWYgKHRoaXMuX2FmdGVyRWFjaEhvb2tzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9hZnRlckVhY2hIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgICAgcmV0dXJuIGhvb2suY2FsbChudWxsLCB7XG4gICAgICAgICAgICB0bzogdHJhbnNpdGlvbi50byxcbiAgICAgICAgICAgIGZyb206IHRyYW5zaXRpb24uZnJvbVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uLmRvbmUgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgc3R1ZmYgYWZ0ZXIgdGhlIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JvdXRlfSByb3V0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhdGVdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFthbmNob3JdXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLl9wb3N0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIF9wb3N0VHJhbnNpdGlvbihyb3V0ZSwgc3RhdGUsIGFuY2hvcikge1xuICAgICAgLy8gaGFuZGxlIHNjcm9sbCBwb3NpdGlvbnNcbiAgICAgIC8vIHNhdmVkIHNjcm9sbCBwb3NpdGlvbnMgdGFrZSBwcmlvcml0eVxuICAgICAgLy8gdGhlbiB3ZSBjaGVjayBpZiB0aGUgcGF0aCBoYXMgYW4gYW5jaG9yXG4gICAgICB2YXIgcG9zID0gc3RhdGUgJiYgc3RhdGUucG9zO1xuICAgICAgaWYgKHBvcyAmJiB0aGlzLl9zYXZlU2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgVnVlLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8ocG9zLngsIHBvcy55KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGFuY2hvcikge1xuICAgICAgICBWdWUubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFuY2hvci5zbGljZSgxKSk7XG4gICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8od2luZG93LnNjcm9sbFgsIGVsLm9mZnNldFRvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFJvdXRlcjtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBndWFyZENvbXBvbmVudChwYXRoLCBoYW5kbGVyKSB7XG4gICAgdmFyIGNvbXAgPSBoYW5kbGVyLmNvbXBvbmVudDtcbiAgICBpZiAoVnVlLnV0aWwuaXNQbGFpbk9iamVjdChjb21wKSkge1xuICAgICAgY29tcCA9IGhhbmRsZXIuY29tcG9uZW50ID0gVnVlLmV4dGVuZChjb21wKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiBjb21wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBoYW5kbGVyLmNvbXBvbmVudCA9IG51bGw7XG4gICAgICB3YXJuJDEoJ2ludmFsaWQgY29tcG9uZW50IGZvciByb3V0ZSBcIicgKyBwYXRoICsgJ1wiLicpO1xuICAgIH1cbiAgfVxuXG4gIC8qIEluc3RhbGxhdGlvbiAqL1xuXG4gIFJvdXRlci5pbnN0YWxsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogSW5zdGFsbGF0aW9uIGludGVyZmFjZS5cbiAgICogSW5zdGFsbCB0aGUgbmVjZXNzYXJ5IGRpcmVjdGl2ZXMuXG4gICAqL1xuXG4gIFJvdXRlci5pbnN0YWxsID0gZnVuY3Rpb24gKGV4dGVybmFsVnVlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKFJvdXRlci5pbnN0YWxsZWQpIHtcbiAgICAgIHdhcm4kMSgnYWxyZWFkeSBpbnN0YWxsZWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFZ1ZSA9IGV4dGVybmFsVnVlO1xuICAgIGFwcGx5T3ZlcnJpZGUoVnVlKTtcbiAgICBWaWV3KFZ1ZSk7XG4gICAgTGluayhWdWUpO1xuICAgIGV4cG9ydHMkMS5WdWUgPSBWdWU7XG4gICAgUm91dGVyLmluc3RhbGxlZCA9IHRydWU7XG4gIH07XG5cbiAgLy8gYXV0byBpbnN0YWxsXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICAgIHdpbmRvdy5WdWUudXNlKFJvdXRlcik7XG4gIH1cblxuICByZXR1cm4gUm91dGVyO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_script__, __vue_template__\n__webpack_require__(4)\n__vue_script__ = __webpack_require__(5)\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] app/src/components/app.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = __webpack_require__(46)\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (false) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"_v-9fe25812/app.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvYXBwLnZ1ZT9kOGRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EscUJBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBLFlBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJyZW1vdmVcXFwiOnRydWV9IWNzcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyFsZXNzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2FwcC52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9hcHAudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIGFwcC9zcmMvY29tcG9uZW50cy9hcHAudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vYXBwLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTlmZTI1ODEyL2FwcC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hcHAvc3JjL2NvbXBvbmVudHMvYXBwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvYXBwLnZ1ZT81MjJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi9sZXNzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYXBwL3NyYy9jb21wb25lbnRzL2FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _vue = __webpack_require__(1);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _sidemenu = __webpack_require__(6);\n\nvar _sidemenu2 = _interopRequireDefault(_sidemenu);\n\nvar _store = __webpack_require__(20);\n\nvar _store2 = _interopRequireDefault(_store);\n\nvar _user = __webpack_require__(45);\n\nvar userActions = _interopRequireWildcard(_user);\n\nvar _getter = __webpack_require__(18);\n\nvar getters = _interopRequireWildcard(_getter);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// 创建 modal 组件\n_vue2.default.component('modal', {\n  template: \"#modal-template\",\n  props: ['show']\n}); // <template>\n//   <div>\n//     <router-view></router-view>\n//   <script type=\"x-template\" id=\"modal-template\">\n//     <div class=\"modal-mask\" v-if=\"show\" transition=\"modal-animation_default\">\n//       <div class=\"modal-wrapper\">\n//         <div class=\"modal-container\">\n//           <slot name=\"content\"></slot>\n//         </div>\n//       </div>\n//     </div>\n//   </script>\n// </div>\n// </template>\n//\n// <script>\nexports.default = {\n  vuex: {\n    actions: {\n      authenticate: userActions.authenticate\n    },\n    getters: {\n      user: getters.getUserInfo\n    }\n  },\n  data: function data() {\n    return {\n      msg: 'Hello from BlueRobin'\n    };\n  },\n\n  computed: {},\n  created: function created() {\n    var _this = this;\n\n    this.authenticate(function (user) {\n      if (user) {\n        _this.$router.go('/lists');\n      } else {\n        console.log('login first, please!');\n        _this.$router.go('/login');\n      }\n    });\n  },\n  ready: function ready() {},\n\n  methods: {},\n  components: {\n    sidemenu: _sidemenu2.default\n  },\n  store: _store2.default\n};\n// </script>\n//\n// <style lang=\"less\">\n//   #app{\n//     height: 100%;\n//     min-height: 100%;\n//   }\n//   .page-content{\n//     // display: flex;\n//     padding-top: 80px;\n//     padding-bottom: 50px;\n//     min-height: 100%;\n//     height: 100%;\n//     box-sizing: border-box;\n//   }\n//   // .app{\n//   //   height: 100%;\n//   //   position: absolute;\n//   //   left: 0;\n//   //   right: 0;\n//   //   bottom: 0;\n//   //   top: 0;\n//   // }\n//   .animate_routerview-transition{\n//     transition: all 0.4s ease;\n//   }\n//   .animate_routerview-enter, .animate_routerview-leave{\n//     opacity: 0;\n//     height:0;\n//     transform: translate3d(20px, 0, 0);\n//   }\n//\n// </style>\n\n/* generated by vue-loader *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYXBwLnZ1ZT84MzcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQWdCQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7QUFHQTtZQUVBO1NBQ0EsQ0FJQTtBQU5BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDQVdBO0FBRkE7O29CQU1BO0FBSEE7QUFKQTt3QkFRQTs7V0FHQTtBQUZBO0FBR0E7O1lBR0E7O0FBQ0E7O3NDQUNBO2dCQUNBO3lCQUNBO2FBQ0E7b0JBQ0E7eUJBQ0E7QUFDQTtBQUNBO0FBQ0E7MEJBQ0EsQ0FDQTs7V0FFQTs7QUFHQTtBQUZBO0FBR0E7QUFsQ0EiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8cm91dGVyLXZpZXc+PC9yb3V0ZXItdmlldz5cbiAgPHNjcmlwdCB0eXBlPVwieC10ZW1wbGF0ZVwiIGlkPVwibW9kYWwtdGVtcGxhdGVcIj5cbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtbWFza1wiIHYtaWY9XCJzaG93XCIgdHJhbnNpdGlvbj1cIm1vZGFsLWFuaW1hdGlvbl9kZWZhdWx0XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtd3JhcHBlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtY29udGFpbmVyXCI+XG4gICAgICAgICAgPHNsb3QgbmFtZT1cImNvbnRlbnRcIj48L3Nsb3Q+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvc2NyaXB0PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG4gIGltcG9ydCBTaWRlTWVudVZpZXcgZnJvbSAnLi90YXNrL3NpZGVtZW51LnZ1ZSc7XG4gIGltcG9ydCBzdG9yZSBmcm9tICcuLi92dWV4L3N0b3JlJztcblxuICBpbXBvcnQgKiBhcyB1c2VyQWN0aW9ucyBmcm9tICcuLi92dWV4L2FjdGlvbnMvdXNlcic7XG4gIGltcG9ydCAqIGFzIGdldHRlcnMgZnJvbSAnLi4vdnVleC9nZXR0ZXInO1xuXG4gIC8vIOWIm+W7uiBtb2RhbCDnu4Tku7ZcbiAgVnVlLmNvbXBvbmVudCgnbW9kYWwnLCB7XG4gICAgdGVtcGxhdGU6IFwiI21vZGFsLXRlbXBsYXRlXCIsXG4gICAgcHJvcHM6IFtcbiAgICAgICdzaG93JyxcbiAgICBdLFxuICB9KTtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgdnVleDoge1xuICAgICAgYWN0aW9uczoge1xuICAgICAgICBhdXRoZW50aWNhdGU6IHVzZXJBY3Rpb25zLmF1dGhlbnRpY2F0ZSxcbiAgICAgIH0sXG4gICAgICBnZXR0ZXJzOiB7XG4gICAgICAgIHVzZXI6IGdldHRlcnMuZ2V0VXNlckluZm8sXG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbXNnOiAnSGVsbG8gZnJvbSBCbHVlUm9iaW4nLFxuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICB9LFxuICAgIGNyZWF0ZWQoKSB7XG4gICAgICB0aGlzLmF1dGhlbnRpY2F0ZSgodXNlcikgPT4ge1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgIHRoaXMuJHJvdXRlci5nbygnL2xpc3RzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2xvZ2luIGZpcnN0LCBwbGVhc2UhJyk7XG4gICAgICAgICAgdGhpcy4kcm91dGVyLmdvKCcvbG9naW4nKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICByZWFkeSgpIHtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICB9LFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIHNpZGVtZW51OiBTaWRlTWVudVZpZXcsXG4gICAgfSxcbiAgICBzdG9yZTogc3RvcmUsXG4gIH07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG4gICNhcHB7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIG1pbi1oZWlnaHQ6IDEwMCU7XG4gIH1cbiAgLnBhZ2UtY29udGVudHtcbiAgICAvLyBkaXNwbGF5OiBmbGV4O1xuICAgIHBhZGRpbmctdG9wOiA4MHB4O1xuICAgIHBhZGRpbmctYm90dG9tOiA1MHB4O1xuICAgIG1pbi1oZWlnaHQ6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cbiAgLy8gLmFwcHtcbiAgLy8gICBoZWlnaHQ6IDEwMCU7XG4gIC8vICAgcG9zaXRpb246IGFic29sdXRlO1xuICAvLyAgIGxlZnQ6IDA7XG4gIC8vICAgcmlnaHQ6IDA7XG4gIC8vICAgYm90dG9tOiAwO1xuICAvLyAgIHRvcDogMDtcbiAgLy8gfVxuICAuYW5pbWF0ZV9yb3V0ZXJ2aWV3LXRyYW5zaXRpb257XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuNHMgZWFzZTtcbiAgfVxuICAuYW5pbWF0ZV9yb3V0ZXJ2aWV3LWVudGVyLCAuYW5pbWF0ZV9yb3V0ZXJ2aWV3LWxlYXZle1xuICAgIG9wYWNpdHk6IDA7XG4gICAgaGVpZ2h0OjA7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgyMHB4LCAwLCAwKTtcbiAgfVxuXG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogYXBwLnZ1ZT81ZGNkOTNjZFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_script__, __vue_template__\n__webpack_require__(7)\n__vue_script__ = __webpack_require__(8)\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] app/src/components/task/sidemenu.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = __webpack_require__(19)\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (false) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"_v-2880fd56/sidemenu.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay9zaWRlbWVudS52dWU/YzNjYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHFCQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQSxZQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhbGVzcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zaWRlbWVudS52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9zaWRlbWVudS52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gYXBwL3NyYy9jb21wb25lbnRzL3Rhc2svc2lkZW1lbnUudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc2lkZW1lbnUudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtMjg4MGZkNTYvc2lkZW1lbnUudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3NyYy9jb21wb25lbnRzL3Rhc2svc2lkZW1lbnUudnVlXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay9zaWRlbWVudS52dWU/Nzg3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vbGVzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2FwcC9zcmMvY29tcG9uZW50cy90YXNrL3NpZGVtZW51LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lists = __webpack_require__(9);\n\nvar listsActions = _interopRequireWildcard(_lists);\n\nvar _getter = __webpack_require__(18);\n\nvar getters = _interopRequireWildcard(_getter);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// <template>\n//   <div class=\"sidebar\">\n//     <ul class=\"side-menu\">\n//       <li v-for=\"list in lists\">\n//         <a class=\"side-menu__item\" v-link=\"{name: 'list', params: {id: list.id}}\">\n//           <span class=\"material-icons\">list</span>\n//           <span class=\"side-menu__item-content\">{{list.name}}</span>\n//           <span class=\"side-menu__item-count\">{{list.task_count_total - list.task_count_completed || ''}}</span>\n//           <span class=\"material-icons edit\" @click=\"showCurrent(e, list)\">edit</span>\n//         </a>\n//       </li>\n//     </ul>\n//     <div class=\"side-actions\">\n//       <span class=\"side-menu__item\" @click=\"showModal = true\">\n//         <span class=\"material-icons\">add</span>\n//         <span class=\"side-menu__item-content\">新建分类</span>\n//       </span>\n//     </div>\n//\n//   </div>\n//   <modal :show=\"showModal\">\n//     <div slot=\"content\" class=\"list-editor\">\n//       <div class=\"list-editor-header\">\n//         <h3 class=\"list-editor-header--title\">创建新的清单</h3>\n//       </div>\n//       <div class=\"list-editor-body\">\n//         <div class=\"robin-textfield\">\n//           <input type=\"text\" class=\"robin-textfield--input robin-textfield--input_default\" v-model=\"newList.name\"/>\n//         </div>\n//       </div>\n//       <div class=\"list-editor-footer\">\n//         <span></span>\n//         <button class=\"robin-btn robin-btn__default\" @click=\"createNewList\">创建</button>\n//       </div>\n//     </div>\n//   </modal>\n//   <modal :show=\"showCurrentList\">\n//     <div slot=\"content\" class=\"list-editor\">\n//       <div class=\"list-editor-header\">\n//         <h3 class=\"list-editor-header--title\">编辑清单</h3>\n//       </div>\n//       <div class=\"list-editor-body\">\n//         <div class=\"robin-textfield\">\n//           <input type=\"text\" class=\"robin-textfield--input robin-textfield--input_default\" v-model=\"currentList.name\"/>\n//         </div>\n//       </div>\n//       <div class=\"list-editor-footer\">\n//         <span class=\"material-icons\" @click=\"deleteList(this.currentList)\">delete</span>\n//         <button class=\"robin-btn robin-btn__default\" @click=\"doEditList\">确定</button>\n//       </div>\n//     </div>\n//   </modal>\n// </template>\n// <script>\nexports.default = {\n  data: function data() {\n    return {\n      showModal: false,\n      newList: {\n        name: ''\n      },\n      currentList: null,\n      showCurrentList: false\n    };\n  },\n\n  vuex: {\n    actions: {\n      addList: listsActions.addList,\n      deleteList: listsActions.deleteList,\n      editList: listsActions.editList\n    },\n    getters: {\n      lists: getters.getLists\n    }\n  },\n  watch: {\n    // 监控左侧 list 列表，默认选中第一个\n    lists: function lists() {\n      if (this.lists && this.lists.length && this.$route.params.id) {\n        this.$router.go({ name: 'list', params: { id: this.lists[0].id } });\n      }\n      this.showModal = false;\n      this.showCurrentList = false;\n      this.newList.name = '';\n    }\n  },\n  ready: function ready() {\n    var _this = this;\n\n    document.addEventListener('keyup', function (e) {\n      if (e.keyCode === 27) {\n        _this.showModal = false;\n        _this.showCurrentList = false;\n      }\n    });\n  },\n\n  methods: {\n    createNewList: function createNewList() {\n      if (!this.newList.name) {\n        return false;\n      }\n      var param = {\n        name: this.newList.name\n      };\n      this.addList(param);\n    },\n    showCurrent: function showCurrent(e, list) {\n      this.currentList = list;\n      this.showCurrentList = true;\n    },\n    doEditList: function doEditList() {\n      var param = {};\n      param.name = this.currentList.name;\n      this.editList(this.currentList.id, param);\n    }\n  }\n};\n// </script>\n//\n// <style lang=\"less\">\n//\n//   @import '../../public/stylesheets/variables';\n//   .sidebar{\n//     float:left;\n//     width: @sideMenuWidth;\n//     // padding: 20px 30px;\n//     box-sizing: border-box;\n//     position: fixed;\n//   }\n//   .side-menu{\n//     padding: 0;\n//     margin: 0;\n//     &__item{\n//       box-sizing: border-box;\n//       border-radius: 2px;\n//       padding: 10px 10px 10px 22px;\n//       color: #000;\n//       text-decoration: none;\n//       display: flex;\n//       cursor: pointer;\n//       .edit{\n//         display: none;\n//       }\n//       &:hover{\n//         background: rgba(0,0,0,.03);\n//       }\n//       &--active{\n//         background: #e0e0e0;\n//         .edit{\n//           float:right;\n//           display: block;\n//         }\n//       }\n//       &-content{\n//         margin-left: 10px;\n//         flex: 0 0 64%;\n//         .text-overflow();\n//       }\n//     }\n//   }\n//   .side-actions{\n//    font-size: 14px;\n//  }\n//\n//  .list-editor {\n//   width: 340px;\n//   margin: 0 auto;\n//   background: #fff;\n//   border-radius: 2px;\n//   &-header {\n//     padding: 14px 14px 0px;\n//     text-align: center;\n//     &--title {\n//       font-size: 26px;\n//       margin: 0px;\n//     }\n//   }\n//   &-body {\n//     padding: 4px 14px 10px;\n//   }\n//   &-footer {\n//     padding: 12px;\n//     border-top: 1px solid #e0e0df;\n//     display: flex;\n//     align-items: center;\n//     justify-content: space-between;\n//   }\n// }\n//\n//\n// </style>\n\n/* generated by vue-loader *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc2lkZW1lbnUudnVlP2I2MjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBc0RBOzs7O0FBQ0E7O0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQUVBOztpQkFFQTs7Y0FHQTtBQUZBO21CQUdBO3VCQUVBO0FBUEE7QUFRQTs7Ozs0QkFHQTsrQkFDQTs2QkFFQTtBQUpBOztxQkFRQTtBQUhBO0FBTkE7O0FBV0E7NEJBQ0E7b0VBQ0E7b0VBQ0E7QUFDQTt1QkFDQTs2QkFDQTswQkFDQTtBQUVBO0FBVkE7O0FBV0E7O29EQUNBOzRCQUNBOzBCQUNBO2dDQUNBO0FBQ0E7QUFDQTtBQUNBOzs7NENBRUE7OEJBQ0E7ZUFDQTtBQUNBOzsyQkFHQTtBQUZBO21CQUdBO0FBQ0E7K0NBQ0E7eUJBQ0E7NkJBQ0E7QUFDQTtzQ0FDQTtrQkFDQTtvQ0FDQTt5Q0FDQTtBQUVBO0FBbkJBO0FBeENBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJzaWRlYmFyXCI+XG4gICAgPHVsIGNsYXNzPVwic2lkZS1tZW51XCI+XG4gICAgICA8bGkgdi1mb3I9XCJsaXN0IGluIGxpc3RzXCI+XG4gICAgICAgIDxhIGNsYXNzPVwic2lkZS1tZW51X19pdGVtXCIgdi1saW5rPVwie25hbWU6ICdsaXN0JywgcGFyYW1zOiB7aWQ6IGxpc3QuaWR9fVwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5saXN0PC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2lkZS1tZW51X19pdGVtLWNvbnRlbnRcIj57e2xpc3QubmFtZX19PC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2lkZS1tZW51X19pdGVtLWNvdW50XCI+e3tsaXN0LnRhc2tfY291bnRfdG90YWwgLSBsaXN0LnRhc2tfY291bnRfY29tcGxldGVkIHx8ICcnfX08L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJtYXRlcmlhbC1pY29ucyBlZGl0XCIgQGNsaWNrPVwic2hvd0N1cnJlbnQoZSwgbGlzdClcIj5lZGl0PC9zcGFuPlxuICAgICAgICA8L2E+XG4gICAgICA8L2xpPlxuICAgIDwvdWw+XG4gICAgPGRpdiBjbGFzcz1cInNpZGUtYWN0aW9uc1wiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJzaWRlLW1lbnVfX2l0ZW1cIiBAY2xpY2s9XCJzaG93TW9kYWwgPSB0cnVlXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5hZGQ8L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwic2lkZS1tZW51X19pdGVtLWNvbnRlbnRcIj7mlrDlu7rliIbnsbs8L3NwYW4+XG4gICAgICA8L3NwYW4+XG4gICAgPC9kaXY+XG5cbiAgPC9kaXY+XG4gIDxtb2RhbCA6c2hvdz1cInNob3dNb2RhbFwiPlxuICAgIDxkaXYgc2xvdD1cImNvbnRlbnRcIiBjbGFzcz1cImxpc3QtZWRpdG9yXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibGlzdC1lZGl0b3ItaGVhZGVyXCI+XG4gICAgICAgIDxoMyBjbGFzcz1cImxpc3QtZWRpdG9yLWhlYWRlci0tdGl0bGVcIj7liJvlu7rmlrDnmoTmuIXljZU8L2gzPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwibGlzdC1lZGl0b3ItYm9keVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm9iaW4tdGV4dGZpZWxkXCI+XG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJyb2Jpbi10ZXh0ZmllbGQtLWlucHV0IHJvYmluLXRleHRmaWVsZC0taW5wdXRfZGVmYXVsdFwiIHYtbW9kZWw9XCJuZXdMaXN0Lm5hbWVcIi8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwibGlzdC1lZGl0b3ItZm9vdGVyXCI+XG4gICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInJvYmluLWJ0biByb2Jpbi1idG5fX2RlZmF1bHRcIiBAY2xpY2s9XCJjcmVhdGVOZXdMaXN0XCI+5Yib5bu6PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9tb2RhbD5cbiAgPG1vZGFsIDpzaG93PVwic2hvd0N1cnJlbnRMaXN0XCI+XG4gICAgPGRpdiBzbG90PVwiY29udGVudFwiIGNsYXNzPVwibGlzdC1lZGl0b3JcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJsaXN0LWVkaXRvci1oZWFkZXJcIj5cbiAgICAgICAgPGgzIGNsYXNzPVwibGlzdC1lZGl0b3ItaGVhZGVyLS10aXRsZVwiPue8lui+kea4heWNlTwvaDM+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJsaXN0LWVkaXRvci1ib2R5XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb2Jpbi10ZXh0ZmllbGRcIj5cbiAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cInJvYmluLXRleHRmaWVsZC0taW5wdXQgcm9iaW4tdGV4dGZpZWxkLS1pbnB1dF9kZWZhdWx0XCIgdi1tb2RlbD1cImN1cnJlbnRMaXN0Lm5hbWVcIi8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwibGlzdC1lZGl0b3ItZm9vdGVyXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIiBAY2xpY2s9XCJkZWxldGVMaXN0KHRoaXMuY3VycmVudExpc3QpXCI+ZGVsZXRlPC9zcGFuPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwicm9iaW4tYnRuIHJvYmluLWJ0bl9fZGVmYXVsdFwiIEBjbGljaz1cImRvRWRpdExpc3RcIj7noa7lrpo8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L21vZGFsPlxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG4gIGltcG9ydCAqIGFzIGxpc3RzQWN0aW9ucyBmcm9tICcuLi8uLi92dWV4L2FjdGlvbnMvbGlzdHMnO1xuICBpbXBvcnQgKiBhcyBnZXR0ZXJzIGZyb20gJy4uLy4uL3Z1ZXgvZ2V0dGVyJztcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNob3dNb2RhbDogZmFsc2UsXG4gICAgICAgIG5ld0xpc3Q6IHtcbiAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVudExpc3Q6IG51bGwsXG4gICAgICAgIHNob3dDdXJyZW50TGlzdDogZmFsc2UsXG4gICAgICB9O1xuICAgIH0sXG4gICAgdnVleDoge1xuICAgICAgYWN0aW9uczoge1xuICAgICAgICBhZGRMaXN0OiBsaXN0c0FjdGlvbnMuYWRkTGlzdCxcbiAgICAgICAgZGVsZXRlTGlzdDogbGlzdHNBY3Rpb25zLmRlbGV0ZUxpc3QsXG4gICAgICAgIGVkaXRMaXN0OiBsaXN0c0FjdGlvbnMuZWRpdExpc3QsXG4gICAgICB9LFxuICAgICAgZ2V0dGVyczoge1xuICAgICAgICBsaXN0czogZ2V0dGVycy5nZXRMaXN0cyxcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAvLyDnm5Hmjqflt6bkvqcgbGlzdCDliJfooajvvIzpu5jorqTpgInkuK3nrKzkuIDkuKpcbiAgICAgIGxpc3RzKCkge1xuICAgICAgICBpZiAodGhpcy5saXN0cyAmJiB0aGlzLmxpc3RzLmxlbmd0aCAmJiB0aGlzLiRyb3V0ZS5wYXJhbXMuaWQpIHtcbiAgICAgICAgICB0aGlzLiRyb3V0ZXIuZ28oe25hbWU6ICdsaXN0JywgcGFyYW1zOiB7aWQ6IHRoaXMubGlzdHNbMF0uaWR9fSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaG93TW9kYWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG93Q3VycmVudExpc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXdMaXN0Lm5hbWUgPSAnJztcbiAgICAgIH0sXG4gICAgfSxcbiAgICByZWFkeSgpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGUpID0+IHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICB0aGlzLnNob3dNb2RhbCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuc2hvd0N1cnJlbnRMaXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgY3JlYXRlTmV3TGlzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5ld0xpc3QubmFtZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgICAgbmFtZTogdGhpcy5uZXdMaXN0Lm5hbWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkTGlzdChwYXJhbSk7XG4gICAgICB9LFxuICAgICAgc2hvd0N1cnJlbnQoZSwgbGlzdCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ID0gbGlzdDtcbiAgICAgICAgdGhpcy5zaG93Q3VycmVudExpc3QgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIGRvRWRpdExpc3QoKSB7XG4gICAgICAgIGxldCBwYXJhbSA9IHt9O1xuICAgICAgICBwYXJhbS5uYW1lID0gdGhpcy5jdXJyZW50TGlzdC5uYW1lO1xuICAgICAgICB0aGlzLmVkaXRMaXN0KHRoaXMuY3VycmVudExpc3QuaWQsIHBhcmFtKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblxuICBAaW1wb3J0ICcuLi8uLi9wdWJsaWMvc3R5bGVzaGVldHMvdmFyaWFibGVzJztcbiAgLnNpZGViYXJ7XG4gICAgZmxvYXQ6bGVmdDtcbiAgICB3aWR0aDogQHNpZGVNZW51V2lkdGg7XG4gICAgLy8gcGFkZGluZzogMjBweCAzMHB4O1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICB9XG4gIC5zaWRlLW1lbnV7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG4gICAgJl9faXRlbXtcbiAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICBwYWRkaW5nOiAxMHB4IDEwcHggMTBweCAyMnB4O1xuICAgICAgY29sb3I6ICMwMDA7XG4gICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgLmVkaXR7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICB9XG4gICAgICAmOmhvdmVye1xuICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLC4wMyk7XG4gICAgICB9XG4gICAgICAmLS1hY3RpdmV7XG4gICAgICAgIGJhY2tncm91bmQ6ICNlMGUwZTA7XG4gICAgICAgIC5lZGl0e1xuICAgICAgICAgIGZsb2F0OnJpZ2h0O1xuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAmLWNvbnRlbnR7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xuICAgICAgICBmbGV4OiAwIDAgNjQlO1xuICAgICAgICAudGV4dC1vdmVyZmxvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAuc2lkZS1hY3Rpb25ze1xuICAgZm9udC1zaXplOiAxNHB4O1xuIH1cblxuIC5saXN0LWVkaXRvciB7XG4gIHdpZHRoOiAzNDBweDtcbiAgbWFyZ2luOiAwIGF1dG87XG4gIGJhY2tncm91bmQ6ICNmZmY7XG4gIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgJi1oZWFkZXIge1xuICAgIHBhZGRpbmc6IDE0cHggMTRweCAwcHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICYtLXRpdGxlIHtcbiAgICAgIGZvbnQtc2l6ZTogMjZweDtcbiAgICAgIG1hcmdpbjogMHB4O1xuICAgIH1cbiAgfVxuICAmLWJvZHkge1xuICAgIHBhZGRpbmc6IDRweCAxNHB4IDEwcHg7XG4gIH1cbiAgJi1mb290ZXIge1xuICAgIHBhZGRpbmc6IDEycHg7XG4gICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlMGUwZGY7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgfVxufVxuXG5cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzaWRlbWVudS52dWU/M2JjOWUwMjdcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.editList = exports.deleteList = exports.addList = exports.fetchLists = undefined;\n\nvar _superagent = __webpack_require__(10);\n\nvar _superagent2 = _interopRequireDefault(_superagent);\n\nvar _mutationType = __webpack_require__(15);\n\nvar mutationType = _interopRequireWildcard(_mutationType);\n\nvar _base = __webpack_require__(16);\n\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar fetchLists = exports.fetchLists = function fetchLists(_ref) {\n  var dispatch = _ref.dispatch;\n\n  _superagent2.default.get('/lists').set('x-access-token', window.localStorage.token).use(_base2.default).then(function (res) {\n    dispatch(mutationType.FETCH_LISTS, res.body);\n  }, function (err) {\n    dispatch(mutationType.FETCH_LISTS_ERROR, err);\n  });\n};\n\nvar addList = exports.addList = function addList(_ref2, param) {\n  var dispatch = _ref2.dispatch;\n\n  _superagent2.default.post('/lists').set('x-access-token', window.localStorage.token).send(param).use(_base2.default).then(function (res) {\n    console.log(res);\n    dispatch(mutationType.ADD_LIST, res.body);\n  }, function (err) {\n    dispatch(mutationType.ADD_LIST_ERROR, err);\n  });\n};\n\nvar deleteList = exports.deleteList = function deleteList(_ref3, param) {\n  var dispatch = _ref3.dispatch;\n\n  _superagent2.default.delete('/lists/' + param.id).send(param).set('x-access-token', window.localStorage.token).use(_base2.default).then(function () {\n    dispatch(mutationType.DELETE_LIST, param.id);\n  }, function (err) {\n    dispatch(mutationType.DELETE_LIST_ERROR, err);\n  });\n};\n\nvar editList = exports.editList = function editList(_ref4, id, param) {\n  var dispatch = _ref4.dispatch;\n\n  _superagent2.default.put('/lists/' + id).send(param).set('x-access-token', window.localStorage.token).use(_base2.default).then(function (res) {\n    dispatch(mutationType.EDIT_LIST, res.body);\n  }, function (err) {\n    dispatch(mutationType.EDIT_LIST_ERROR, err);\n  });\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3Z1ZXgvYWN0aW9ucy9saXN0cy5qcz9lODk0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUNBOztJQUFZLFk7O0FBQ1o7Ozs7Ozs7O0FBRU8sSUFBTSxrQ0FBYSxTQUFiLFVBQWEsT0FBdUI7QUFBQSxNQUFaLFFBQVksUUFBWixRQUFZOztBQUMvQyx1QkFDRyxHQURILENBQ08sUUFEUCxFQUVHLEdBRkgsQ0FFTyxnQkFGUCxFQUV5QixPQUFPLFlBQVAsQ0FBb0IsS0FGN0MsRUFHRyxHQUhILGlCQUlHLElBSkgsQ0FJUSxVQUFDLEdBQUQsRUFBUztBQUNiLGFBQVMsYUFBYSxXQUF0QixFQUFtQyxJQUFJLElBQXZDO0FBQ0QsR0FOSCxFQU1LLFVBQUMsR0FBRCxFQUFTO0FBQ1YsYUFBUyxhQUFhLGlCQUF0QixFQUF5QyxHQUF6QztBQUNELEdBUkg7QUFTRCxDQVZNOztBQVlBLElBQU0sNEJBQVUsU0FBVixPQUFVLFFBQWUsS0FBZixFQUF5QjtBQUFBLE1BQXRCLFFBQXNCLFNBQXRCLFFBQXNCOztBQUM5Qyx1QkFDRyxJQURILENBQ1EsUUFEUixFQUVHLEdBRkgsQ0FFTyxnQkFGUCxFQUV5QixPQUFPLFlBQVAsQ0FBb0IsS0FGN0MsRUFHRyxJQUhILENBR1EsS0FIUixFQUlHLEdBSkgsaUJBS0csSUFMSCxDQUtRLFVBQUMsR0FBRCxFQUFTO0FBQ2IsWUFBUSxHQUFSLENBQVksR0FBWjtBQUNBLGFBQVMsYUFBYSxRQUF0QixFQUFnQyxJQUFJLElBQXBDO0FBQ0QsR0FSSCxFQVFLLFVBQUMsR0FBRCxFQUFTO0FBQ1YsYUFBUyxhQUFhLGNBQXRCLEVBQXNDLEdBQXRDO0FBQ0QsR0FWSDtBQVdELENBWk07O0FBY0EsSUFBTSxrQ0FBYSxTQUFiLFVBQWEsUUFBZSxLQUFmLEVBQXlCO0FBQUEsTUFBdEIsUUFBc0IsU0FBdEIsUUFBc0I7O0FBQ2pELHVCQUNHLE1BREgsQ0FDVSxZQUFZLE1BQU0sRUFENUIsRUFFRyxJQUZILENBRVEsS0FGUixFQUdHLEdBSEgsQ0FHTyxnQkFIUCxFQUd5QixPQUFPLFlBQVAsQ0FBb0IsS0FIN0MsRUFJRyxHQUpILGlCQUtHLElBTEgsQ0FLUSxZQUFNO0FBQ1YsYUFBUyxhQUFhLFdBQXRCLEVBQW1DLE1BQU0sRUFBekM7QUFDRCxHQVBILEVBT0ssVUFBQyxHQUFELEVBQVM7QUFDVixhQUFTLGFBQWEsaUJBQXRCLEVBQXlDLEdBQXpDO0FBQ0QsR0FUSDtBQVVELENBWE07O0FBYUEsSUFBTSw4QkFBVyxTQUFYLFFBQVcsUUFBZSxFQUFmLEVBQW1CLEtBQW5CLEVBQTZCO0FBQUEsTUFBMUIsUUFBMEIsU0FBMUIsUUFBMEI7O0FBQ25ELHVCQUNHLEdBREgsQ0FDTyxZQUFZLEVBRG5CLEVBRUcsSUFGSCxDQUVRLEtBRlIsRUFHRyxHQUhILENBR08sZ0JBSFAsRUFHeUIsT0FBTyxZQUFQLENBQW9CLEtBSDdDLEVBSUcsR0FKSCxpQkFLRyxJQUxILENBS1EsVUFBQyxHQUFELEVBQVM7QUFDYixhQUFTLGFBQWEsU0FBdEIsRUFBaUMsSUFBSSxJQUFyQztBQUNELEdBUEgsRUFPSyxVQUFDLEdBQUQsRUFBUztBQUNWLGFBQVMsYUFBYSxlQUF0QixFQUF1QyxHQUF2QztBQUNELEdBVEg7QUFVRCxDQVhNIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCAqIGFzIG11dGF0aW9uVHlwZSBmcm9tICcuLi9tdXRhdGlvblR5cGUnO1xuaW1wb3J0IGJhc2VVUkwgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGNvbnN0IGZldGNoTGlzdHMgPSBmdW5jdGlvbih7IGRpc3BhdGNoIH0pIHtcbiAgcmVxdWVzdFxuICAgIC5nZXQoJy9saXN0cycpXG4gICAgLnNldCgneC1hY2Nlc3MtdG9rZW4nLCB3aW5kb3cubG9jYWxTdG9yYWdlLnRva2VuKVxuICAgIC51c2UoYmFzZVVSTClcbiAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICBkaXNwYXRjaChtdXRhdGlvblR5cGUuRkVUQ0hfTElTVFMsIHJlcy5ib2R5KTtcbiAgICB9LCAoZXJyKSA9PiB7XG4gICAgICBkaXNwYXRjaChtdXRhdGlvblR5cGUuRkVUQ0hfTElTVFNfRVJST1IsIGVycik7XG4gICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgYWRkTGlzdCA9ICh7IGRpc3BhdGNoIH0sIHBhcmFtKSA9PiB7XG4gIHJlcXVlc3RcbiAgICAucG9zdCgnL2xpc3RzJylcbiAgICAuc2V0KCd4LWFjY2Vzcy10b2tlbicsIHdpbmRvdy5sb2NhbFN0b3JhZ2UudG9rZW4pXG4gICAgLnNlbmQocGFyYW0pXG4gICAgLnVzZShiYXNlVVJMKVxuICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKHJlcyk7XG4gICAgICBkaXNwYXRjaChtdXRhdGlvblR5cGUuQUREX0xJU1QsIHJlcy5ib2R5KTtcbiAgICB9LCAoZXJyKSA9PiB7XG4gICAgICBkaXNwYXRjaChtdXRhdGlvblR5cGUuQUREX0xJU1RfRVJST1IsIGVycik7XG4gICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgZGVsZXRlTGlzdCA9ICh7IGRpc3BhdGNoIH0sIHBhcmFtKSA9PiB7XG4gIHJlcXVlc3RcbiAgICAuZGVsZXRlKCcvbGlzdHMvJyArIHBhcmFtLmlkKVxuICAgIC5zZW5kKHBhcmFtKVxuICAgIC5zZXQoJ3gtYWNjZXNzLXRva2VuJywgd2luZG93LmxvY2FsU3RvcmFnZS50b2tlbilcbiAgICAudXNlKGJhc2VVUkwpXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgZGlzcGF0Y2gobXV0YXRpb25UeXBlLkRFTEVURV9MSVNULCBwYXJhbS5pZCk7XG4gICAgfSwgKGVycikgPT4ge1xuICAgICAgZGlzcGF0Y2gobXV0YXRpb25UeXBlLkRFTEVURV9MSVNUX0VSUk9SLCBlcnIpO1xuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGVkaXRMaXN0ID0gKHsgZGlzcGF0Y2ggfSwgaWQsIHBhcmFtKSA9PiB7XG4gIHJlcXVlc3RcbiAgICAucHV0KCcvbGlzdHMvJyArIGlkKVxuICAgIC5zZW5kKHBhcmFtKVxuICAgIC5zZXQoJ3gtYWNjZXNzLXRva2VuJywgd2luZG93LmxvY2FsU3RvcmFnZS50b2tlbilcbiAgICAudXNlKGJhc2VVUkwpXG4gICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgZGlzcGF0Y2gobXV0YXRpb25UeXBlLkVESVRfTElTVCwgcmVzLmJvZHkpO1xuICAgIH0sIChlcnIpID0+IHtcbiAgICAgIGRpc3BhdGNoKG11dGF0aW9uVHlwZS5FRElUX0xJU1RfRVJST1IsIGVycik7XG4gICAgfSk7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc3JjL3Z1ZXgvYWN0aW9ucy9saXN0cy5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Root reference for iframes.\n */\n\nvar root;\nif (typeof window !== 'undefined') { // Browser window\n  root = window;\n} else if (typeof self !== 'undefined') { // Web Worker\n  root = self;\n} else { // Other environments\n  console.warn(\"Using browser-only version of superagent in non-browser environment\");\n  root = this;\n}\n\nvar Emitter = __webpack_require__(11);\nvar requestBase = __webpack_require__(12);\nvar isObject = __webpack_require__(13);\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Expose `request`.\n */\n\nvar request = module.exports = __webpack_require__(14).bind(null, Request);\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  throw Error(\"Browser-only verison of superagent could not find XHR\");\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    if (null != obj[key]) {\n      pushEncodedKeyValuePair(pairs, key, obj[key]);\n    }\n  }\n  return pairs.join('&');\n}\n\n/**\n * Helps 'serialize' with serializing arrays.\n * Mutates the pairs array.\n *\n * @param {Array} pairs\n * @param {String} key\n * @param {Mixed} val\n */\n\nfunction pushEncodedKeyValuePair(pairs, key, val) {\n  if (Array.isArray(val)) {\n    return val.forEach(function(v) {\n      pushEncodedKeyValuePair(pairs, key, v);\n    });\n  } else if (isObject(val)) {\n    for(var subkey in val) {\n      pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);\n    }\n    return;\n  }\n  pairs.push(encodeURIComponent(key)\n    + '=' + encodeURIComponent(val));\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var pair;\n  var pos;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    pos = pair.indexOf('=');\n    if (pos == -1) {\n      obj[decodeURIComponent(pair)] = '';\n    } else {\n      obj[decodeURIComponent(pair.slice(0, pos))] =\n        decodeURIComponent(pair.slice(pos + 1));\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'application/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Check if `mime` is json or has +json structured syntax suffix.\n *\n * @param {String} mime\n * @return {Boolean}\n * @api private\n */\n\nfunction isJSON(mime) {\n  return /[\\/+]json\\b/.test(mime);\n}\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction type(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction params(str){\n  return str.split(/ *; */).reduce(function(obj, str){\n    var parts = str.split(/ *= */),\n        key = parts.shift(),\n        val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req, options) {\n  options = options || {};\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  this._setStatusProperties(this.xhr.status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this._setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD'\n    ? this._parseBody(this.text ? this.text : this.xhr.response)\n    : null;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponse.prototype.get = function(field){\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponse.prototype._setHeaderProperties = function(header){\n  // content-type\n  var ct = this.header['content-type'] || '';\n  this.type = type(ct);\n\n  // params\n  var obj = params(ct);\n  for (var key in obj) this[key] = obj[key];\n};\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype._parseBody = function(str){\n  var parse = request.parse[this.type];\n  if (!parse && isJSON(this.type)) {\n    parse = request.parse['application/json'];\n  }\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponse.prototype._setStatusProperties = function(status){\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n\n  var type = status / 100 | 0;\n\n  // status / class\n  this.status = this.statusCode = status;\n  this.statusType = type;\n\n  // basics\n  this.info = 1 == type;\n  this.ok = 2 == type;\n  this.clientError = 4 == type;\n  this.serverError = 5 == type;\n  this.error = (4 == type || 5 == type)\n    ? this.toError()\n    : false;\n\n  // sugar\n  this.accepted = 202 == status;\n  this.noContent = 204 == status;\n  this.badRequest = 400 == status;\n  this.unauthorized = 401 == status;\n  this.notAcceptable = 406 == status;\n  this.notFound = 404 == status;\n  this.forbidden = 403 == status;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {}; // preserves header name case\n  this._header = {}; // coerces header names to lowercase\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      // issue #675: return the raw response if the response parsing fails\n      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;\n      // issue #876: return the http status code if the response parsing fails\n      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    var new_err;\n    try {\n      if (res.status < 200 || res.status >= 300) {\n        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n        new_err.original = err;\n        new_err.response = res;\n        new_err.status = res.status;\n      }\n    } catch(e) {\n      new_err = e; // #985 touching res may cause INVALID_STATE_ERR on old Android\n    }\n\n    // #1000 don't catch errors from the callback to avoid double calling it\n    if (new_err) {\n      self.callback(new_err, res);\n    } else {\n      self.callback(null, res);\n    }\n  });\n}\n\n/**\n * Mixin `Emitter` and `requestBase`.\n */\n\nEmitter(Request.prototype);\nfor (var key in requestBase) {\n  Request.prototype[key] = requestBase[key];\n}\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set responseType to `val`. Presently valid responseTypes are 'blob' and\n * 'arraybuffer'.\n *\n * Examples:\n *\n *      req.get('/')\n *        .responseType('blob')\n *        .end(callback);\n *\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.responseType = function(val){\n  this._responseType = val;\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} pass\n * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass, options){\n  if (!options) {\n    options = {\n      type: 'basic'\n    }\n  }\n\n  switch (options.type) {\n    case 'basic':\n      var str = btoa(user + ':' + pass);\n      this.set('Authorization', 'Basic ' + str);\n    break;\n\n    case 'auto':\n      this.username = user;\n      this.password = pass;\n    break;\n  }\n  return this;\n};\n\n/**\n* Add query-string `val`.\n*\n* Examples:\n*\n*   request.get('/shoes')\n*     .query('size=10')\n*     .query({ color: 'blue' })\n*\n* @param {Object|String} val\n* @return {Request} for chaining\n* @api public\n*/\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `filename`.\n *\n * ``` js\n * request.post('/upload')\n *   .attach('content', new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String} filename\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, filename){\n  this._getFormData().append(field, file, filename || file.name);\n  return this;\n};\n\nRequest.prototype._getFormData = function(){\n  if (!this._formData) {\n    this._formData = new root.FormData();\n  }\n  return this._formData;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  var fn = this._callback;\n  this.clearTimeout();\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n  err.crossDomain = true;\n\n  err.status = this.status;\n  err.method = this.method;\n  err.url = this.url;\n\n  this.callback(err);\n};\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequest.prototype._timeoutError = function(){\n  var timeout = this._timeout;\n  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  this.callback(err);\n};\n\n/**\n * Compose querystring to append to req.url\n *\n * @api private\n */\n\nRequest.prototype._appendQueryString = function(){\n  var query = this._query.join('&');\n  if (query) {\n    this.url += ~this.url.indexOf('?')\n      ? '&' + query\n      : '?' + query;\n  }\n};\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  var self = this;\n  var xhr = this.xhr = request.getXHR();\n  var timeout = this._timeout;\n  var data = this._formData || this._data;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // state change\n  xhr.onreadystatechange = function(){\n    if (4 != xhr.readyState) return;\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (0 == status) {\n      if (self.timedout) return self._timeoutError();\n      if (self._aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(e){\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    e.direction = 'download';\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    xhr.onprogress = handleProgress;\n  }\n  try {\n    if (xhr.upload && this.hasListeners('progress')) {\n      xhr.upload.onprogress = handleProgress;\n    }\n  } catch(e) {\n    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n    // Reported here:\n    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n  }\n\n  // timeout\n  if (timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self.timedout = true;\n      self.abort();\n    }, timeout);\n  }\n\n  // querystring\n  this._appendQueryString();\n\n  // initiate request\n  if (this.username && this.password) {\n    xhr.open(this.method, this.url, true, this.username, this.password);\n  } else {\n    xhr.open(this.method, this.url, true);\n  }\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {\n    // serialize stuff\n    var contentType = this._header['content-type'];\n    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n    xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  if (this._responseType) {\n    xhr.responseType = this._responseType;\n  }\n\n  // send stuff\n  this.emit('request', this);\n\n  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n  // We need null here if data is undefined\n  xhr.send(typeof data !== 'undefined' ? data : null);\n  return this;\n};\n\n\n/**\n * Expose `Request`.\n */\n\nrequest.Request = Request;\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * OPTIONS query to `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.options = function(url, data, fn){\n  var req = request('OPTIONS', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nfunction del(url, fn){\n  var req = request('DELETE', url);\n  if (fn) req.end(fn);\n  return req;\n};\n\nrequest['del'] = del;\nrequest['delete'] = del;\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcz9hNTRlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0EsQ0FBQyxPQUFPO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsK0NBQStDLEVBQUU7QUFDMUQsU0FBUyxnREFBZ0QsRUFBRTtBQUMzRCxTQUFTLGdEQUFnRCxFQUFFO0FBQzNELFNBQVMsNENBQTRDLEVBQUU7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEMsaUJBQWlCLHNDQUFzQzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNB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QUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUm9vdCByZWZlcmVuY2UgZm9yIGlmcmFtZXMuXG4gKi9cblxudmFyIHJvb3Q7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQnJvd3NlciB3aW5kb3dcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IC8vIFdlYiBXb3JrZXJcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgeyAvLyBPdGhlciBlbnZpcm9ubWVudHNcbiAgY29uc29sZS53YXJuKFwiVXNpbmcgYnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcbiAgcm9vdCA9IHRoaXM7XG59XG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlcicpO1xudmFyIHJlcXVlc3RCYXNlID0gcmVxdWlyZSgnLi9yZXF1ZXN0LWJhc2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fTtcblxuLyoqXG4gKiBFeHBvc2UgYHJlcXVlc3RgLlxuICovXG5cbnZhciByZXF1ZXN0ID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlcXVlc3QnKS5iaW5kKG51bGwsIFJlcXVlc3QpO1xuXG4vKipcbiAqIERldGVybWluZSBYSFIuXG4gKi9cblxucmVxdWVzdC5nZXRYSFIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChyb290LlhNTEh0dHBSZXF1ZXN0XG4gICAgICAmJiAoIXJvb3QubG9jYXRpb24gfHwgJ2ZpbGU6JyAhPSByb290LmxvY2F0aW9uLnByb3RvY29sXG4gICAgICAgICAgfHwgIXJvb3QuQWN0aXZlWE9iamVjdCkpIHtcbiAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuNi4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjMuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gIH1cbiAgdGhyb3cgRXJyb3IoXCJCcm93c2VyLW9ubHkgdmVyaXNvbiBvZiBzdXBlcmFnZW50IGNvdWxkIG5vdCBmaW5kIFhIUlwiKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBhZGRlZCB0byBzdXBwb3J0IElFLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgdHJpbSA9ICcnLnRyaW1cbiAgPyBmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfVxuICA6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvKF5cXHMqfFxccyokKS9nLCAnJyk7IH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAobnVsbCAhPSBvYmpba2V5XSkge1xuICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgb2JqW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbC5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBmb3IodmFyIHN1YmtleSBpbiB2YWwpIHtcbiAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXkgKyAnWycgKyBzdWJrZXkgKyAnXScsIHZhbFtzdWJrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSlcbiAgICArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpKTtcbn1cblxuLyoqXG4gKiBFeHBvc2Ugc2VyaWFsaXphdGlvbiBtZXRob2QuXG4gKi9cblxuIHJlcXVlc3Quc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplO1xuXG4gLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xuICB2YXIgb2JqID0ge307XG4gIHZhciBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuICB2YXIgcGFpcjtcbiAgdmFyIHBvcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFpcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBwYWlyID0gcGFpcnNbaV07XG4gICAgcG9zID0gcGFpci5pbmRleE9mKCc9Jyk7XG4gICAgaWYgKHBvcyA9PSAtMSkge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyKV0gPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKDAsIHBvcykpXSA9XG4gICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKHBvcyArIDEpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEV4cG9zZSBwYXJzZXIuXG4gKi9cblxucmVxdWVzdC5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuXG4vKipcbiAqIERlZmF1bHQgTUlNRSB0eXBlIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKi9cblxucmVxdWVzdC50eXBlcyA9IHtcbiAgaHRtbDogJ3RleHQvaHRtbCcsXG4gIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgeG1sOiAnYXBwbGljYXRpb24veG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbiByZXF1ZXN0LnNlcmlhbGl6ZSA9IHtcbiAgICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBzZXJpYWxpemUsXG4gICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG4gfTtcblxuIC8qKlxuICAqIERlZmF1bHQgcGFyc2Vycy5cbiAgKlxuICAqICAgICBzdXBlcmFnZW50LnBhcnNlWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKHN0cil7XG4gICogICAgICAgcmV0dXJuIHsgb2JqZWN0IHBhcnNlZCBmcm9tIHN0ciB9O1xuICAqICAgICB9O1xuICAqXG4gICovXG5cbnJlcXVlc3QucGFyc2UgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBwYXJzZVN0cmluZyxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnBhcnNlXG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgYHN0cmAgaW50b1xuICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcHBlZCBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoc3RyKSB7XG4gIHZhciBsaW5lcyA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgZmllbGRzID0ge307XG4gIHZhciBpbmRleDtcbiAgdmFyIGxpbmU7XG4gIHZhciBmaWVsZDtcbiAgdmFyIHZhbDtcblxuICBsaW5lcy5wb3AoKTsgLy8gdHJhaWxpbmcgQ1JMRlxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGZpZWxkID0gbGluZS5zbGljZSgwLCBpbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB0cmltKGxpbmUuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgZmllbGRzW2ZpZWxkXSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG1pbWVgIGlzIGpzb24gb3IgaGFzICtqc29uIHN0cnVjdHVyZWQgc3ludGF4IHN1ZmZpeC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzSlNPTihtaW1lKSB7XG4gIHJldHVybiAvW1xcLytdanNvblxcYi8udGVzdChtaW1lKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHR5cGUoc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICo7ICovKS5zaGlmdCgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaGVhZGVyIGZpZWxkIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyYW1zKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgc3RyKXtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLyksXG4gICAgICAgIGtleSA9IHBhcnRzLnNoaWZ0KCksXG4gICAgICAgIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZWAgd2l0aCB0aGUgZ2l2ZW4gYHhocmAuXG4gKlxuICogIC0gc2V0IGZsYWdzICgub2ssIC5lcnJvciwgZXRjKVxuICogIC0gcGFyc2UgaGVhZGVyXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogIEFsaWFzaW5nIGBzdXBlcmFnZW50YCBhcyBgcmVxdWVzdGAgaXMgbmljZTpcbiAqXG4gKiAgICAgIHJlcXVlc3QgPSBzdXBlcmFnZW50O1xuICpcbiAqICBXZSBjYW4gdXNlIHRoZSBwcm9taXNlLWxpa2UgQVBJLCBvciBwYXNzIGNhbGxiYWNrczpcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJykuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJywgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgU2VuZGluZyBkYXRhIGNhbiBiZSBjaGFpbmVkOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5zZW5kKClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnBvc3QoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIE9yIGZ1cnRoZXIgcmVkdWNlZCB0byBhIHNpbmdsZSBjYWxsIGZvciBzaW1wbGUgY2FzZXM6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogQHBhcmFtIHtYTUxIVFRQUmVxdWVzdH0geGhyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2UocmVxLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcbiAgdGhpcy50ZXh0ID0gKCh0aGlzLnJlcS5tZXRob2QgIT0nSEVBRCcgJiYgKHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgfHwgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcpKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJylcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHRcbiAgICAgOiBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSB0aGlzLnJlcS54aHIuc3RhdHVzVGV4dDtcbiAgdGhpcy5fc2V0U3RhdHVzUHJvcGVydGllcyh0aGlzLnhoci5zdGF0dXMpO1xuICB0aGlzLmhlYWRlciA9IHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVyKHRoaXMueGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcbiAgLy8gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIHNvbWV0aW1lcyBmYWxzZWx5IHJldHVybnMgXCJcIiBmb3IgQ09SUyByZXF1ZXN0cywgYnV0XG4gIC8vIGdldFJlc3BvbnNlSGVhZGVyIHN0aWxsIHdvcmtzLiBzbyB3ZSBnZXQgY29udGVudC10eXBlIGV2ZW4gaWYgZ2V0dGluZ1xuICAvLyBvdGhlciBoZWFkZXJzIGZhaWxzLlxuICB0aGlzLmhlYWRlclsnY29udGVudC10eXBlJ10gPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG4gIHRoaXMuX3NldEhlYWRlclByb3BlcnRpZXModGhpcy5oZWFkZXIpO1xuICB0aGlzLmJvZHkgPSB0aGlzLnJlcS5tZXRob2QgIT0gJ0hFQUQnXG4gICAgPyB0aGlzLl9wYXJzZUJvZHkodGhpcy50ZXh0ID8gdGhpcy50ZXh0IDogdGhpcy54aHIucmVzcG9uc2UpXG4gICAgOiBudWxsO1xufVxuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGBmaWVsZGAgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciByZWxhdGVkIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGAudHlwZWAgdGhlIGNvbnRlbnQgdHlwZSB3aXRob3V0IHBhcmFtc1xuICpcbiAqIEEgcmVzcG9uc2Ugb2YgXCJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICogd2lsbCBwcm92aWRlIHlvdSB3aXRoIGEgYC50eXBlYCBvZiBcInRleHQvcGxhaW5cIi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX3NldEhlYWRlclByb3BlcnRpZXMgPSBmdW5jdGlvbihoZWFkZXIpe1xuICAvLyBjb250ZW50LXR5cGVcbiAgdmFyIGN0ID0gdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICB0aGlzLnR5cGUgPSB0eXBlKGN0KTtcblxuICAvLyBwYXJhbXNcbiAgdmFyIG9iaiA9IHBhcmFtcyhjdCk7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHRoaXNba2V5XSA9IG9ialtrZXldO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYm9keSBgc3RyYC5cbiAqXG4gKiBVc2VkIGZvciBhdXRvLXBhcnNpbmcgb2YgYm9kaWVzLiBQYXJzZXJzXG4gKiBhcmUgZGVmaW5lZCBvbiB0aGUgYHN1cGVyYWdlbnQucGFyc2VgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fcGFyc2VCb2R5ID0gZnVuY3Rpb24oc3RyKXtcbiAgdmFyIHBhcnNlID0gcmVxdWVzdC5wYXJzZVt0aGlzLnR5cGVdO1xuICBpZiAoIXBhcnNlICYmIGlzSlNPTih0aGlzLnR5cGUpKSB7XG4gICAgcGFyc2UgPSByZXF1ZXN0LnBhcnNlWydhcHBsaWNhdGlvbi9qc29uJ107XG4gIH1cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCB8fCBzdHIgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgPyBwYXJzZShzdHIpXG4gICAgOiBudWxsO1xufTtcblxuLyoqXG4gKiBTZXQgZmxhZ3Mgc3VjaCBhcyBgLm9rYCBiYXNlZCBvbiBgc3RhdHVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cbiAqIHdoZXJlYXMgNXh4IHdpbGwgYmUgX19mYWxzZV9fIGFuZCBgLmVycm9yYCB3aWxsIGJlIF9fdHJ1ZV9fLiBUaGVcbiAqIGAuY2xpZW50RXJyb3JgIGFuZCBgLnNlcnZlckVycm9yYCBhcmUgYWxzbyBhdmFpbGFibGUgdG8gYmUgbW9yZVxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxuICogc29tZXRpbWVzIHVzZWZ1bCBmb3IgbWFwcGluZyByZXNwb25kIGNvbG9ycyBldGMuXG4gKlxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxuICpcbiAqICAgLSAubm9Db250ZW50XG4gKiAgIC0gLmJhZFJlcXVlc3RcbiAqICAgLSAudW5hdXRob3JpemVkXG4gKiAgIC0gLm5vdEFjY2VwdGFibGVcbiAqICAgLSAubm90Rm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX3NldFN0YXR1c1Byb3BlcnRpZXMgPSBmdW5jdGlvbihzdGF0dXMpe1xuICAvLyBoYW5kbGUgSUU5IGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG4gIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICBzdGF0dXMgPSAyMDQ7XG4gIH1cblxuICB2YXIgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7XG5cbiAgLy8gc3RhdHVzIC8gY2xhc3NcbiAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XG5cbiAgLy8gYmFzaWNzXG4gIHRoaXMuaW5mbyA9IDEgPT0gdHlwZTtcbiAgdGhpcy5vayA9IDIgPT0gdHlwZTtcbiAgdGhpcy5jbGllbnRFcnJvciA9IDQgPT0gdHlwZTtcbiAgdGhpcy5zZXJ2ZXJFcnJvciA9IDUgPT0gdHlwZTtcbiAgdGhpcy5lcnJvciA9ICg0ID09IHR5cGUgfHwgNSA9PSB0eXBlKVxuICAgID8gdGhpcy50b0Vycm9yKClcbiAgICA6IGZhbHNlO1xuXG4gIC8vIHN1Z2FyXG4gIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICB0aGlzLm5vQ29udGVudCA9IDIwNCA9PSBzdGF0dXM7XG4gIHRoaXMuYmFkUmVxdWVzdCA9IDQwMCA9PSBzdGF0dXM7XG4gIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgdGhpcy5ub3RBY2NlcHRhYmxlID0gNDA2ID09IHN0YXR1cztcbiAgdGhpcy5ub3RGb3VuZCA9IDQwNCA9PSBzdGF0dXM7XG4gIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kO1xuICB2YXIgdXJsID0gcmVxLnVybDtcblxuICB2YXIgbXNnID0gJ2Nhbm5vdCAnICsgbWV0aG9kICsgJyAnICsgdXJsICsgJyAoJyArIHRoaXMuc3RhdHVzICsgJyknO1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTsgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcbiAgdGhpcy5faGVhZGVyID0ge307IC8vIGNvZXJjZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyY2FzZVxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpe1xuICAgIHZhciBlcnIgPSBudWxsO1xuICAgIHZhciByZXMgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IG5ldyBSZXNwb25zZShzZWxmKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignUGFyc2VyIGlzIHVuYWJsZSB0byBwYXJzZSB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIGVyci5wYXJzZSA9IHRydWU7XG4gICAgICBlcnIub3JpZ2luYWwgPSBlO1xuICAgICAgLy8gaXNzdWUgIzY3NTogcmV0dXJuIHRoZSByYXcgcmVzcG9uc2UgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgIGVyci5yYXdSZXNwb25zZSA9IHNlbGYueGhyICYmIHNlbGYueGhyLnJlc3BvbnNlVGV4dCA/IHNlbGYueGhyLnJlc3BvbnNlVGV4dCA6IG51bGw7XG4gICAgICAvLyBpc3N1ZSAjODc2OiByZXR1cm4gdGhlIGh0dHAgc3RhdHVzIGNvZGUgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgIGVyci5zdGF0dXNDb2RlID0gc2VsZi54aHIgJiYgc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG5cbiAgICB2YXIgbmV3X2VycjtcbiAgICB0cnkge1xuICAgICAgaWYgKHJlcy5zdGF0dXMgPCAyMDAgfHwgcmVzLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICAgICAgbmV3X2Vyci5vcmlnaW5hbCA9IGVycjtcbiAgICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgICAgbmV3X2Vyci5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgbmV3X2VyciA9IGU7IC8vICM5ODUgdG91Y2hpbmcgcmVzIG1heSBjYXVzZSBJTlZBTElEX1NUQVRFX0VSUiBvbiBvbGQgQW5kcm9pZFxuICAgIH1cblxuICAgIC8vICMxMDAwIGRvbid0IGNhdGNoIGVycm9ycyBmcm9tIHRoZSBjYWxsYmFjayB0byBhdm9pZCBkb3VibGUgY2FsbGluZyBpdFxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBzZWxmLmNhbGxiYWNrKG5ld19lcnIsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1peGluIGBFbWl0dGVyYCBhbmQgYHJlcXVlc3RCYXNlYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcbmZvciAodmFyIGtleSBpbiByZXF1ZXN0QmFzZSkge1xuICBSZXF1ZXN0LnByb3RvdHlwZVtrZXldID0gcmVxdWVzdEJhc2Vba2V5XTtcbn1cblxuLyoqXG4gKiBTZXQgQ29udGVudC1UeXBlIHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgneG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCdhcHBsaWNhdGlvbi94bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0NvbnRlbnQtVHlwZScsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgcmVzcG9uc2VUeXBlIHRvIGB2YWxgLiBQcmVzZW50bHkgdmFsaWQgcmVzcG9uc2VUeXBlcyBhcmUgJ2Jsb2InIGFuZFxuICogJ2FycmF5YnVmZmVyJy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5yZXNwb25zZVR5cGUoJ2Jsb2InKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWwpe1xuICB0aGlzLl9yZXNwb25zZVR5cGUgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQWNjZXB0IHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLmpzb24gPSAnYXBwbGljYXRpb24vanNvbic7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdqc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY2NlcHRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0FjY2VwdCcsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQXV0aG9yaXphdGlvbiBmaWVsZCB2YWx1ZSB3aXRoIGB1c2VyYCBhbmQgYHBhc3NgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFzc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgd2l0aCAndHlwZScgcHJvcGVydHkgJ2F1dG8nIG9yICdiYXNpYycgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucyl7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiAnYmFzaWMnXG4gICAgfVxuICB9XG5cbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlICdiYXNpYyc6XG4gICAgICB2YXIgc3RyID0gYnRvYSh1c2VyICsgJzonICsgcGFzcyk7XG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgc3RyKTtcbiAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXI7XG4gICAgICB0aGlzLnBhc3N3b3JkID0gcGFzcztcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuKiBBZGQgcXVlcnktc3RyaW5nIGB2YWxgLlxuKlxuKiBFeGFtcGxlczpcbipcbiogICByZXF1ZXN0LmdldCgnL3Nob2VzJylcbiogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4qICAgICAucXVlcnkoeyBjb2xvcjogJ2JsdWUnIH0pXG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4qIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuKiBAYXBpIHB1YmxpY1xuKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2YWwpe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHZhbCkgdmFsID0gc2VyaWFsaXplKHZhbCk7XG4gIGlmICh2YWwpIHRoaXMuX3F1ZXJ5LnB1c2godmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBmaWxlbmFtZWAuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuYXR0YWNoKCdjb250ZW50JywgbmV3IEJsb2IoWyc8YSBpZD1cImFcIj48YiBpZD1cImJcIj5oZXkhPC9iPjwvYT4nXSwgeyB0eXBlOiBcInRleHQvaHRtbFwifSkpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge0Jsb2J8RmlsZX0gZmlsZVxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oZmllbGQsIGZpbGUsIGZpbGVuYW1lKXtcbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIGZpbGVuYW1lIHx8IGZpbGUubmFtZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2dldEZvcm1EYXRhID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRoaXMuX2Zvcm1EYXRhID0gbmV3IHJvb3QuRm9ybURhdGEoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZm9ybURhdGE7XG59O1xuXG4vKipcbiAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBgZXJyYCBhbmQgYHJlc2BcbiAqIGFuZCBoYW5kbGUgYXJpdHkgY2hlY2suXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCByZXMpe1xuICB2YXIgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgZm4oZXJyLCByZXMpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB4LWRvbWFpbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcm9zc0RvbWFpbkVycm9yID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignUmVxdWVzdCBoYXMgYmVlbiB0ZXJtaW5hdGVkXFxuUG9zc2libGUgY2F1c2VzOiB0aGUgbmV0d29yayBpcyBvZmZsaW5lLCBPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luLCB0aGUgcGFnZSBpcyBiZWluZyB1bmxvYWRlZCwgZXRjLicpO1xuICBlcnIuY3Jvc3NEb21haW4gPSB0cnVlO1xuXG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IHRoaXMubWV0aG9kO1xuICBlcnIudXJsID0gdGhpcy51cmw7XG5cbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3RpbWVvdXQgb2YgJyArIHRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnKTtcbiAgZXJyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vKipcbiAqIENvbXBvc2UgcXVlcnlzdHJpbmcgdG8gYXBwZW5kIHRvIHJlcS51cmxcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fYXBwZW5kUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeS5qb2luKCcmJyk7XG4gIGlmIChxdWVyeSkge1xuICAgIHRoaXMudXJsICs9IH50aGlzLnVybC5pbmRleE9mKCc/JylcbiAgICAgID8gJyYnICsgcXVlcnlcbiAgICAgIDogJz8nICsgcXVlcnk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5pdGlhdGUgcmVxdWVzdCwgaW52b2tpbmcgY2FsbGJhY2sgYGZuKHJlcylgXG4gKiB3aXRoIGFuIGluc3RhbmNlb2YgYFJlc3BvbnNlYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGhyID0gdGhpcy54aHIgPSByZXF1ZXN0LmdldFhIUigpO1xuICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gIHZhciBkYXRhID0gdGhpcy5fZm9ybURhdGEgfHwgdGhpcy5fZGF0YTtcblxuICAvLyBzdG9yZSBjYWxsYmFja1xuICB0aGlzLl9jYWxsYmFjayA9IGZuIHx8IG5vb3A7XG5cbiAgLy8gc3RhdGUgY2hhbmdlXG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG5cbiAgICAvLyBJbiBJRTksIHJlYWRzIHRvIGFueSBwcm9wZXJ0eSAoZS5nLiBzdGF0dXMpIG9mZiBvZiBhbiBhYm9ydGVkIFhIUiB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBlcnJvciBcIkNvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlwiXG4gICAgdmFyIHN0YXR1cztcbiAgICB0cnkgeyBzdGF0dXMgPSB4aHIuc3RhdHVzIH0gY2F0Y2goZSkgeyBzdGF0dXMgPSAwOyB9XG5cbiAgICBpZiAoMCA9PSBzdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLnRpbWVkb3V0KSByZXR1cm4gc2VsZi5fdGltZW91dEVycm9yKCk7XG4gICAgICBpZiAoc2VsZi5fYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgcmV0dXJuIHNlbGYuY3Jvc3NEb21haW5FcnJvcigpO1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9O1xuXG4gIC8vIHByb2dyZXNzXG4gIHZhciBoYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uKGUpe1xuICAgIGlmIChlLnRvdGFsID4gMCkge1xuICAgICAgZS5wZXJjZW50ID0gZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwO1xuICAgIH1cbiAgICBlLmRpcmVjdGlvbiA9ICdkb3dubG9hZCc7XG4gICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIGUpO1xuICB9O1xuICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICB4aHIub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKHhoci51cGxvYWQgJiYgdGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7XG4gICAgLy8gQWNjZXNzaW5nIHhoci51cGxvYWQgZmFpbHMgaW4gSUUgZnJvbSBhIHdlYiB3b3JrZXIsIHNvIGp1c3QgcHJldGVuZCBpdCBkb2Vzbid0IGV4aXN0LlxuICAgIC8vIFJlcG9ydGVkIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MzcyNDUveG1saHR0cHJlcXVlc3QtdXBsb2FkLXRocm93cy1pbnZhbGlkLWFyZ3VtZW50LXdoZW4tdXNlZC1mcm9tLXdlYi13b3JrZXItY29udGV4dFxuICB9XG5cbiAgLy8gdGltZW91dFxuICBpZiAodGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYudGltZWRvdXQgPSB0cnVlO1xuICAgICAgc2VsZi5hYm9ydCgpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9XG5cbiAgLy8gcXVlcnlzdHJpbmdcbiAgdGhpcy5fYXBwZW5kUXVlcnlTdHJpbmcoKTtcblxuICAvLyBpbml0aWF0ZSByZXF1ZXN0XG4gIGlmICh0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmQpIHtcbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUsIHRoaXMudXNlcm5hbWUsIHRoaXMucGFzc3dvcmQpO1xuICB9IGVsc2Uge1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSk7XG4gIH1cblxuICAvLyBDT1JTXG4gIGlmICh0aGlzLl93aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gIC8vIGJvZHlcbiAgaWYgKCdHRVQnICE9IHRoaXMubWV0aG9kICYmICdIRUFEJyAhPSB0aGlzLm1ldGhvZCAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSAmJiAhdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgLy8gc2VyaWFsaXplIHN0dWZmXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICB2YXIgc2VyaWFsaXplID0gdGhpcy5fc2VyaWFsaXplciB8fCByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRXhwb3NlIGBSZXF1ZXN0YC5cbiAqL1xuXG5yZXF1ZXN0LlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdHRVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogSEVBRCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuaGVhZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIE9QVElPTlMgcXVlcnkgdG8gYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0Lm9wdGlvbnMgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBERUxFVEUgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVsKHVybCwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnREVMRVRFJywgdXJsKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbnJlcXVlc3RbJ2RlbCddID0gZGVsO1xucmVxdWVzdFsnZGVsZXRlJ10gPSBkZWw7XG5cbi8qKlxuICogUEFUQ0ggYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucGF0Y2ggPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUE9TVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wb3N0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUFVUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnB1dCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUFVUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zdXBlcmFnZW50L2xpYi9jbGllbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (true) {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  var args = [].slice.call(arguments, 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzP2VhMmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Module of mixed-in functions shared between node and client code\n */\nvar isObject = __webpack_require__(13);\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nexports.clearTimeout = function _clearTimeout(){\n  this._timeout = 0;\n  clearTimeout(this._timer);\n  return this;\n};\n\n/**\n * Override default response body parser\n *\n * This function will be called to convert incoming data into request.body\n *\n * @param {Function}\n * @api public\n */\n\nexports.parse = function parse(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Override default request body serializer\n *\n * This function will be called to convert data set via .send or .attach into payload to send\n *\n * @param {Function}\n * @api public\n */\n\nexports.serialize = function serialize(fn){\n  this._serializer = fn;\n  return this;\n};\n\n/**\n * Set timeout to `ms`.\n *\n * @param {Number} ms\n * @return {Request} for chaining\n * @api public\n */\n\nexports.timeout = function timeout(ms){\n  this._timeout = ms;\n  return this;\n};\n\n/**\n * Promise support\n *\n * @param {Function} resolve\n * @param {Function} reject\n * @return {Request}\n */\n\nexports.then = function then(resolve, reject) {\n  if (!this._fullfilledPromise) {\n    var self = this;\n    this._fullfilledPromise = new Promise(function(innerResolve, innerReject){\n      self.end(function(err, res){\n        if (err) innerReject(err); else innerResolve(res);\n      });\n    });\n  }\n  return this._fullfilledPromise.then(resolve, reject);\n}\n\n/**\n * Allow for extension\n */\n\nexports.use = function use(fn) {\n  fn(this);\n  return this;\n}\n\n\n/**\n * Get request header `field`.\n * Case-insensitive.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nexports.get = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Get case-insensitive header `field` value.\n * This is a deprecated internal API. Use `.get(field)` instead.\n *\n * (getHeader is no longer used internally by the superagent code base)\n *\n * @param {String} field\n * @return {String}\n * @api private\n * @deprecated\n */\n\nexports.getHeader = exports.get;\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n * Case-insensitive.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nexports.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n * Case-insensitive.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n */\nexports.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Write the field `name` and `val` for \"multipart/form-data\"\n * request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n * ```\n *\n * @param {String} name\n * @param {String|Blob|File|Buffer|fs.ReadStream} val\n * @return {Request} for chaining\n * @api public\n */\nexports.field = function(name, val) {\n  this._getFormData().append(name, val);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\nexports.abort = function(){\n  if (this._aborted) {\n    return this;\n  }\n  this._aborted = true;\n  this.xhr && this.xhr.abort(); // browser\n  this.req && this.req.abort(); // node\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nexports.withCredentials = function(){\n  // This is browser-only functionality. Node side is no-op.\n  this._withCredentials = true;\n  return this;\n};\n\n/**\n * Set the max redirects to `n`. Does noting in browser XHR implementation.\n *\n * @param {Number} n\n * @return {Request} for chaining\n * @api public\n */\n\nexports.redirects = function(n){\n  this._maxRedirects = n;\n  return this;\n};\n\n/**\n * Convert to a plain javascript object (not JSON string) of scalar properties.\n * Note as this method is designed to return a useful non-this value,\n * it cannot be chained.\n *\n * @return {Object} describing method, url, and data of this request\n * @api public\n */\n\nexports.toJSON = function(){\n  return {\n    method: this.method,\n    url: this.url,\n    data: this._data,\n    headers: this._header\n  };\n};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * TODO: future proof, move to compoent land\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nexports._isHost = function _isHost(obj) {\n  var str = {}.toString.call(obj);\n\n  switch (str) {\n    case '[object File]':\n    case '[object Blob]':\n    case '[object FormData]':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Send `data` as the request body, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"}')\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n *      request.post('/user')\n *        .send('name=tobi')\n *        .send('species=ferret')\n *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nexports.send = function(data){\n  var obj = isObject(data);\n  var type = this._header['content-type'];\n\n  // merge\n  if (obj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    // default to x-www-form-urlencoded\n    if (!type) this.type('form');\n    type = this._header['content-type'];\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!obj || this._isHost(data)) return this;\n\n  // default to json\n  if (!type) this.type('json');\n  return this;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N1cGVyYWdlbnQvbGliL3JlcXVlc3QtYmFzZS5qcz8yMDcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQW9EO0FBQ3BFO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsc0NBQXNDO0FBQ2pELFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIG9mIG1peGVkLWluIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiBub2RlIGFuZCBjbGllbnQgY29kZVxuICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gX2NsZWFyVGltZW91dCgpe1xuICB0aGlzLl90aW1lb3V0ID0gMDtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVzcG9uc2UgYm9keSBwYXJzZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgaW5jb21pbmcgZGF0YSBpbnRvIHJlcXVlc3QuYm9keVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShmbil7XG4gIHRoaXMuX3BhcnNlciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXF1ZXN0IGJvZHkgc2VyaWFsaXplclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBkYXRhIHNldCB2aWEgLnNlbmQgb3IgLmF0dGFjaCBpbnRvIHBheWxvYWQgdG8gc2VuZFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKGZuKXtcbiAgdGhpcy5fc2VyaWFsaXplciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRpbWVvdXQgdG8gYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnRpbWVvdXQgPSBmdW5jdGlvbiB0aW1lb3V0KG1zKXtcbiAgdGhpcy5fdGltZW91dCA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHJvbWlzZSBzdXBwb3J0XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cbmV4cG9ydHMudGhlbiA9IGZ1bmN0aW9uIHRoZW4ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGlmICghdGhpcy5fZnVsbGZpbGxlZFByb21pc2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fZnVsbGZpbGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihpbm5lclJlc29sdmUsIGlubmVyUmVqZWN0KXtcbiAgICAgIHNlbGYuZW5kKGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgICAgICAgaWYgKGVycikgaW5uZXJSZWplY3QoZXJyKTsgZWxzZSBpbm5lclJlc29sdmUocmVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59XG5cbi8qKlxuICogQWxsb3cgZm9yIGV4dGVuc2lvblxuICovXG5cbmV4cG9ydHMudXNlID0gZnVuY3Rpb24gdXNlKGZuKSB7XG4gIGZuKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIEdldCByZXF1ZXN0IGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBgZmllbGRgIHZhbHVlLlxuICogVGhpcyBpcyBhIGRlcHJlY2F0ZWQgaW50ZXJuYWwgQVBJLiBVc2UgYC5nZXQoZmllbGQpYCBpbnN0ZWFkLlxuICpcbiAqIChnZXRIZWFkZXIgaXMgbm8gbG9uZ2VyIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgc3VwZXJhZ2VudCBjb2RlIGJhc2UpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuZXhwb3J0cy5nZXRIZWFkZXIgPSBleHBvcnRzLmdldDtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIGBmaWVsZGAgdG8gYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3QuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5zZXQoJ1gtQVBJLUtleScsICdmb29iYXInKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCh7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAnWC1BUEktS2V5JzogJ2Zvb2JhcicgfSlcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZXQgPSBmdW5jdGlvbihmaWVsZCwgdmFsKXtcbiAgaWYgKGlzT2JqZWN0KGZpZWxkKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBmaWVsZCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAudW5zZXQoJ1VzZXItQWdlbnQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICovXG5leHBvcnRzLnVuc2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGUgdGhlIGZpZWxkIGBuYW1lYCBhbmQgYHZhbGAgZm9yIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiXG4gKiByZXF1ZXN0IGJvZGllcy5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCgnZm9vJywgJ2JhcicpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8RmlsZXxCdWZmZXJ8ZnMuUmVhZFN0cmVhbX0gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMuZmllbGQgPSBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQobmFtZSwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFib3J0IHRoZSByZXF1ZXN0LCBhbmQgY2xlYXIgcG90ZW50aWFsIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMuYWJvcnQgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhociAmJiB0aGlzLnhoci5hYm9ydCgpOyAvLyBicm93c2VyXG4gIHRoaXMucmVxICYmIHRoaXMucmVxLmFib3J0KCk7IC8vIG5vZGVcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5hYmxlIHRyYW5zbWlzc2lvbiBvZiBjb29raWVzIHdpdGggeC1kb21haW4gcmVxdWVzdHMuXG4gKlxuICogTm90ZSB0aGF0IGZvciB0aGlzIHRvIHdvcmsgdGhlIG9yaWdpbiBtdXN0IG5vdCBiZVxuICogdXNpbmcgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIiB3aXRoIGEgd2lsZGNhcmQsXG4gKiBhbmQgYWxzbyBtdXN0IHNldCBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCJcbiAqIHRvIFwidHJ1ZVwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy53aXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbigpe1xuICAvLyBUaGlzIGlzIGJyb3dzZXItb25seSBmdW5jdGlvbmFsaXR5LiBOb2RlIHNpZGUgaXMgbm8tb3AuXG4gIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCByZWRpcmVjdHMgdG8gYG5gLiBEb2VzIG5vdGluZyBpbiBicm93c2VyIFhIUiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVkaXJlY3RzID0gZnVuY3Rpb24obil7XG4gIHRoaXMuX21heFJlZGlyZWN0cyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgKG5vdCBKU09OIHN0cmluZykgb2Ygc2NhbGFyIHByb3BlcnRpZXMuXG4gKiBOb3RlIGFzIHRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIHJldHVybiBhIHVzZWZ1bCBub24tdGhpcyB2YWx1ZSxcbiAqIGl0IGNhbm5vdCBiZSBjaGFpbmVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVzY3JpYmluZyBtZXRob2QsIHVybCwgYW5kIGRhdGEgb2YgdGhpcyByZXF1ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudG9KU09OID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgIHVybDogdGhpcy51cmwsXG4gICAgZGF0YTogdGhpcy5fZGF0YSxcbiAgICBoZWFkZXJzOiB0aGlzLl9oZWFkZXJcbiAgfTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBob3N0IG9iamVjdCxcbiAqIHdlIGRvbid0IHdhbnQgdG8gc2VyaWFsaXplIHRoZXNlIDopXG4gKlxuICogVE9ETzogZnV0dXJlIHByb29mLCBtb3ZlIHRvIGNvbXBvZW50IGxhbmRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5faXNIb3N0ID0gZnVuY3Rpb24gX2lzSG9zdChvYmopIHtcbiAgdmFyIHN0ciA9IHt9LnRvU3RyaW5nLmNhbGwob2JqKTtcblxuICBzd2l0Y2ggKHN0cikge1xuICAgIGNhc2UgJ1tvYmplY3QgRmlsZV0nOlxuICAgIGNhc2UgJ1tvYmplY3QgQmxvYl0nOlxuICAgIGNhc2UgJ1tvYmplY3QgRm9ybURhdGFdJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kIGBkYXRhYCBhcyB0aGUgcmVxdWVzdCBib2R5LCBkZWZhdWx0aW5nIHRoZSBgLnR5cGUoKWAgdG8gXCJqc29uXCIgd2hlblxuICogYW4gb2JqZWN0IGlzIGdpdmVuLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIG1hbnVhbCBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgICAuc2VuZCgne1wibmFtZVwiOlwidGpcIn0nKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8ganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKCduYW1lPXRqJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gZGVmYXVsdHMgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKCduYW1lPXRvYmknKVxuICogICAgICAgIC5zZW5kKCdzcGVjaWVzPWZlcnJldCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnNlbmQgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIG9iaiA9IGlzT2JqZWN0KGRhdGEpO1xuICB2YXIgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgLy8gbWVyZ2VcbiAgaWYgKG9iaiAmJiBpc09iamVjdCh0aGlzLl9kYXRhKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgLy8gZGVmYXVsdCB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xuICAgIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIGlmICgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyA9PSB0eXBlKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YVxuICAgICAgICA/IHRoaXMuX2RhdGEgKyAnJicgKyBkYXRhXG4gICAgICAgIDogZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGF0YSA9ICh0aGlzLl9kYXRhIHx8ICcnKSArIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgaWYgKCFvYmogfHwgdGhpcy5faXNIb3N0KGRhdGEpKSByZXR1cm4gdGhpcztcblxuICAvLyBkZWZhdWx0IHRvIGpzb25cbiAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2pzb24nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3VwZXJhZ2VudC9saWIvcmVxdWVzdC1iYXNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return null !== obj && 'object' === typeof obj;\n}\n\nmodule.exports = isObject;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N1cGVyYWdlbnQvbGliL2lzLW9iamVjdC5qcz85ZWRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBudWxsICE9PSBvYmogJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zdXBlcmFnZW50L2xpYi9pcy1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 14 */
/***/ function(module, exports) {

	eval("// The node and browser modules expose versions of this with the\n// appropriate constructor function bound as first argument\n/**\n * Issue a request:\n *\n * Examples:\n *\n *    request('GET', '/users').end(callback)\n *    request('/users').end(callback)\n *    request('/users', callback)\n *\n * @param {String} method\n * @param {String|Function} url or callback\n * @return {Request}\n * @api public\n */\n\nfunction request(RequestConstructor, method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new RequestConstructor('GET', method).end(url);\n  }\n\n  // url first\n  if (2 == arguments.length) {\n    return new RequestConstructor('GET', method);\n  }\n\n  return new RequestConstructor(method, url);\n}\n\nmodule.exports = request;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N1cGVyYWdlbnQvbGliL3JlcXVlc3QuanM/NjFjOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoZSBub2RlIGFuZCBicm93c2VyIG1vZHVsZXMgZXhwb3NlIHZlcnNpb25zIG9mIHRoaXMgd2l0aCB0aGVcbi8vIGFwcHJvcHJpYXRlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGJvdW5kIGFzIGZpcnN0IGFyZ3VtZW50XG4vKipcbiAqIElzc3VlIGEgcmVxdWVzdDpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICByZXF1ZXN0KCdHRVQnLCAnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJywgY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHVybCBvciBjYWxsYmFja1xuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcmVxdWVzdChSZXF1ZXN0Q29uc3RydWN0b3IsIG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1cmwpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcignR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcbiAgfVxuXG4gIC8vIHVybCBmaXJzdFxuICBpZiAoMiA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0Q29uc3RydWN0b3IoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcihtZXRob2QsIHVybCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N1cGVyYWdlbnQvbGliL3JlcXVlc3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar AUTHENTICATE = exports.AUTHENTICATE = 'AUTHENTICATE';\nvar AUTHENTICATE_ERROR = exports.AUTHENTICATE_ERROR = 'AUTHENTICATE_ERROR';\nvar LOGIN = exports.LOGIN = 'LOGIN';\nvar LOGIN_ERROR = exports.LOGIN_ERROR = 'LOGIN_ERROR';\n\nvar FETCH_TASKS = exports.FETCH_TASKS = 'FETCH_TASKS';\nvar FETCH_TASKS_ERROR = exports.FETCH_TASKS_ERROR = 'FETCH_TASKS_ERROR';\nvar FETCH_TASK_DETAIL = exports.FETCH_TASK_DETAIL = 'FETCH_TASK_DETAIL';\nvar FETCH_TASK_DETAIL_ERROR = exports.FETCH_TASK_DETAIL_ERROR = 'FETCH_TASK_DETAIL_ERROR';\nvar HIDE_DETAIL_WINDOW = exports.HIDE_DETAIL_WINDOW = 'HIDE_DETAIL_WINDOW';\nvar ADD_TASK = exports.ADD_TASK = 'ADD_TASK';\nvar ADD_TASK_ERROR = exports.ADD_TASK_ERROR = 'ADD_TASK_ERROR';\nvar DELETE_TASK = exports.DELETE_TASK = 'DELETE_TASK';\nvar EDIT_TASK = exports.EDIT_TASK = 'EDIT_TASK';\nvar COMPLETE_TASK = exports.COMPLETE_TASK = 'COMPLETE_TASK';\n\n// list 相关\nvar FETCH_LISTS = exports.FETCH_LISTS = 'FETCH_LISTS';\nvar FETCH_LISTS_ERROR = exports.FETCH_LISTS_ERROR = 'FETCH_LISTS_ERROR';\nvar ADD_LIST = exports.ADD_LIST = 'ADD_LIST';\nvar ADD_LIST_ERROR = exports.ADD_LIST_ERROR = 'ADD_LIST_ERROR';\nvar EDIT_LIST = exports.EDIT_LIST = 'EDIT_LIST';\nvar DELETE_LIST = exports.DELETE_LIST = 'DELETE_LIST';\nvar DELETE_LIST_ERROR = exports.DELETE_LIST_ERROR = 'DELETE_LIST_ERROR';\n\nvar UPDATE_LIST = exports.UPDATE_LIST = 'UPDATE_LIST';//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3Z1ZXgvbXV0YXRpb25UeXBlLmpzPzMwYzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxJQUFNLHNDQUFlLGNBQXJCO0FBQ0EsSUFBTSxrREFBcUIsb0JBQTNCO0FBQ0EsSUFBTSx3QkFBUSxPQUFkO0FBQ0EsSUFBTSxvQ0FBYyxhQUFwQjs7QUFFQSxJQUFNLG9DQUFjLGFBQXBCO0FBQ0EsSUFBTSxnREFBb0IsbUJBQTFCO0FBQ0EsSUFBTSxnREFBb0IsbUJBQTFCO0FBQ0EsSUFBTSw0REFBMEIseUJBQWhDO0FBQ0EsSUFBTSxrREFBcUIsb0JBQTNCO0FBQ0EsSUFBTSw4QkFBVyxVQUFqQjtBQUNBLElBQU0sMENBQWlCLGdCQUF2QjtBQUNBLElBQU0sb0NBQWMsYUFBcEI7QUFDQSxJQUFNLGdDQUFZLFdBQWxCO0FBQ0EsSUFBTSx3Q0FBZ0IsZUFBdEI7O0FBRVA7QUFDTyxJQUFNLG9DQUFjLGFBQXBCO0FBQ0EsSUFBTSxnREFBb0IsbUJBQTFCO0FBQ0EsSUFBTSw4QkFBVyxVQUFqQjtBQUNBLElBQU0sMENBQWlCLGdCQUF2QjtBQUNBLElBQU0sZ0NBQVksV0FBbEI7QUFDQSxJQUFNLG9DQUFjLGFBQXBCO0FBQ0EsSUFBTSxnREFBb0IsbUJBQTFCOztBQUVBLElBQU0sb0NBQWMsYUFBcEIiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgQVVUSEVOVElDQVRFID0gJ0FVVEhFTlRJQ0FURSc7XG5leHBvcnQgY29uc3QgQVVUSEVOVElDQVRFX0VSUk9SID0gJ0FVVEhFTlRJQ0FURV9FUlJPUic7XG5leHBvcnQgY29uc3QgTE9HSU4gPSAnTE9HSU4nO1xuZXhwb3J0IGNvbnN0IExPR0lOX0VSUk9SID0gJ0xPR0lOX0VSUk9SJztcblxuZXhwb3J0IGNvbnN0IEZFVENIX1RBU0tTID0gJ0ZFVENIX1RBU0tTJztcbmV4cG9ydCBjb25zdCBGRVRDSF9UQVNLU19FUlJPUiA9ICdGRVRDSF9UQVNLU19FUlJPUic7XG5leHBvcnQgY29uc3QgRkVUQ0hfVEFTS19ERVRBSUwgPSAnRkVUQ0hfVEFTS19ERVRBSUwnO1xuZXhwb3J0IGNvbnN0IEZFVENIX1RBU0tfREVUQUlMX0VSUk9SID0gJ0ZFVENIX1RBU0tfREVUQUlMX0VSUk9SJztcbmV4cG9ydCBjb25zdCBISURFX0RFVEFJTF9XSU5ET1cgPSAnSElERV9ERVRBSUxfV0lORE9XJztcbmV4cG9ydCBjb25zdCBBRERfVEFTSyA9ICdBRERfVEFTSyc7XG5leHBvcnQgY29uc3QgQUREX1RBU0tfRVJST1IgPSAnQUREX1RBU0tfRVJST1InO1xuZXhwb3J0IGNvbnN0IERFTEVURV9UQVNLID0gJ0RFTEVURV9UQVNLJztcbmV4cG9ydCBjb25zdCBFRElUX1RBU0sgPSAnRURJVF9UQVNLJztcbmV4cG9ydCBjb25zdCBDT01QTEVURV9UQVNLID0gJ0NPTVBMRVRFX1RBU0snO1xuXG4vLyBsaXN0IOebuOWFs1xuZXhwb3J0IGNvbnN0IEZFVENIX0xJU1RTID0gJ0ZFVENIX0xJU1RTJztcbmV4cG9ydCBjb25zdCBGRVRDSF9MSVNUU19FUlJPUiA9ICdGRVRDSF9MSVNUU19FUlJPUic7XG5leHBvcnQgY29uc3QgQUREX0xJU1QgPSAnQUREX0xJU1QnO1xuZXhwb3J0IGNvbnN0IEFERF9MSVNUX0VSUk9SID0gJ0FERF9MSVNUX0VSUk9SJztcbmV4cG9ydCBjb25zdCBFRElUX0xJU1QgPSAnRURJVF9MSVNUJztcbmV4cG9ydCBjb25zdCBERUxFVEVfTElTVCA9ICdERUxFVEVfTElTVCc7XG5leHBvcnQgY29uc3QgREVMRVRFX0xJU1RfRVJST1IgPSAnREVMRVRFX0xJU1RfRVJST1InO1xuXG5leHBvcnQgY29uc3QgVVBEQVRFX0xJU1QgPSAnVVBEQVRFX0xJU1QnO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc3JjL3Z1ZXgvbXV0YXRpb25UeXBlLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _superagentPrefix = __webpack_require__(17);\n\nvar _superagentPrefix2 = _interopRequireDefault(_superagentPrefix);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar baseURL = (0, _superagentPrefix2.default)('http://localhost:1234/api');\n\nexports.default = baseURL;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3Z1ZXgvYWN0aW9ucy9iYXNlLmpzPzQ1ZTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7OztBQUVBLElBQUksVUFBVSxnQ0FBWSwyQkFBWixDQUFkOztrQkFFZSxPIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFnZW50UHJlZml4IGZyb20gJ3N1cGVyYWdlbnQtcHJlZml4JztcblxubGV0IGJhc2VVUkwgPSBhZ2VudFByZWZpeCgnaHR0cDovL2xvY2FsaG9zdDoxMjM0L2FwaScpO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlVVJMO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc3JjL3Z1ZXgvYWN0aW9ucy9iYXNlLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("module.exports = function (prefix) {\n    return function (request) {\n        if (request.url[0] === '/') {\n            request.url = prefix + request.url;\n        }\n\n        return request;\n    };\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N1cGVyYWdlbnQtcHJlZml4L2luZGV4LmpzP2UxNzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QudXJsWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgIHJlcXVlc3QudXJsID0gcHJlZml4ICsgcmVxdWVzdC51cmw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N1cGVyYWdlbnQtcHJlZml4L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 18 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar getUserInfo = exports.getUserInfo = function getUserInfo(state) {\n  return state.user.data;\n};\n\nvar getUserAuth = exports.getUserAuth = function getUserAuth(state) {\n  return state.user.auth;\n};\n\nvar getLists = exports.getLists = function getLists(state) {\n  return state.lists.all;\n};\n\nvar getTasks = exports.getTasks = function getTasks(state) {\n  return state.tasks.all;\n};\n\nvar isShowDetail = exports.isShowDetail = function isShowDetail(state) {\n  return state.tasks.showDetail;\n};\n\nvar getTaskDetail = exports.getTaskDetail = function getTaskDetail(state) {\n  return state.tasks.taskDetail;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3Z1ZXgvZ2V0dGVyLmpzPzg4ZjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxJQUFNLG9DQUFjLFNBQWQsV0FBYyxDQUFDLEtBQUQsRUFBVztBQUNwQyxTQUFPLE1BQU0sSUFBTixDQUFXLElBQWxCO0FBQ0QsQ0FGTTs7QUFJQSxJQUFNLG9DQUFjLFNBQWQsV0FBYyxDQUFDLEtBQUQsRUFBVztBQUNwQyxTQUFPLE1BQU0sSUFBTixDQUFXLElBQWxCO0FBQ0QsQ0FGTTs7QUFJQSxJQUFNLDhCQUFXLFNBQVgsUUFBVyxDQUFDLEtBQUQsRUFBVztBQUNqQyxTQUFPLE1BQU0sS0FBTixDQUFZLEdBQW5CO0FBQ0QsQ0FGTTs7QUFJQSxJQUFNLDhCQUFXLFNBQVgsUUFBVyxDQUFDLEtBQUQsRUFBVztBQUNqQyxTQUFPLE1BQU0sS0FBTixDQUFZLEdBQW5CO0FBQ0QsQ0FGTTs7QUFJQSxJQUFNLHNDQUFlLFNBQWYsWUFBZSxDQUFDLEtBQUQsRUFBVztBQUNyQyxTQUFPLE1BQU0sS0FBTixDQUFZLFVBQW5CO0FBQ0QsQ0FGTTs7QUFJQSxJQUFNLHdDQUFnQixTQUFoQixhQUFnQixDQUFDLEtBQUQsRUFBVztBQUN0QyxTQUFPLE1BQU0sS0FBTixDQUFZLFVBQW5CO0FBQ0QsQ0FGTSIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBnZXRVc2VySW5mbyA9IChzdGF0ZSkgPT4ge1xuICByZXR1cm4gc3RhdGUudXNlci5kYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFVzZXJBdXRoID0gKHN0YXRlKSA9PiB7XG4gIHJldHVybiBzdGF0ZS51c2VyLmF1dGg7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0TGlzdHMgPSAoc3RhdGUpID0+IHtcbiAgcmV0dXJuIHN0YXRlLmxpc3RzLmFsbDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRUYXNrcyA9IChzdGF0ZSkgPT4ge1xuICByZXR1cm4gc3RhdGUudGFza3MuYWxsO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzU2hvd0RldGFpbCA9IChzdGF0ZSkgPT4ge1xuICByZXR1cm4gc3RhdGUudGFza3Muc2hvd0RldGFpbDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRUYXNrRGV0YWlsID0gKHN0YXRlKSA9PiB7XG4gIHJldHVybiBzdGF0ZS50YXNrcy50YXNrRGV0YWlsO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NyYy92dWV4L2dldHRlci5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 19 */
/***/ function(module, exports) {

	eval("module.exports = \"\\n<div class=\\\"sidebar\\\">\\n  <ul class=\\\"side-menu\\\">\\n    <li v-for=\\\"list in lists\\\">\\n      <a class=\\\"side-menu__item\\\" v-link=\\\"{name: 'list', params: {id: list.id}}\\\">\\n        <span class=\\\"material-icons\\\">list</span>\\n        <span class=\\\"side-menu__item-content\\\">{{list.name}}</span>\\n        <span class=\\\"side-menu__item-count\\\">{{list.task_count_total - list.task_count_completed || ''}}</span>\\n        <span class=\\\"material-icons edit\\\" @click=\\\"showCurrent(e, list)\\\">edit</span>\\n      </a>\\n    </li>\\n  </ul>\\n  <div class=\\\"side-actions\\\">\\n    <span class=\\\"side-menu__item\\\" @click=\\\"showModal = true\\\">\\n      <span class=\\\"material-icons\\\">add</span>\\n      <span class=\\\"side-menu__item-content\\\">新建分类</span>\\n    </span>\\n  </div>\\n\\n</div>\\n<modal :show=\\\"showModal\\\">\\n  <div slot=\\\"content\\\" class=\\\"list-editor\\\">\\n    <div class=\\\"list-editor-header\\\">\\n      <h3 class=\\\"list-editor-header--title\\\">创建新的清单</h3>\\n    </div>\\n    <div class=\\\"list-editor-body\\\">\\n      <div class=\\\"robin-textfield\\\">\\n        <input type=\\\"text\\\" class=\\\"robin-textfield--input robin-textfield--input_default\\\" v-model=\\\"newList.name\\\"/>\\n      </div>\\n    </div>\\n    <div class=\\\"list-editor-footer\\\">\\n      <span></span>\\n      <button class=\\\"robin-btn robin-btn__default\\\" @click=\\\"createNewList\\\">创建</button>\\n    </div>\\n  </div>\\n</modal>\\n<modal :show=\\\"showCurrentList\\\">\\n  <div slot=\\\"content\\\" class=\\\"list-editor\\\">\\n    <div class=\\\"list-editor-header\\\">\\n      <h3 class=\\\"list-editor-header--title\\\">编辑清单</h3>\\n    </div>\\n    <div class=\\\"list-editor-body\\\">\\n      <div class=\\\"robin-textfield\\\">\\n        <input type=\\\"text\\\" class=\\\"robin-textfield--input robin-textfield--input_default\\\" v-model=\\\"currentList.name\\\"/>\\n      </div>\\n    </div>\\n    <div class=\\\"list-editor-footer\\\">\\n      <span class=\\\"material-icons\\\" @click=\\\"deleteList(this.currentList)\\\">delete</span>\\n      <button class=\\\"robin-btn robin-btn__default\\\" @click=\\\"doEditList\\\">确定</button>\\n    </div>\\n  </div>\\n</modal>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay9zaWRlbWVudS52dWU/ZDNjMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx3SkFBd0osdUJBQXVCLGFBQWEsMkdBQTJHLFdBQVcseURBQXlELHlEQUF5RCIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJzaWRlYmFyXFxcIj5cXG4gIDx1bCBjbGFzcz1cXFwic2lkZS1tZW51XFxcIj5cXG4gICAgPGxpIHYtZm9yPVxcXCJsaXN0IGluIGxpc3RzXFxcIj5cXG4gICAgICA8YSBjbGFzcz1cXFwic2lkZS1tZW51X19pdGVtXFxcIiB2LWxpbms9XFxcIntuYW1lOiAnbGlzdCcsIHBhcmFtczoge2lkOiBsaXN0LmlkfX1cXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm1hdGVyaWFsLWljb25zXFxcIj5saXN0PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNpZGUtbWVudV9faXRlbS1jb250ZW50XFxcIj57e2xpc3QubmFtZX19PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNpZGUtbWVudV9faXRlbS1jb3VudFxcXCI+e3tsaXN0LnRhc2tfY291bnRfdG90YWwgLSBsaXN0LnRhc2tfY291bnRfY29tcGxldGVkIHx8ICcnfX08L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwibWF0ZXJpYWwtaWNvbnMgZWRpdFxcXCIgQGNsaWNrPVxcXCJzaG93Q3VycmVudChlLCBsaXN0KVxcXCI+ZWRpdDwvc3Bhbj5cXG4gICAgICA8L2E+XFxuICAgIDwvbGk+XFxuICA8L3VsPlxcbiAgPGRpdiBjbGFzcz1cXFwic2lkZS1hY3Rpb25zXFxcIj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcInNpZGUtbWVudV9faXRlbVxcXCIgQGNsaWNrPVxcXCJzaG93TW9kYWwgPSB0cnVlXFxcIj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwibWF0ZXJpYWwtaWNvbnNcXFwiPmFkZDwvc3Bhbj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwic2lkZS1tZW51X19pdGVtLWNvbnRlbnRcXFwiPuaWsOW7uuWIhuexuzwvc3Bhbj5cXG4gICAgPC9zcGFuPlxcbiAgPC9kaXY+XFxuXFxuPC9kaXY+XFxuPG1vZGFsIDpzaG93PVxcXCJzaG93TW9kYWxcXFwiPlxcbiAgPGRpdiBzbG90PVxcXCJjb250ZW50XFxcIiBjbGFzcz1cXFwibGlzdC1lZGl0b3JcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsaXN0LWVkaXRvci1oZWFkZXJcXFwiPlxcbiAgICAgIDxoMyBjbGFzcz1cXFwibGlzdC1lZGl0b3ItaGVhZGVyLS10aXRsZVxcXCI+5Yib5bu65paw55qE5riF5Y2VPC9oMz5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImxpc3QtZWRpdG9yLWJvZHlcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInJvYmluLXRleHRmaWVsZFxcXCI+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcInJvYmluLXRleHRmaWVsZC0taW5wdXQgcm9iaW4tdGV4dGZpZWxkLS1pbnB1dF9kZWZhdWx0XFxcIiB2LW1vZGVsPVxcXCJuZXdMaXN0Lm5hbWVcXFwiLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImxpc3QtZWRpdG9yLWZvb3RlclxcXCI+XFxuICAgICAgPHNwYW4+PC9zcGFuPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcInJvYmluLWJ0biByb2Jpbi1idG5fX2RlZmF1bHRcXFwiIEBjbGljaz1cXFwiY3JlYXRlTmV3TGlzdFxcXCI+5Yib5bu6PC9idXR0b24+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9tb2RhbD5cXG48bW9kYWwgOnNob3c9XFxcInNob3dDdXJyZW50TGlzdFxcXCI+XFxuICA8ZGl2IHNsb3Q9XFxcImNvbnRlbnRcXFwiIGNsYXNzPVxcXCJsaXN0LWVkaXRvclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImxpc3QtZWRpdG9yLWhlYWRlclxcXCI+XFxuICAgICAgPGgzIGNsYXNzPVxcXCJsaXN0LWVkaXRvci1oZWFkZXItLXRpdGxlXFxcIj7nvJbovpHmuIXljZU8L2gzPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibGlzdC1lZGl0b3ItYm9keVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicm9iaW4tdGV4dGZpZWxkXFxcIj5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwicm9iaW4tdGV4dGZpZWxkLS1pbnB1dCByb2Jpbi10ZXh0ZmllbGQtLWlucHV0X2RlZmF1bHRcXFwiIHYtbW9kZWw9XFxcImN1cnJlbnRMaXN0Lm5hbWVcXFwiLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImxpc3QtZWRpdG9yLWZvb3RlclxcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcIm1hdGVyaWFsLWljb25zXFxcIiBAY2xpY2s9XFxcImRlbGV0ZUxpc3QodGhpcy5jdXJyZW50TGlzdClcXFwiPmRlbGV0ZTwvc3Bhbj5cXG4gICAgICA8YnV0dG9uIGNsYXNzPVxcXCJyb2Jpbi1idG4gcm9iaW4tYnRuX19kZWZhdWx0XFxcIiBAY2xpY2s9XFxcImRvRWRpdExpc3RcXFwiPuehruWumjwvYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvbW9kYWw+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay9zaWRlbWVudS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _vue = __webpack_require__(1);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _vuex = __webpack_require__(21);\n\nvar _vuex2 = _interopRequireDefault(_vuex);\n\nvar _logger = __webpack_require__(22);\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _user = __webpack_require__(23);\n\nvar _user2 = _interopRequireDefault(_user);\n\nvar _lists = __webpack_require__(43);\n\nvar _lists2 = _interopRequireDefault(_lists);\n\nvar _tasks = __webpack_require__(44);\n\nvar _tasks2 = _interopRequireDefault(_tasks);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_vue2.default.use(_vuex2.default);\n_vue2.default.config.debug = true;\nvar debug = (\"development\") !== 'production';\n\nvar logger = (0, _logger2.default)({\n  collapsed: false, // 自动展开输出的 mutations\n  transformer: function transformer(state) {\n    // 输出前对 state 进行转换\n    // 比如说只返回一个 sub-tree\n    return state;\n  },\n  mutationTransformer: function mutationTransformer(mutation) {\n    // mutations 会格式化为 { type, payload } 输出\n    // 我们可以按照自己的需求格式化成任何我们想要的结构\n    return mutation.type;\n  }\n});\n\nvar myMiddleware = {\n  onInit: function onInit(state) {\n    // 记录初始 state\n    console.log('middlewares');\n  },\n  onMutation: function onMutation(mutation, state) {\n    // 每个 mutation 后会被调用\n    // mutation 参数的格式为 { type, payload }\n    console.log('------>mutation');\n  }\n};\n\n// 整合初始状态和变更函数，我们就得到了我们所需的 store\n// 至此，这个 store 就可以连接到我们的应用中\nexports.default = new _vuex2.default.Store({\n  modules: {\n    user: _user2.default,\n    lists: _lists2.default,\n    tasks: _tasks2.default\n  },\n  middlewares: [myMiddleware]\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3Z1ZXgvc3RvcmUuanM/M2M0NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFNQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQU5BLGNBQUksR0FBSjtBQUNBLGNBQUksTUFBSixDQUFXLEtBQVgsR0FBbUIsSUFBbkI7QUFDQSxJQUFNLFFBQVEsb0JBQXlCLFlBQXZDOztBQU1BLElBQU0sU0FBUyxzQkFBYTtBQUMxQixhQUFXLEtBRGUsRUFDUjtBQUNsQixhQUYwQix1QkFFZCxLQUZjLEVBRVA7QUFDakI7QUFDQTtBQUNBLFdBQU8sS0FBUDtBQUNELEdBTnlCO0FBTzFCLHFCQVAwQiwrQkFPTixRQVBNLEVBT0k7QUFDNUI7QUFDQTtBQUNBLFdBQU8sU0FBUyxJQUFoQjtBQUNEO0FBWHlCLENBQWIsQ0FBZjs7QUFjQSxJQUFNLGVBQWU7QUFDbkIsUUFEbUIsa0JBQ1osS0FEWSxFQUNMO0FBQ1o7QUFDQSxZQUFRLEdBQVIsQ0FBWSxhQUFaO0FBQ0QsR0FKa0I7QUFLbkIsWUFMbUIsc0JBS1IsUUFMUSxFQUtFLEtBTEYsRUFLUztBQUMxQjtBQUNBO0FBQ0EsWUFBUSxHQUFSLENBQVksaUJBQVo7QUFDRDtBQVRrQixDQUFyQjs7QUFZQTtBQUNBO2tCQUNlLElBQUksZUFBSyxLQUFULENBQWU7QUFDNUIsV0FBUztBQUNQLHdCQURPO0FBRVAsMEJBRk87QUFHUDtBQUhPLEdBRG1CO0FBTTVCLGVBQWEsQ0FBQyxZQUFEO0FBTmUsQ0FBZixDIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IFZ1ZXggZnJvbSAndnVleCc7XG5pbXBvcnQgY3JlYXRlTG9nZ2VyIGZyb20gJ3Z1ZXgvbG9nZ2VyJztcblxuVnVlLnVzZShWdWV4KTtcblZ1ZS5jb25maWcuZGVidWcgPSB0cnVlO1xuY29uc3QgZGVidWcgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nO1xuXG5pbXBvcnQgdXNlciBmcm9tICcuL21vZHVsZXMvdXNlcic7XG5pbXBvcnQgbGlzdHMgZnJvbSAnLi9tb2R1bGVzL2xpc3RzJztcbmltcG9ydCB0YXNrcyBmcm9tICcuL21vZHVsZXMvdGFza3MnO1xuXG5jb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICBjb2xsYXBzZWQ6IGZhbHNlLCAvLyDoh6rliqjlsZXlvIDovpPlh7rnmoQgbXV0YXRpb25zXG4gIHRyYW5zZm9ybWVyKHN0YXRlKSB7XG4gICAgLy8g6L6T5Ye65YmN5a+5IHN0YXRlIOi/m+ihjOi9rOaNolxuICAgIC8vIOavlOWmguivtOWPqui/lOWbnuS4gOS4qiBzdWItdHJlZVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfSxcbiAgbXV0YXRpb25UcmFuc2Zvcm1lcihtdXRhdGlvbikge1xuICAgIC8vIG11dGF0aW9ucyDkvJrmoLzlvI/ljJbkuLogeyB0eXBlLCBwYXlsb2FkIH0g6L6T5Ye6XG4gICAgLy8g5oiR5Lus5Y+v5Lul5oyJ54Wn6Ieq5bex55qE6ZyA5rGC5qC85byP5YyW5oiQ5Lu75L2V5oiR5Lus5oOz6KaB55qE57uT5p6EXG4gICAgcmV0dXJuIG11dGF0aW9uLnR5cGU7XG4gIH1cbn0pO1xuXG5jb25zdCBteU1pZGRsZXdhcmUgPSB7XG4gIG9uSW5pdChzdGF0ZSkge1xuICAgIC8vIOiusOW9leWIneWniyBzdGF0ZVxuICAgIGNvbnNvbGUubG9nKCdtaWRkbGV3YXJlcycpO1xuICB9LFxuICBvbk11dGF0aW9uKG11dGF0aW9uLCBzdGF0ZSkge1xuICAgIC8vIOavj+S4qiBtdXRhdGlvbiDlkI7kvJrooqvosIPnlKhcbiAgICAvLyBtdXRhdGlvbiDlj4LmlbDnmoTmoLzlvI/kuLogeyB0eXBlLCBwYXlsb2FkIH1cbiAgICBjb25zb2xlLmxvZygnLS0tLS0tPm11dGF0aW9uJyk7XG4gIH1cbn07XG5cbi8vIOaVtOWQiOWIneWni+eKtuaAgeWSjOWPmOabtOWHveaVsO+8jOaIkeS7rOWwseW+l+WIsOS6huaIkeS7rOaJgOmcgOeahCBzdG9yZVxuLy8g6Iez5q2k77yM6L+Z5LiqIHN0b3JlIOWwseWPr+S7pei/nuaOpeWIsOaIkeS7rOeahOW6lOeUqOS4rVxuZXhwb3J0IGRlZmF1bHQgbmV3IFZ1ZXguU3RvcmUoe1xuICBtb2R1bGVzOiB7XG4gICAgdXNlcixcbiAgICBsaXN0cyxcbiAgICB0YXNrcyxcbiAgfSxcbiAgbWlkZGxld2FyZXM6IFtteU1pZGRsZXdhcmVdLFxufSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9zcmMvdnVleC9zdG9yZS5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * Vuex v1.0.0-rc.2\n * (c) 2016 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Vuex = factory());\n}(this, function () { 'use strict';\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n  };\n\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n  /**\n   * Merge an array of objects into one.\n   *\n   * @param {Array<Object>} arr\n   * @return {Object}\n   */\n\n  function mergeObjects(arr) {\n    return arr.reduce(function (prev, obj) {\n      Object.keys(obj).forEach(function (key) {\n        var existing = prev[key];\n        if (existing) {\n          // allow multiple mutation objects to contain duplicate\n          // handlers for the same mutation type\n          if (Array.isArray(existing)) {\n            prev[key] = existing.concat(obj[key]);\n          } else {\n            prev[key] = [existing].concat(obj[key]);\n          }\n        } else {\n          prev[key] = obj[key];\n        }\n      });\n      return prev;\n    }, {});\n  }\n\n  /**\n   * Check whether the given value is Object or not\n   *\n   * @param {*} obj\n   * @return {Boolean}\n   */\n\n  function isObject(obj) {\n    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n  }\n\n  /**\n   * Get state sub tree by given keys.\n   *\n   * @param {Object} state\n   * @param {Array<String>} nestedKeys\n   * @return {Object}\n   */\n  function getNestedState(state, nestedKeys) {\n    return nestedKeys.reduce(function (state, key) {\n      return state[key];\n    }, state);\n  }\n\n  /**\n   * Hacks to get access to Vue internals.\n   * Maybe we should expose these...\n   */\n\n  var Watcher = void 0;\n  function getWatcher(vm) {\n    if (!Watcher) {\n      var noop = function noop() {};\n      var unwatch = vm.$watch(noop, noop);\n      Watcher = vm._watchers[0].constructor;\n      unwatch();\n    }\n    return Watcher;\n  }\n\n  var Dep = void 0;\n  function getDep(vm) {\n    if (!Dep) {\n      Dep = vm._data.__ob__.dep.constructor;\n    }\n    return Dep;\n  }\n\n  var hook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  function devtoolPlugin(store) {\n    if (!hook) return;\n\n    hook.emit('vuex:init', store);\n\n    hook.on('vuex:travel-to-state', function (targetState) {\n      store.replaceState(targetState);\n    });\n\n    store.subscribe(function (mutation, state) {\n      hook.emit('vuex:mutation', mutation, state);\n    });\n  }\n\n  function override (Vue) {\n    var version = Number(Vue.version.split('.')[0]);\n\n    if (version >= 2) {\n      var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;\n      Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });\n    } else {\n      (function () {\n        // override init and inject vuex init procedure\n        // for 1.x backwards compatibility.\n        var _init = Vue.prototype._init;\n        Vue.prototype._init = function () {\n          var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n          options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;\n          _init.call(this, options);\n        };\n      })();\n    }\n\n    /**\n     * Vuex init hook, injected into each instances init hooks list.\n     */\n\n    function vuexInit() {\n      var options = this.$options;\n      var store = options.store;\n      var vuex = options.vuex;\n      // store injection\n\n      if (store) {\n        this.$store = store;\n      } else if (options.parent && options.parent.$store) {\n        this.$store = options.parent.$store;\n      }\n      // vuex option handling\n      if (vuex) {\n        if (!this.$store) {\n          console.warn('[vuex] store not injected. make sure to ' + 'provide the store option in your root component.');\n        }\n        var state = vuex.state;\n        var actions = vuex.actions;\n        var getters = vuex.getters;\n        // handle deprecated state option\n\n        if (state && !getters) {\n          console.warn('[vuex] vuex.state option will been deprecated in 1.0. ' + 'Use vuex.getters instead.');\n          getters = state;\n        }\n        // getters\n        if (getters) {\n          options.computed = options.computed || {};\n          for (var key in getters) {\n            defineVuexGetter(this, key, getters[key]);\n          }\n        }\n        // actions\n        if (actions) {\n          options.methods = options.methods || {};\n          for (var _key in actions) {\n            options.methods[_key] = makeBoundAction(this.$store, actions[_key], _key);\n          }\n        }\n      }\n    }\n\n    /**\n     * Setter for all getter properties.\n     */\n\n    function setter() {\n      throw new Error('vuex getter properties are read-only.');\n    }\n\n    /**\n     * Define a Vuex getter on an instance.\n     *\n     * @param {Vue} vm\n     * @param {String} key\n     * @param {Function} getter\n     */\n\n    function defineVuexGetter(vm, key, getter) {\n      if (typeof getter !== 'function') {\n        console.warn('[vuex] Getter bound to key \\'vuex.getters.' + key + '\\' is not a function.');\n      } else {\n        Object.defineProperty(vm, key, {\n          enumerable: true,\n          configurable: true,\n          get: makeComputedGetter(vm.$store, getter),\n          set: setter\n        });\n      }\n    }\n\n    /**\n     * Make a computed getter, using the same caching mechanism of computed\n     * properties. In addition, it is cached on the raw getter function using\n     * the store's unique cache id. This makes the same getter shared\n     * across all components use the same underlying watcher, and makes\n     * the getter evaluated only once during every flush.\n     *\n     * @param {Store} store\n     * @param {Function} getter\n     */\n\n    function makeComputedGetter(store, getter) {\n      var id = store._getterCacheId;\n\n      // cached\n      if (getter[id]) {\n        return getter[id];\n      }\n      var vm = store._vm;\n      var Watcher = getWatcher(vm);\n      var Dep = getDep(vm);\n      var watcher = new Watcher(vm, function (vm) {\n        return getter(vm.state);\n      }, null, { lazy: true });\n      var computedGetter = function computedGetter() {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value;\n      };\n      getter[id] = computedGetter;\n      return computedGetter;\n    }\n\n    /**\n     * Make a bound-to-store version of a raw action function.\n     *\n     * @param {Store} store\n     * @param {Function} action\n     * @param {String} key\n     */\n\n    function makeBoundAction(store, action, key) {\n      if (typeof action !== 'function') {\n        console.warn('[vuex] Action bound to key \\'vuex.actions.' + key + '\\' is not a function.');\n      }\n      return function vuexBoundAction() {\n        for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return action.call.apply(action, [this, store].concat(args));\n      };\n    }\n\n    // option merging\n    var merge = Vue.config.optionMergeStrategies.computed;\n    Vue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {\n      if (!toVal) return fromVal;\n      if (!fromVal) return toVal;\n      return {\n        getters: merge(toVal.getters, fromVal.getters),\n        state: merge(toVal.state, fromVal.state),\n        actions: merge(toVal.actions, fromVal.actions)\n      };\n    };\n  }\n\n  var Vue = void 0;\n  var uid = 0;\n\n  var Store = function () {\n\n    /**\n     * @param {Object} options\n     *        - {Object} state\n     *        - {Object} actions\n     *        - {Object} mutations\n     *        - {Array} plugins\n     *        - {Boolean} strict\n     */\n\n    function Store() {\n      var _this = this;\n\n      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref$state = _ref.state;\n      var state = _ref$state === undefined ? {} : _ref$state;\n      var _ref$mutations = _ref.mutations;\n      var mutations = _ref$mutations === undefined ? {} : _ref$mutations;\n      var _ref$modules = _ref.modules;\n      var modules = _ref$modules === undefined ? {} : _ref$modules;\n      var _ref$plugins = _ref.plugins;\n      var plugins = _ref$plugins === undefined ? [] : _ref$plugins;\n      var _ref$strict = _ref.strict;\n      var strict = _ref$strict === undefined ? false : _ref$strict;\n      classCallCheck(this, Store);\n\n      this._getterCacheId = 'vuex_store_' + uid++;\n      this._dispatching = false;\n      this._rootMutations = this._mutations = mutations;\n      this._modules = modules;\n      this._subscribers = [];\n      // bind dispatch to self\n      var dispatch = this.dispatch;\n      this.dispatch = function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        dispatch.apply(_this, args);\n      };\n      // use a Vue instance to store the state tree\n      // suppress warnings just in case the user has added\n      // some funky global mixins\n      if (!Vue) {\n        throw new Error('[vuex] must call Vue.use(Vuex) before creating a store instance.');\n      }\n      var silent = Vue.config.silent;\n      Vue.config.silent = true;\n      this._vm = new Vue({\n        data: {\n          state: state\n        }\n      });\n      Vue.config.silent = silent;\n      this._setupModuleState(state, modules);\n      this._setupModuleMutations(modules);\n      // add extra warnings in strict mode\n      if (strict) {\n        this._setupMutationCheck();\n      }\n      // apply plugins\n      devtoolPlugin(this);\n      plugins.forEach(function (plugin) {\n        return plugin(_this);\n      });\n    }\n\n    /**\n     * Getter for the entire state tree.\n     * Read only.\n     *\n     * @return {Object}\n     */\n\n    createClass(Store, [{\n      key: 'replaceState',\n\n\n      /**\n       * Replace root state.\n       *\n       * @param {Object} state\n       */\n\n      value: function replaceState(state) {\n        this._dispatching = true;\n        this._vm.state = state;\n        this._dispatching = false;\n      }\n\n      /**\n       * Dispatch an action.\n       *\n       * @param {String} type\n       */\n\n    }, {\n      key: 'dispatch',\n      value: function dispatch(type) {\n        var _this2 = this;\n\n        for (var _len2 = arguments.length, payload = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          payload[_key2 - 1] = arguments[_key2];\n        }\n\n        var silent = false;\n        var isObjectStyleDispatch = false;\n        // compatibility for object actions, e.g. FSA\n        if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type.type && arguments.length === 1) {\n          isObjectStyleDispatch = true;\n          payload = type;\n          if (type.silent) silent = true;\n          type = type.type;\n        }\n        var handler = this._mutations[type];\n        var state = this.state;\n        if (handler) {\n          this._dispatching = true;\n          // apply the mutation\n          if (Array.isArray(handler)) {\n            handler.forEach(function (h) {\n              isObjectStyleDispatch ? h(state, payload) : h.apply(undefined, [state].concat(toConsumableArray(payload)));\n            });\n          } else {\n            isObjectStyleDispatch ? handler(state, payload) : handler.apply(undefined, [state].concat(toConsumableArray(payload)));\n          }\n          this._dispatching = false;\n          if (!silent) {\n            (function () {\n              var mutation = isObjectStyleDispatch ? payload : { type: type, payload: payload };\n              _this2._subscribers.forEach(function (sub) {\n                return sub(mutation, state);\n              });\n            })();\n          }\n        } else {\n          console.warn('[vuex] Unknown mutation: ' + type);\n        }\n      }\n\n      /**\n       * Watch state changes on the store.\n       * Same API as Vue's $watch, except when watching a function,\n       * the function gets the state as the first argument.\n       *\n       * @param {Function} fn\n       * @param {Function} cb\n       * @param {Object} [options]\n       */\n\n    }, {\n      key: 'watch',\n      value: function watch(fn, cb, options) {\n        var _this3 = this;\n\n        if (typeof fn !== 'function') {\n          console.error('Vuex store.watch only accepts function.');\n          return;\n        }\n        return this._vm.$watch(function () {\n          return fn(_this3.state);\n        }, cb, options);\n      }\n\n      /**\n       * Subscribe to state changes. Fires after every mutation.\n       */\n\n    }, {\n      key: 'subscribe',\n      value: function subscribe(fn) {\n        var subs = this._subscribers;\n        if (subs.indexOf(fn) < 0) {\n          subs.push(fn);\n        }\n        return function () {\n          var i = subs.indexOf(fn);\n          if (i > -1) {\n            subs.splice(i, 1);\n          }\n        };\n      }\n\n      /**\n       * Hot update mutations & modules.\n       *\n       * @param {Object} options\n       *        - {Object} [mutations]\n       *        - {Object} [modules]\n       */\n\n    }, {\n      key: 'hotUpdate',\n      value: function hotUpdate() {\n        var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n        var mutations = _ref2.mutations;\n        var modules = _ref2.modules;\n\n        this._rootMutations = this._mutations = mutations || this._rootMutations;\n        this._setupModuleMutations(modules || this._modules);\n      }\n\n      /**\n       * Attach sub state tree of each module to the root tree.\n       *\n       * @param {Object} state\n       * @param {Object} modules\n       */\n\n    }, {\n      key: '_setupModuleState',\n      value: function _setupModuleState(state, modules) {\n        var _this4 = this;\n\n        if (!isObject(modules)) return;\n\n        Object.keys(modules).forEach(function (key) {\n          var module = modules[key];\n\n          // set this module's state\n          Vue.set(state, key, module.state || {});\n\n          // retrieve nested modules\n          _this4._setupModuleState(state[key], module.modules);\n        });\n      }\n\n      /**\n       * Bind mutations for each module to its sub tree and\n       * merge them all into one final mutations map.\n       *\n       * @param {Object} updatedModules\n       */\n\n    }, {\n      key: '_setupModuleMutations',\n      value: function _setupModuleMutations(updatedModules) {\n        var modules = this._modules;\n        Object.keys(updatedModules).forEach(function (key) {\n          modules[key] = updatedModules[key];\n        });\n        var updatedMutations = this._createModuleMutations(modules, []);\n        this._mutations = mergeObjects([this._rootMutations].concat(toConsumableArray(updatedMutations)));\n      }\n\n      /**\n       * Helper method for _setupModuleMutations.\n       * The method retrieve nested sub modules and\n       * bind each mutations to its sub tree recursively.\n       *\n       * @param {Object} modules\n       * @param {Array<String>} nestedKeys\n       * @return {Array<Object>}\n       */\n\n    }, {\n      key: '_createModuleMutations',\n      value: function _createModuleMutations(modules, nestedKeys) {\n        var _this5 = this;\n\n        if (!isObject(modules)) return [];\n\n        return Object.keys(modules).map(function (key) {\n          var module = modules[key];\n          var newNestedKeys = nestedKeys.concat(key);\n\n          // retrieve nested modules\n          var nestedMutations = _this5._createModuleMutations(module.modules, newNestedKeys);\n\n          if (!module || !module.mutations) {\n            return mergeObjects(nestedMutations);\n          }\n\n          // bind mutations to sub state tree\n          var mutations = {};\n          Object.keys(module.mutations).forEach(function (name) {\n            var original = module.mutations[name];\n            mutations[name] = function (state) {\n              for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                args[_key3 - 1] = arguments[_key3];\n              }\n\n              original.apply(undefined, [getNestedState(state, newNestedKeys)].concat(args));\n            };\n          });\n\n          // merge mutations of this module and nested modules\n          return mergeObjects([mutations].concat(toConsumableArray(nestedMutations)));\n        });\n      }\n\n      /**\n       * Setup mutation check: if the vuex instance's state is mutated\n       * outside of a mutation handler, we throw en error. This effectively\n       * enforces all mutations to the state to be trackable and hot-reloadble.\n       * However, this comes at a run time cost since we are doing a deep\n       * watch on the entire state tree, so it is only enalbed with the\n       * strict option is set to true.\n       */\n\n    }, {\n      key: '_setupMutationCheck',\n      value: function _setupMutationCheck() {\n        var _this6 = this;\n\n        var Watcher = getWatcher(this._vm);\n        /* eslint-disable no-new */\n        new Watcher(this._vm, 'state', function () {\n          if (!_this6._dispatching) {\n            throw new Error('[vuex] Do not mutate vuex store state outside mutation handlers.');\n          }\n        }, { deep: true, sync: true });\n        /* eslint-enable no-new */\n      }\n    }, {\n      key: 'state',\n      get: function get() {\n        return this._vm.state;\n      },\n      set: function set(v) {\n        throw new Error('[vuex] Use store.replaceState() to explicit replace store state.');\n      }\n    }]);\n    return Store;\n  }();\n\n  function install(_Vue) {\n    if (Vue) {\n      console.warn('[vuex] already installed. Vue.use(Vuex) should be called only once.');\n      return;\n    }\n    Vue = _Vue;\n    override(Vue);\n  }\n\n  // auto install in dist mode\n  if (typeof window !== 'undefined' && window.Vue) {\n    install(window.Vue);\n  }\n\n  var index = {\n    Store: Store,\n    install: install\n  };\n\n  return index;\n\n}));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZXgvZGlzdC92dWV4LmpzPzkwY2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7O0FBRXJCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCOztBQUUvRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxjQUFjO0FBQzNCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Es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Q0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVleCB2MS4wLjAtcmMuMlxuICogKGMpIDIwMTYgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsLlZ1ZXggPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH07XG5cbiAgdmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICAgIHJldHVybiBhcnIyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTWVyZ2UgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBhcnJcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBtZXJnZU9iamVjdHMoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG9iaikge1xuICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gcHJldltrZXldO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAvLyBhbGxvdyBtdWx0aXBsZSBtdXRhdGlvbiBvYmplY3RzIHRvIGNvbnRhaW4gZHVwbGljYXRlXG4gICAgICAgICAgLy8gaGFuZGxlcnMgZm9yIHRoZSBzYW1lIG11dGF0aW9uIHR5cGVcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgIHByZXZba2V5XSA9IGV4aXN0aW5nLmNvbmNhdChvYmpba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZba2V5XSA9IFtleGlzdGluZ10uY29uY2F0KG9ialtrZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldltrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIE9iamVjdCBvciBub3RcbiAgICpcbiAgICogQHBhcmFtIHsqfSBvYmpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgPT09ICdvYmplY3QnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzdGF0ZSBzdWIgdHJlZSBieSBnaXZlbiBrZXlzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBuZXN0ZWRLZXlzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldE5lc3RlZFN0YXRlKHN0YXRlLCBuZXN0ZWRLZXlzKSB7XG4gICAgcmV0dXJuIG5lc3RlZEtleXMucmVkdWNlKGZ1bmN0aW9uIChzdGF0ZSwga2V5KSB7XG4gICAgICByZXR1cm4gc3RhdGVba2V5XTtcbiAgICB9LCBzdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogSGFja3MgdG8gZ2V0IGFjY2VzcyB0byBWdWUgaW50ZXJuYWxzLlxuICAgKiBNYXliZSB3ZSBzaG91bGQgZXhwb3NlIHRoZXNlLi4uXG4gICAqL1xuXG4gIHZhciBXYXRjaGVyID0gdm9pZCAwO1xuICBmdW5jdGlvbiBnZXRXYXRjaGVyKHZtKSB7XG4gICAgaWYgKCFXYXRjaGVyKSB7XG4gICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbiAgICAgIHZhciB1bndhdGNoID0gdm0uJHdhdGNoKG5vb3AsIG5vb3ApO1xuICAgICAgV2F0Y2hlciA9IHZtLl93YXRjaGVyc1swXS5jb25zdHJ1Y3RvcjtcbiAgICAgIHVud2F0Y2goKTtcbiAgICB9XG4gICAgcmV0dXJuIFdhdGNoZXI7XG4gIH1cblxuICB2YXIgRGVwID0gdm9pZCAwO1xuICBmdW5jdGlvbiBnZXREZXAodm0pIHtcbiAgICBpZiAoIURlcCkge1xuICAgICAgRGVwID0gdm0uX2RhdGEuX19vYl9fLmRlcC5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIERlcDtcbiAgfVxuXG4gIHZhciBob29rID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgZnVuY3Rpb24gZGV2dG9vbFBsdWdpbihzdG9yZSkge1xuICAgIGlmICghaG9vaykgcmV0dXJuO1xuXG4gICAgaG9vay5lbWl0KCd2dWV4OmluaXQnLCBzdG9yZSk7XG5cbiAgICBob29rLm9uKCd2dWV4OnRyYXZlbC10by1zdGF0ZScsIGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuICAgICAgc3RvcmUucmVwbGFjZVN0YXRlKHRhcmdldFN0YXRlKTtcbiAgICB9KTtcblxuICAgIHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAobXV0YXRpb24sIHN0YXRlKSB7XG4gICAgICBob29rLmVtaXQoJ3Z1ZXg6bXV0YXRpb24nLCBtdXRhdGlvbiwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb3ZlcnJpZGUgKFZ1ZSkge1xuICAgIHZhciB2ZXJzaW9uID0gTnVtYmVyKFZ1ZS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pO1xuXG4gICAgaWYgKHZlcnNpb24gPj0gMikge1xuICAgICAgdmFyIHVzZXNJbml0ID0gVnVlLmNvbmZpZy5fbGlmZWN5Y2xlSG9va3MuaW5kZXhPZignaW5pdCcpID4gLTE7XG4gICAgICBWdWUubWl4aW4odXNlc0luaXQgPyB7IGluaXQ6IHZ1ZXhJbml0IH0gOiB7IGJlZm9yZUNyZWF0ZTogdnVleEluaXQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG92ZXJyaWRlIGluaXQgYW5kIGluamVjdCB2dWV4IGluaXQgcHJvY2VkdXJlXG4gICAgICAgIC8vIGZvciAxLnggYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIHZhciBfaW5pdCA9IFZ1ZS5wcm90b3R5cGUuX2luaXQ7XG4gICAgICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgIG9wdGlvbnMuaW5pdCA9IG9wdGlvbnMuaW5pdCA/IFt2dWV4SW5pdF0uY29uY2F0KG9wdGlvbnMuaW5pdCkgOiB2dWV4SW5pdDtcbiAgICAgICAgICBfaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWdWV4IGluaXQgaG9vaywgaW5qZWN0ZWQgaW50byBlYWNoIGluc3RhbmNlcyBpbml0IGhvb2tzIGxpc3QuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB2dWV4SW5pdCgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICAgIHZhciBzdG9yZSA9IG9wdGlvbnMuc3RvcmU7XG4gICAgICB2YXIgdnVleCA9IG9wdGlvbnMudnVleDtcbiAgICAgIC8vIHN0b3JlIGluamVjdGlvblxuXG4gICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgdGhpcy4kc3RvcmUgPSBzdG9yZTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQuJHN0b3JlKSB7XG4gICAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5wYXJlbnQuJHN0b3JlO1xuICAgICAgfVxuICAgICAgLy8gdnVleCBvcHRpb24gaGFuZGxpbmdcbiAgICAgIGlmICh2dWV4KSB7XG4gICAgICAgIGlmICghdGhpcy4kc3RvcmUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSBzdG9yZSBub3QgaW5qZWN0ZWQuIG1ha2Ugc3VyZSB0byAnICsgJ3Byb3ZpZGUgdGhlIHN0b3JlIG9wdGlvbiBpbiB5b3VyIHJvb3QgY29tcG9uZW50LicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHZ1ZXguc3RhdGU7XG4gICAgICAgIHZhciBhY3Rpb25zID0gdnVleC5hY3Rpb25zO1xuICAgICAgICB2YXIgZ2V0dGVycyA9IHZ1ZXguZ2V0dGVycztcbiAgICAgICAgLy8gaGFuZGxlIGRlcHJlY2F0ZWQgc3RhdGUgb3B0aW9uXG5cbiAgICAgICAgaWYgKHN0YXRlICYmICFnZXR0ZXJzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbdnVleF0gdnVleC5zdGF0ZSBvcHRpb24gd2lsbCBiZWVuIGRlcHJlY2F0ZWQgaW4gMS4wLiAnICsgJ1VzZSB2dWV4LmdldHRlcnMgaW5zdGVhZC4nKTtcbiAgICAgICAgICBnZXR0ZXJzID0gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0dGVyc1xuICAgICAgICBpZiAoZ2V0dGVycykge1xuICAgICAgICAgIG9wdGlvbnMuY29tcHV0ZWQgPSBvcHRpb25zLmNvbXB1dGVkIHx8IHt9O1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBnZXR0ZXJzKSB7XG4gICAgICAgICAgICBkZWZpbmVWdWV4R2V0dGVyKHRoaXMsIGtleSwgZ2V0dGVyc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWN0aW9uc1xuICAgICAgICBpZiAoYWN0aW9ucykge1xuICAgICAgICAgIG9wdGlvbnMubWV0aG9kcyA9IG9wdGlvbnMubWV0aG9kcyB8fCB7fTtcbiAgICAgICAgICBmb3IgKHZhciBfa2V5IGluIGFjdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kc1tfa2V5XSA9IG1ha2VCb3VuZEFjdGlvbih0aGlzLiRzdG9yZSwgYWN0aW9uc1tfa2V5XSwgX2tleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0dGVyIGZvciBhbGwgZ2V0dGVyIHByb3BlcnRpZXMuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBzZXR0ZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Z1ZXggZ2V0dGVyIHByb3BlcnRpZXMgYXJlIHJlYWQtb25seS4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgYSBWdWV4IGdldHRlciBvbiBhbiBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGRlZmluZVZ1ZXhHZXR0ZXIodm0sIGtleSwgZ2V0dGVyKSB7XG4gICAgICBpZiAodHlwZW9mIGdldHRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSBHZXR0ZXIgYm91bmQgdG8ga2V5IFxcJ3Z1ZXguZ2V0dGVycy4nICsga2V5ICsgJ1xcJyBpcyBub3QgYSBmdW5jdGlvbi4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2bSwga2V5LCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBtYWtlQ29tcHV0ZWRHZXR0ZXIodm0uJHN0b3JlLCBnZXR0ZXIpLFxuICAgICAgICAgIHNldDogc2V0dGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2UgYSBjb21wdXRlZCBnZXR0ZXIsIHVzaW5nIHRoZSBzYW1lIGNhY2hpbmcgbWVjaGFuaXNtIG9mIGNvbXB1dGVkXG4gICAgICogcHJvcGVydGllcy4gSW4gYWRkaXRpb24sIGl0IGlzIGNhY2hlZCBvbiB0aGUgcmF3IGdldHRlciBmdW5jdGlvbiB1c2luZ1xuICAgICAqIHRoZSBzdG9yZSdzIHVuaXF1ZSBjYWNoZSBpZC4gVGhpcyBtYWtlcyB0aGUgc2FtZSBnZXR0ZXIgc2hhcmVkXG4gICAgICogYWNyb3NzIGFsbCBjb21wb25lbnRzIHVzZSB0aGUgc2FtZSB1bmRlcmx5aW5nIHdhdGNoZXIsIGFuZCBtYWtlc1xuICAgICAqIHRoZSBnZXR0ZXIgZXZhbHVhdGVkIG9ubHkgb25jZSBkdXJpbmcgZXZlcnkgZmx1c2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0b3JlfSBzdG9yZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gbWFrZUNvbXB1dGVkR2V0dGVyKHN0b3JlLCBnZXR0ZXIpIHtcbiAgICAgIHZhciBpZCA9IHN0b3JlLl9nZXR0ZXJDYWNoZUlkO1xuXG4gICAgICAvLyBjYWNoZWRcbiAgICAgIGlmIChnZXR0ZXJbaWRdKSB7XG4gICAgICAgIHJldHVybiBnZXR0ZXJbaWRdO1xuICAgICAgfVxuICAgICAgdmFyIHZtID0gc3RvcmUuX3ZtO1xuICAgICAgdmFyIFdhdGNoZXIgPSBnZXRXYXRjaGVyKHZtKTtcbiAgICAgIHZhciBEZXAgPSBnZXREZXAodm0pO1xuICAgICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZnVuY3Rpb24gKHZtKSB7XG4gICAgICAgIHJldHVybiBnZXR0ZXIodm0uc3RhdGUpO1xuICAgICAgfSwgbnVsbCwgeyBsYXp5OiB0cnVlIH0pO1xuICAgICAgdmFyIGNvbXB1dGVkR2V0dGVyID0gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIoKSB7XG4gICAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcbiAgICAgIH07XG4gICAgICBnZXR0ZXJbaWRdID0gY29tcHV0ZWRHZXR0ZXI7XG4gICAgICByZXR1cm4gY29tcHV0ZWRHZXR0ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSBhIGJvdW5kLXRvLXN0b3JlIHZlcnNpb24gb2YgYSByYXcgYWN0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdG9yZX0gc3RvcmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBtYWtlQm91bmRBY3Rpb24oc3RvcmUsIGFjdGlvbiwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGFjdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSBBY3Rpb24gYm91bmQgdG8ga2V5IFxcJ3Z1ZXguYWN0aW9ucy4nICsga2V5ICsgJ1xcJyBpcyBub3QgYSBmdW5jdGlvbi4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiB2dWV4Qm91bmRBY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjdGlvbi5jYWxsLmFwcGx5KGFjdGlvbiwgW3RoaXMsIHN0b3JlXS5jb25jYXQoYXJncykpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBvcHRpb24gbWVyZ2luZ1xuICAgIHZhciBtZXJnZSA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzLmNvbXB1dGVkO1xuICAgIFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzLnZ1ZXggPSBmdW5jdGlvbiAodG9WYWwsIGZyb21WYWwpIHtcbiAgICAgIGlmICghdG9WYWwpIHJldHVybiBmcm9tVmFsO1xuICAgICAgaWYgKCFmcm9tVmFsKSByZXR1cm4gdG9WYWw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXR0ZXJzOiBtZXJnZSh0b1ZhbC5nZXR0ZXJzLCBmcm9tVmFsLmdldHRlcnMpLFxuICAgICAgICBzdGF0ZTogbWVyZ2UodG9WYWwuc3RhdGUsIGZyb21WYWwuc3RhdGUpLFxuICAgICAgICBhY3Rpb25zOiBtZXJnZSh0b1ZhbC5hY3Rpb25zLCBmcm9tVmFsLmFjdGlvbnMpXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB2YXIgVnVlID0gdm9pZCAwO1xuICB2YXIgdWlkID0gMDtcblxuICB2YXIgU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqICAgICAgICAtIHtPYmplY3R9IHN0YXRlXG4gICAgICogICAgICAgIC0ge09iamVjdH0gYWN0aW9uc1xuICAgICAqICAgICAgICAtIHtPYmplY3R9IG11dGF0aW9uc1xuICAgICAqICAgICAgICAtIHtBcnJheX0gcGx1Z2luc1xuICAgICAqICAgICAgICAtIHtCb29sZWFufSBzdHJpY3RcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFN0b3JlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgdmFyIF9yZWYkc3RhdGUgPSBfcmVmLnN0YXRlO1xuICAgICAgdmFyIHN0YXRlID0gX3JlZiRzdGF0ZSA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmJHN0YXRlO1xuICAgICAgdmFyIF9yZWYkbXV0YXRpb25zID0gX3JlZi5tdXRhdGlvbnM7XG4gICAgICB2YXIgbXV0YXRpb25zID0gX3JlZiRtdXRhdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZiRtdXRhdGlvbnM7XG4gICAgICB2YXIgX3JlZiRtb2R1bGVzID0gX3JlZi5tb2R1bGVzO1xuICAgICAgdmFyIG1vZHVsZXMgPSBfcmVmJG1vZHVsZXMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZiRtb2R1bGVzO1xuICAgICAgdmFyIF9yZWYkcGx1Z2lucyA9IF9yZWYucGx1Z2lucztcbiAgICAgIHZhciBwbHVnaW5zID0gX3JlZiRwbHVnaW5zID09PSB1bmRlZmluZWQgPyBbXSA6IF9yZWYkcGx1Z2lucztcbiAgICAgIHZhciBfcmVmJHN0cmljdCA9IF9yZWYuc3RyaWN0O1xuICAgICAgdmFyIHN0cmljdCA9IF9yZWYkc3RyaWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkc3RyaWN0O1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RvcmUpO1xuXG4gICAgICB0aGlzLl9nZXR0ZXJDYWNoZUlkID0gJ3Z1ZXhfc3RvcmVfJyArIHVpZCsrO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3Jvb3RNdXRhdGlvbnMgPSB0aGlzLl9tdXRhdGlvbnMgPSBtdXRhdGlvbnM7XG4gICAgICB0aGlzLl9tb2R1bGVzID0gbW9kdWxlcztcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG4gICAgICAvLyBiaW5kIGRpc3BhdGNoIHRvIHNlbGZcbiAgICAgIHZhciBkaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2g7XG4gICAgICB0aGlzLmRpc3BhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwYXRjaC5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgICAgLy8gdXNlIGEgVnVlIGluc3RhbmNlIHRvIHN0b3JlIHRoZSBzdGF0ZSB0cmVlXG4gICAgICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBqdXN0IGluIGNhc2UgdGhlIHVzZXIgaGFzIGFkZGVkXG4gICAgICAvLyBzb21lIGZ1bmt5IGdsb2JhbCBtaXhpbnNcbiAgICAgIGlmICghVnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW3Z1ZXhdIG11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLicpO1xuICAgICAgfVxuICAgICAgdmFyIHNpbGVudCA9IFZ1ZS5jb25maWcuc2lsZW50O1xuICAgICAgVnVlLmNvbmZpZy5zaWxlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5fdm0gPSBuZXcgVnVlKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFZ1ZS5jb25maWcuc2lsZW50ID0gc2lsZW50O1xuICAgICAgdGhpcy5fc2V0dXBNb2R1bGVTdGF0ZShzdGF0ZSwgbW9kdWxlcyk7XG4gICAgICB0aGlzLl9zZXR1cE1vZHVsZU11dGF0aW9ucyhtb2R1bGVzKTtcbiAgICAgIC8vIGFkZCBleHRyYSB3YXJuaW5ncyBpbiBzdHJpY3QgbW9kZVxuICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICB0aGlzLl9zZXR1cE11dGF0aW9uQ2hlY2soKTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBsdWdpbnNcbiAgICAgIGRldnRvb2xQbHVnaW4odGhpcyk7XG4gICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luKF90aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHRlciBmb3IgdGhlIGVudGlyZSBzdGF0ZSB0cmVlLlxuICAgICAqIFJlYWQgb25seS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cblxuICAgIGNyZWF0ZUNsYXNzKFN0b3JlLCBbe1xuICAgICAga2V5OiAncmVwbGFjZVN0YXRlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2Ugcm9vdCBzdGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICAgICAqL1xuXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdm0uc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEaXNwYXRjaCBhbiBhY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzcGF0Y2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoKHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBwYXlsb2FkID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIHBheWxvYWRbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2lsZW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBpc09iamVjdFN0eWxlRGlzcGF0Y2ggPSBmYWxzZTtcbiAgICAgICAgLy8gY29tcGF0aWJpbGl0eSBmb3Igb2JqZWN0IGFjdGlvbnMsIGUuZy4gRlNBXG4gICAgICAgIGlmICgodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHR5cGUpKSA9PT0gJ29iamVjdCcgJiYgdHlwZS50eXBlICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBpc09iamVjdFN0eWxlRGlzcGF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHBheWxvYWQgPSB0eXBlO1xuICAgICAgICAgIGlmICh0eXBlLnNpbGVudCkgc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICB0eXBlID0gdHlwZS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5fbXV0YXRpb25zW3R5cGVdO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAvLyBhcHBseSB0aGUgbXV0YXRpb25cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgICAgICAgaGFuZGxlci5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICAgIGlzT2JqZWN0U3R5bGVEaXNwYXRjaCA/IGgoc3RhdGUsIHBheWxvYWQpIDogaC5hcHBseSh1bmRlZmluZWQsIFtzdGF0ZV0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHBheWxvYWQpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNPYmplY3RTdHlsZURpc3BhdGNoID8gaGFuZGxlcihzdGF0ZSwgcGF5bG9hZCkgOiBoYW5kbGVyLmFwcGx5KHVuZGVmaW5lZCwgW3N0YXRlXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkocGF5bG9hZCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG11dGF0aW9uID0gaXNPYmplY3RTdHlsZURpc3BhdGNoID8gcGF5bG9hZCA6IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICAgICAgICAgICAgICBfdGhpczIuX3N1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWIobXV0YXRpb24sIHN0YXRlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWV4XSBVbmtub3duIG11dGF0aW9uOiAnICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXYXRjaCBzdGF0ZSBjaGFuZ2VzIG9uIHRoZSBzdG9yZS5cbiAgICAgICAqIFNhbWUgQVBJIGFzIFZ1ZSdzICR3YXRjaCwgZXhjZXB0IHdoZW4gd2F0Y2hpbmcgYSBmdW5jdGlvbixcbiAgICAgICAqIHRoZSBmdW5jdGlvbiBnZXRzIHRoZSBzdGF0ZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3dhdGNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB3YXRjaChmbiwgY2IsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Z1ZXggc3RvcmUud2F0Y2ggb25seSBhY2NlcHRzIGZ1bmN0aW9uLicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdm0uJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZm4oX3RoaXMzLnN0YXRlKTtcbiAgICAgICAgfSwgY2IsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFN1YnNjcmliZSB0byBzdGF0ZSBjaGFuZ2VzLiBGaXJlcyBhZnRlciBldmVyeSBtdXRhdGlvbi5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc3Vic2NyaWJlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmUoZm4pIHtcbiAgICAgICAgdmFyIHN1YnMgPSB0aGlzLl9zdWJzY3JpYmVycztcbiAgICAgICAgaWYgKHN1YnMuaW5kZXhPZihmbikgPCAwKSB7XG4gICAgICAgICAgc3Vicy5wdXNoKGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpID0gc3Vicy5pbmRleE9mKGZuKTtcbiAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICBzdWJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSG90IHVwZGF0ZSBtdXRhdGlvbnMgJiBtb2R1bGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgKiAgICAgICAgLSB7T2JqZWN0fSBbbXV0YXRpb25zXVxuICAgICAgICogICAgICAgIC0ge09iamVjdH0gW21vZHVsZXNdXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hvdFVwZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaG90VXBkYXRlKCkge1xuICAgICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICB2YXIgbXV0YXRpb25zID0gX3JlZjIubXV0YXRpb25zO1xuICAgICAgICB2YXIgbW9kdWxlcyA9IF9yZWYyLm1vZHVsZXM7XG5cbiAgICAgICAgdGhpcy5fcm9vdE11dGF0aW9ucyA9IHRoaXMuX211dGF0aW9ucyA9IG11dGF0aW9ucyB8fCB0aGlzLl9yb290TXV0YXRpb25zO1xuICAgICAgICB0aGlzLl9zZXR1cE1vZHVsZU11dGF0aW9ucyhtb2R1bGVzIHx8IHRoaXMuX21vZHVsZXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEF0dGFjaCBzdWIgc3RhdGUgdHJlZSBvZiBlYWNoIG1vZHVsZSB0byB0aGUgcm9vdCB0cmVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZXNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldHVwTW9kdWxlU3RhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cE1vZHVsZVN0YXRlKHN0YXRlLCBtb2R1bGVzKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNPYmplY3QobW9kdWxlcykpIHJldHVybjtcblxuICAgICAgICBPYmplY3Qua2V5cyhtb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgbW9kdWxlID0gbW9kdWxlc1trZXldO1xuXG4gICAgICAgICAgLy8gc2V0IHRoaXMgbW9kdWxlJ3Mgc3RhdGVcbiAgICAgICAgICBWdWUuc2V0KHN0YXRlLCBrZXksIG1vZHVsZS5zdGF0ZSB8fCB7fSk7XG5cbiAgICAgICAgICAvLyByZXRyaWV2ZSBuZXN0ZWQgbW9kdWxlc1xuICAgICAgICAgIF90aGlzNC5fc2V0dXBNb2R1bGVTdGF0ZShzdGF0ZVtrZXldLCBtb2R1bGUubW9kdWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEJpbmQgbXV0YXRpb25zIGZvciBlYWNoIG1vZHVsZSB0byBpdHMgc3ViIHRyZWUgYW5kXG4gICAgICAgKiBtZXJnZSB0aGVtIGFsbCBpbnRvIG9uZSBmaW5hbCBtdXRhdGlvbnMgbWFwLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVkTW9kdWxlc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0dXBNb2R1bGVNdXRhdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cE1vZHVsZU11dGF0aW9ucyh1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICB2YXIgbW9kdWxlcyA9IHRoaXMuX21vZHVsZXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHVwZGF0ZWRNb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBtb2R1bGVzW2tleV0gPSB1cGRhdGVkTW9kdWxlc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHVwZGF0ZWRNdXRhdGlvbnMgPSB0aGlzLl9jcmVhdGVNb2R1bGVNdXRhdGlvbnMobW9kdWxlcywgW10pO1xuICAgICAgICB0aGlzLl9tdXRhdGlvbnMgPSBtZXJnZU9iamVjdHMoW3RoaXMuX3Jvb3RNdXRhdGlvbnNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh1cGRhdGVkTXV0YXRpb25zKSkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhlbHBlciBtZXRob2QgZm9yIF9zZXR1cE1vZHVsZU11dGF0aW9ucy5cbiAgICAgICAqIFRoZSBtZXRob2QgcmV0cmlldmUgbmVzdGVkIHN1YiBtb2R1bGVzIGFuZFxuICAgICAgICogYmluZCBlYWNoIG11dGF0aW9ucyB0byBpdHMgc3ViIHRyZWUgcmVjdXJzaXZlbHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZXNcbiAgICAgICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gbmVzdGVkS2V5c1xuICAgICAgICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZU1vZHVsZU11dGF0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZU1vZHVsZU11dGF0aW9ucyhtb2R1bGVzLCBuZXN0ZWRLZXlzKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNPYmplY3QobW9kdWxlcykpIHJldHVybiBbXTtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobW9kdWxlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgbW9kdWxlID0gbW9kdWxlc1trZXldO1xuICAgICAgICAgIHZhciBuZXdOZXN0ZWRLZXlzID0gbmVzdGVkS2V5cy5jb25jYXQoa2V5KTtcblxuICAgICAgICAgIC8vIHJldHJpZXZlIG5lc3RlZCBtb2R1bGVzXG4gICAgICAgICAgdmFyIG5lc3RlZE11dGF0aW9ucyA9IF90aGlzNS5fY3JlYXRlTW9kdWxlTXV0YXRpb25zKG1vZHVsZS5tb2R1bGVzLCBuZXdOZXN0ZWRLZXlzKTtcblxuICAgICAgICAgIGlmICghbW9kdWxlIHx8ICFtb2R1bGUubXV0YXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VPYmplY3RzKG5lc3RlZE11dGF0aW9ucyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYmluZCBtdXRhdGlvbnMgdG8gc3ViIHN0YXRlIHRyZWVcbiAgICAgICAgICB2YXIgbXV0YXRpb25zID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXMobW9kdWxlLm11dGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gbW9kdWxlLm11dGF0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIG11dGF0aW9uc1tuYW1lXSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9yaWdpbmFsLmFwcGx5KHVuZGVmaW5lZCwgW2dldE5lc3RlZFN0YXRlKHN0YXRlLCBuZXdOZXN0ZWRLZXlzKV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBtZXJnZSBtdXRhdGlvbnMgb2YgdGhpcyBtb2R1bGUgYW5kIG5lc3RlZCBtb2R1bGVzXG4gICAgICAgICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhbbXV0YXRpb25zXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkobmVzdGVkTXV0YXRpb25zKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBtdXRhdGlvbiBjaGVjazogaWYgdGhlIHZ1ZXggaW5zdGFuY2UncyBzdGF0ZSBpcyBtdXRhdGVkXG4gICAgICAgKiBvdXRzaWRlIG9mIGEgbXV0YXRpb24gaGFuZGxlciwgd2UgdGhyb3cgZW4gZXJyb3IuIFRoaXMgZWZmZWN0aXZlbHlcbiAgICAgICAqIGVuZm9yY2VzIGFsbCBtdXRhdGlvbnMgdG8gdGhlIHN0YXRlIHRvIGJlIHRyYWNrYWJsZSBhbmQgaG90LXJlbG9hZGJsZS5cbiAgICAgICAqIEhvd2V2ZXIsIHRoaXMgY29tZXMgYXQgYSBydW4gdGltZSBjb3N0IHNpbmNlIHdlIGFyZSBkb2luZyBhIGRlZXBcbiAgICAgICAqIHdhdGNoIG9uIHRoZSBlbnRpcmUgc3RhdGUgdHJlZSwgc28gaXQgaXMgb25seSBlbmFsYmVkIHdpdGggdGhlXG4gICAgICAgKiBzdHJpY3Qgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0dXBNdXRhdGlvbkNoZWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBNdXRhdGlvbkNoZWNrKCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICB2YXIgV2F0Y2hlciA9IGdldFdhdGNoZXIodGhpcy5fdm0pO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbiAgICAgICAgbmV3IFdhdGNoZXIodGhpcy5fdm0sICdzdGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIV90aGlzNi5fZGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW3Z1ZXhdIERvIG5vdCBtdXRhdGUgdnVleCBzdG9yZSBzdGF0ZSBvdXRzaWRlIG11dGF0aW9uIGhhbmRsZXJzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBkZWVwOiB0cnVlLCBzeW5jOiB0cnVlIH0pO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3N0YXRlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdm0uc3RhdGU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1t2dWV4XSBVc2Ugc3RvcmUucmVwbGFjZVN0YXRlKCkgdG8gZXhwbGljaXQgcmVwbGFjZSBzdG9yZSBzdGF0ZS4nKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFN0b3JlO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gaW5zdGFsbChfVnVlKSB7XG4gICAgaWYgKFZ1ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdbdnVleF0gYWxyZWFkeSBpbnN0YWxsZWQuIFZ1ZS51c2UoVnVleCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFZ1ZSA9IF9WdWU7XG4gICAgb3ZlcnJpZGUoVnVlKTtcbiAgfVxuXG4gIC8vIGF1dG8gaW5zdGFsbCBpbiBkaXN0IG1vZGVcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgICBpbnN0YWxsKHdpbmRvdy5WdWUpO1xuICB9XG5cbiAgdmFyIGluZGV4ID0ge1xuICAgIFN0b3JlOiBTdG9yZSxcbiAgICBpbnN0YWxsOiBpbnN0YWxsXG4gIH07XG5cbiAgcmV0dXJuIGluZGV4O1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVleC9kaXN0L3Z1ZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 22 */
/***/ function(module, exports) {

	eval("'use strict';\n\n// Credits: borrowed code from fcomb/redux-logger\n\nfunction createLogger() {\n  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  var _ref$collapsed = _ref.collapsed;\n  var collapsed = _ref$collapsed === undefined ? true : _ref$collapsed;\n  var _ref$transformer = _ref.transformer;\n  var transformer = _ref$transformer === undefined ? function (state) {\n    return state;\n  } : _ref$transformer;\n  var _ref$mutationTransfor = _ref.mutationTransformer;\n  var mutationTransformer = _ref$mutationTransfor === undefined ? function (mut) {\n    return mut;\n  } : _ref$mutationTransfor;\n\n  return function (store) {\n    var prevState = JSON.parse(JSON.stringify(store.state));\n\n    store.subscribe(function (mutation, state) {\n      if (typeof console === 'undefined') {\n        return;\n      }\n      var nextState = JSON.parse(JSON.stringify(state));\n      var time = new Date();\n      var formattedTime = ' @ ' + pad(time.getHours(), 2) + ':' + pad(time.getMinutes(), 2) + ':' + pad(time.getSeconds(), 2) + '.' + pad(time.getMilliseconds(), 3);\n      var formattedMutation = mutationTransformer(mutation);\n      var message = 'mutation ' + mutation.type + formattedTime;\n      var startMessage = collapsed ? console.groupCollapsed : console.group;\n\n      // render\n      try {\n        startMessage.call(console, message);\n      } catch (e) {\n        console.log(message);\n      }\n\n      console.log('%c prev state', 'color: #9E9E9E; font-weight: bold', prevState);\n      console.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);\n      console.log('%c next state', 'color: #4CAF50; font-weight: bold', nextState);\n\n      try {\n        console.groupEnd();\n      } catch (e) {\n        console.log('—— log end ——');\n      }\n\n      prevState = nextState;\n    });\n  };\n}\n\nfunction repeat(str, times) {\n  return new Array(times + 1).join(str);\n}\n\nfunction pad(num, maxLength) {\n  return repeat('0', maxLength - num.toString().length) + num;\n}\n\nmodule.exports = createLogger;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZXgvbG9nZ2VyLmpzPzgyYmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRCxpREFBaUQ7QUFDakQsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBDcmVkaXRzOiBib3Jyb3dlZCBjb2RlIGZyb20gZmNvbWIvcmVkdXgtbG9nZ2VyXG5cbmZ1bmN0aW9uIGNyZWF0ZUxvZ2dlcigpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICB2YXIgX3JlZiRjb2xsYXBzZWQgPSBfcmVmLmNvbGxhcHNlZDtcbiAgdmFyIGNvbGxhcHNlZCA9IF9yZWYkY29sbGFwc2VkID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZiRjb2xsYXBzZWQ7XG4gIHZhciBfcmVmJHRyYW5zZm9ybWVyID0gX3JlZi50cmFuc2Zvcm1lcjtcbiAgdmFyIHRyYW5zZm9ybWVyID0gX3JlZiR0cmFuc2Zvcm1lciA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9IDogX3JlZiR0cmFuc2Zvcm1lcjtcbiAgdmFyIF9yZWYkbXV0YXRpb25UcmFuc2ZvciA9IF9yZWYubXV0YXRpb25UcmFuc2Zvcm1lcjtcbiAgdmFyIG11dGF0aW9uVHJhbnNmb3JtZXIgPSBfcmVmJG11dGF0aW9uVHJhbnNmb3IgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChtdXQpIHtcbiAgICByZXR1cm4gbXV0O1xuICB9IDogX3JlZiRtdXRhdGlvblRyYW5zZm9yO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICB2YXIgcHJldlN0YXRlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdG9yZS5zdGF0ZSkpO1xuXG4gICAgc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbiwgc3RhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5leHRTdGF0ZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoKTtcbiAgICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gJyBAICcgKyBwYWQodGltZS5nZXRIb3VycygpLCAyKSArICc6JyArIHBhZCh0aW1lLmdldE1pbnV0ZXMoKSwgMikgKyAnOicgKyBwYWQodGltZS5nZXRTZWNvbmRzKCksIDIpICsgJy4nICsgcGFkKHRpbWUuZ2V0TWlsbGlzZWNvbmRzKCksIDMpO1xuICAgICAgdmFyIGZvcm1hdHRlZE11dGF0aW9uID0gbXV0YXRpb25UcmFuc2Zvcm1lcihtdXRhdGlvbik7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdtdXRhdGlvbiAnICsgbXV0YXRpb24udHlwZSArIGZvcm1hdHRlZFRpbWU7XG4gICAgICB2YXIgc3RhcnRNZXNzYWdlID0gY29sbGFwc2VkID8gY29uc29sZS5ncm91cENvbGxhcHNlZCA6IGNvbnNvbGUuZ3JvdXA7XG5cbiAgICAgIC8vIHJlbmRlclxuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhcnRNZXNzYWdlLmNhbGwoY29uc29sZSwgbWVzc2FnZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnJWMgcHJldiBzdGF0ZScsICdjb2xvcjogIzlFOUU5RTsgZm9udC13ZWlnaHQ6IGJvbGQnLCBwcmV2U3RhdGUpO1xuICAgICAgY29uc29sZS5sb2coJyVjIG11dGF0aW9uJywgJ2NvbG9yOiAjMDNBOUY0OyBmb250LXdlaWdodDogYm9sZCcsIGZvcm1hdHRlZE11dGF0aW9uKTtcbiAgICAgIGNvbnNvbGUubG9nKCclYyBuZXh0IHN0YXRlJywgJ2NvbG9yOiAjNENBRjUwOyBmb250LXdlaWdodDogYm9sZCcsIG5leHRTdGF0ZSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KAlOKAlCBsb2cgZW5kIOKAlOKAlCcpO1xuICAgICAgfVxuXG4gICAgICBwcmV2U3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIHRpbWVzKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodGltZXMgKyAxKS5qb2luKHN0cik7XG59XG5cbmZ1bmN0aW9uIHBhZChudW0sIG1heExlbmd0aCkge1xuICByZXR1cm4gcmVwZWF0KCcwJywgbWF4TGVuZ3RoIC0gbnVtLnRvU3RyaW5nKCkubGVuZ3RoKSArIG51bTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVMb2dnZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVleC9sb2dnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _defineProperty2 = __webpack_require__(24);\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _mutations;\n\nvar _mutationType = __webpack_require__(15);\n\nvar mutationType = _interopRequireWildcard(_mutationType);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar state = {\n  data: {},\n  auth: false\n};\n\nvar mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, mutationType.AUTHENTICATE, function (state, user) {\n  console.log('mutations: AUTHENTICATE');\n  state.data = user;\n  state.auth = true;\n}), (0, _defineProperty3.default)(_mutations, mutationType.AUTHENTICATE_ERROR, function (state, user) {\n  console.log('mutations: AUTHENTICATE_ERROR');\n  state.data = null;\n  state.auth = false;\n}), (0, _defineProperty3.default)(_mutations, mutationType.LOGIN, function (state, user) {\n  console.log('mutations: LOGIN');\n  state.data = user;\n  state.auth = true;\n}), _mutations);\n\nexports.default = {\n  state: state,\n  mutations: mutations\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3Z1ZXgvbW9kdWxlcy91c2VyLmpzPzhmZWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7O0lBQVksWTs7Ozs7O0FBRVosSUFBTSxRQUFRO0FBQ1osUUFBTSxFQURNO0FBRVosUUFBTTtBQUZNLENBQWQ7O0FBS0EsSUFBTSx3RUFDSCxhQUFhLFlBRFYsWUFDd0IsS0FEeEIsRUFDK0IsSUFEL0IsRUFDcUM7QUFDdkMsVUFBUSxHQUFSLENBQVkseUJBQVo7QUFDQSxRQUFNLElBQU4sR0FBYSxJQUFiO0FBQ0EsUUFBTSxJQUFOLEdBQWEsSUFBYjtBQUNELENBTEcsNkNBT0gsYUFBYSxrQkFQVixZQU84QixLQVA5QixFQU9xQyxJQVByQyxFQU8yQztBQUM3QyxVQUFRLEdBQVIsQ0FBWSwrQkFBWjtBQUNBLFFBQU0sSUFBTixHQUFhLElBQWI7QUFDQSxRQUFNLElBQU4sR0FBYSxLQUFiO0FBQ0QsQ0FYRyw2Q0FZSCxhQUFhLEtBWlYsWUFZaUIsS0FaakIsRUFZd0IsSUFaeEIsRUFZOEI7QUFDaEMsVUFBUSxHQUFSLENBQVksa0JBQVo7QUFDQSxRQUFNLElBQU4sR0FBYSxJQUFiO0FBQ0EsUUFBTSxJQUFOLEdBQWEsSUFBYjtBQUNELENBaEJHLGNBQU47O2tCQW1CZTtBQUNiLGNBRGE7QUFFYjtBQUZhLEMiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBtdXRhdGlvblR5cGUgZnJvbSAnLi4vbXV0YXRpb25UeXBlJztcblxuY29uc3Qgc3RhdGUgPSB7XG4gIGRhdGE6IHt9LFxuICBhdXRoOiBmYWxzZSxcbn07XG5cbmNvbnN0IG11dGF0aW9ucyA9IHtcbiAgW211dGF0aW9uVHlwZS5BVVRIRU5USUNBVEVdKHN0YXRlLCB1c2VyKSB7XG4gICAgY29uc29sZS5sb2coJ211dGF0aW9uczogQVVUSEVOVElDQVRFJyk7XG4gICAgc3RhdGUuZGF0YSA9IHVzZXI7XG4gICAgc3RhdGUuYXV0aCA9IHRydWU7XG4gIH0sXG5cbiAgW211dGF0aW9uVHlwZS5BVVRIRU5USUNBVEVfRVJST1JdKHN0YXRlLCB1c2VyKSB7XG4gICAgY29uc29sZS5sb2coJ211dGF0aW9uczogQVVUSEVOVElDQVRFX0VSUk9SJyk7XG4gICAgc3RhdGUuZGF0YSA9IG51bGw7XG4gICAgc3RhdGUuYXV0aCA9IGZhbHNlO1xuICB9LFxuICBbbXV0YXRpb25UeXBlLkxPR0lOXShzdGF0ZSwgdXNlcikge1xuICAgIGNvbnNvbGUubG9nKCdtdXRhdGlvbnM6IExPR0lOJyk7XG4gICAgc3RhdGUuZGF0YSA9IHVzZXI7XG4gICAgc3RhdGUuYXV0aCA9IHRydWU7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3RhdGUsXG4gIG11dGF0aW9uc1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NyYy92dWV4L21vZHVsZXMvdXNlci5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nexports.__esModule = true;\n\nvar _defineProperty = __webpack_require__(25);\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (obj, key, value) {\n  if (key in obj) {\n    (0, _defineProperty2.default)(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcz8xNzJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = { \"default\": __webpack_require__(26), __esModule: true };//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzPzVmNzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(27);\nvar $Object = __webpack_require__(30).Object;\nmodule.exports = function defineProperty(it, key, desc){\n  return $Object.defineProperty(it, key, desc);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzP2I3ZDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(28);\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !__webpack_require__(38), 'Object', {defineProperty: __webpack_require__(34).f});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzP2M4MmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLHFFQUF1RSwwQ0FBMEMiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	eval("var global    = __webpack_require__(29)\n  , core      = __webpack_require__(30)\n  , ctx       = __webpack_require__(31)\n  , hide      = __webpack_require__(33)\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanM/ZWNlMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQiIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBDKXtcbiAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQztcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYoSVNfUFJPVE8pe1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 29 */
/***/ function(module, exports) {

	eval("// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanM/NzdhYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 30 */
/***/ function(module, exports) {

	eval("var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzPzFiNjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNkJBQTZCO0FBQzdCLHFDQUFxQyIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	eval("// optional / simple context binding\nvar aFunction = __webpack_require__(32);\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanM/Y2UwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 32 */
/***/ function(module, exports) {

	eval("module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzP2Q1M2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("var dP         = __webpack_require__(34)\n  , createDesc = __webpack_require__(42);\nmodule.exports = __webpack_require__(38) ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzP2E2ZGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("var anObject       = __webpack_require__(35)\n  , IE8_DOM_DEFINE = __webpack_require__(37)\n  , toPrimitive    = __webpack_require__(41)\n  , dP             = Object.defineProperty;\n\nexports.f = __webpack_require__(38) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanM/NDExNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFVBQVU7QUFDYjtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(36);\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanM/MGRhMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 36 */
/***/ function(module, exports) {

	eval("module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanM/MjRjOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = !__webpack_require__(38) && !__webpack_require__(39)(function(){\n  return Object.defineProperty(__webpack_require__(40)('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcz9iZDFmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EscUVBQXNFLGdCQUFnQixVQUFVLEdBQUc7QUFDbkcsQ0FBQyIsImZpbGUiOiIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	eval("// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(39)(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcz83MDUxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUSxnQkFBZ0IsVUFBVSxHQUFHO0FBQ3RFLENBQUMiLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 39 */
/***/ function(module, exports) {

	eval("module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcz85MzVkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(36)\n  , document = __webpack_require__(29).document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzP2FiNDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	eval("// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(36);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanM/NDlhNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 42 */
/***/ function(module, exports) {

	eval("module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzPzFlODYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _defineProperty2 = __webpack_require__(24);\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _mutations;\n\nvar _mutationType = __webpack_require__(15);\n\nvar mutationType = _interopRequireWildcard(_mutationType);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar state = {\n  all: []\n};\n\n// 创建一个对象存储一系列我们接下来要写的 mutation 函数\nvar mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, mutationType.FETCH_LISTS, function (state, lists) {\n  state.all = lists;\n}), (0, _defineProperty3.default)(_mutations, mutationType.ADD_LIST, function (state, list) {\n  console.log('mutations: ADD_LIST');\n  console.log(list);\n  state.all = state.all.concat(list);\n}), (0, _defineProperty3.default)(_mutations, mutationType.DELETE_LIST, function (state, listid) {\n  state.all = state.all.filter(function (item) {\n    return item.id !== listid;\n  });\n}), (0, _defineProperty3.default)(_mutations, mutationType.EDIT_LIST, function (state, list) {\n  state.all.map(function (item) {\n    if (item.id === list.id) {\n      return list;\n    }\n    return item;\n  });\n}), (0, _defineProperty3.default)(_mutations, mutationType.UPDATE_LIST, function (state, data) {\n  console.log('mutations: UPDATE_LIST');\n  console.log(data);\n  state.all.map(function (item) {\n    if (item.id === data.id) {\n      switch (data.type) {\n        case 'total':\n          item.task_count_total += data.update;\n          break;\n        case 'completed':\n          item.task_count_completed += data.update;\n        default:\n          break;\n      }\n      return item;\n    }\n    return item;\n  });\n}), _mutations);\n\nexports.default = {\n  state: state,\n  mutations: mutations\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3Z1ZXgvbW9kdWxlcy9saXN0cy5qcz82MWMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOztJQUFZLFk7Ozs7OztBQUVaLElBQU0sUUFBUTtBQUNaLE9BQUs7QUFETyxDQUFkOztBQUlBO0FBQ0EsSUFBTSx3RUFDSCxhQUFhLFdBRFYsWUFDdUIsS0FEdkIsRUFDOEIsS0FEOUIsRUFDcUM7QUFDdkMsUUFBTSxHQUFOLEdBQVksS0FBWjtBQUNELENBSEcsNkNBS0gsYUFBYSxRQUxWLFlBS29CLEtBTHBCLEVBSzJCLElBTDNCLEVBS2lDO0FBQ25DLFVBQVEsR0FBUixDQUFZLHFCQUFaO0FBQ0EsVUFBUSxHQUFSLENBQVksSUFBWjtBQUNBLFFBQU0sR0FBTixHQUFZLE1BQU0sR0FBTixDQUFVLE1BQVYsQ0FBaUIsSUFBakIsQ0FBWjtBQUNELENBVEcsNkNBV0gsYUFBYSxXQVhWLFlBV3VCLEtBWHZCLEVBVzhCLE1BWDlCLEVBV3NDO0FBQ3hDLFFBQU0sR0FBTixHQUFZLE1BQU0sR0FBTixDQUFVLE1BQVYsQ0FBaUIsVUFBQyxJQUFELEVBQVU7QUFDckMsV0FBTyxLQUFLLEVBQUwsS0FBWSxNQUFuQjtBQUNELEdBRlcsQ0FBWjtBQUdELENBZkcsNkNBaUJILGFBQWEsU0FqQlYsWUFpQnFCLEtBakJyQixFQWlCNEIsSUFqQjVCLEVBaUJrQztBQUNwQyxRQUFNLEdBQU4sQ0FBVSxHQUFWLENBQWMsVUFBQyxJQUFELEVBQVU7QUFDdEIsUUFBSSxLQUFLLEVBQUwsS0FBWSxLQUFLLEVBQXJCLEVBQXlCO0FBQ3ZCLGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBTyxJQUFQO0FBQ0QsR0FMRDtBQU1ELENBeEJHLDZDQTBCSCxhQUFhLFdBMUJWLFlBMEJ1QixLQTFCdkIsRUEwQjhCLElBMUI5QixFQTBCb0M7QUFDdEMsVUFBUSxHQUFSLENBQVksd0JBQVo7QUFDQSxVQUFRLEdBQVIsQ0FBWSxJQUFaO0FBQ0EsUUFBTSxHQUFOLENBQVUsR0FBVixDQUFjLFVBQUMsSUFBRCxFQUFVO0FBQ3RCLFFBQUksS0FBSyxFQUFMLEtBQVksS0FBSyxFQUFyQixFQUF5QjtBQUN2QixjQUFRLEtBQUssSUFBYjtBQUNFLGFBQUssT0FBTDtBQUNFLGVBQUssZ0JBQUwsSUFBeUIsS0FBSyxNQUE5QjtBQUNBO0FBQ0YsYUFBSyxXQUFMO0FBQ0UsZUFBSyxvQkFBTCxJQUE2QixLQUFLLE1BQWxDO0FBQ0Y7QUFDRTtBQVBKO0FBU0EsYUFBTyxJQUFQO0FBQ0Q7QUFDRCxXQUFPLElBQVA7QUFDRCxHQWREO0FBZUQsQ0E1Q0csY0FBTjs7a0JBZ0RlO0FBQ2IsY0FEYTtBQUViO0FBRmEsQyIsImZpbGUiOiI0My5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG11dGF0aW9uVHlwZSBmcm9tICcuLi9tdXRhdGlvblR5cGUnO1xuXG5jb25zdCBzdGF0ZSA9IHtcbiAgYWxsOiBbXSxcbn07XG5cbi8vIOWIm+W7uuS4gOS4quWvueixoeWtmOWCqOS4gOezu+WIl+aIkeS7rOaOpeS4i+adpeimgeWGmeeahCBtdXRhdGlvbiDlh73mlbBcbmNvbnN0IG11dGF0aW9ucyA9IHtcbiAgW211dGF0aW9uVHlwZS5GRVRDSF9MSVNUU10oc3RhdGUsIGxpc3RzKSB7XG4gICAgc3RhdGUuYWxsID0gbGlzdHM7XG4gIH0sXG5cbiAgW211dGF0aW9uVHlwZS5BRERfTElTVF0oc3RhdGUsIGxpc3QpIHtcbiAgICBjb25zb2xlLmxvZygnbXV0YXRpb25zOiBBRERfTElTVCcpO1xuICAgIGNvbnNvbGUubG9nKGxpc3QpO1xuICAgIHN0YXRlLmFsbCA9IHN0YXRlLmFsbC5jb25jYXQobGlzdCk7XG4gIH0sXG5cbiAgW211dGF0aW9uVHlwZS5ERUxFVEVfTElTVF0oc3RhdGUsIGxpc3RpZCkge1xuICAgIHN0YXRlLmFsbCA9IHN0YXRlLmFsbC5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgIHJldHVybiBpdGVtLmlkICE9PSBsaXN0aWQ7XG4gICAgfSk7XG4gIH0sXG5cbiAgW211dGF0aW9uVHlwZS5FRElUX0xJU1RdKHN0YXRlLCBsaXN0KSB7XG4gICAgc3RhdGUuYWxsLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uaWQgPT09IGxpc3QuaWQpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcbiAgfSxcblxuICBbbXV0YXRpb25UeXBlLlVQREFURV9MSVNUXShzdGF0ZSwgZGF0YSkge1xuICAgIGNvbnNvbGUubG9nKCdtdXRhdGlvbnM6IFVQREFURV9MSVNUJyk7XG4gICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgc3RhdGUuYWxsLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uaWQgPT09IGRhdGEuaWQpIHtcbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICd0b3RhbCc6XG4gICAgICAgICAgICBpdGVtLnRhc2tfY291bnRfdG90YWwgKz0gZGF0YS51cGRhdGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgaXRlbS50YXNrX2NvdW50X2NvbXBsZXRlZCArPSBkYXRhLnVwZGF0ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcbiAgfVxuXG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN0YXRlLFxuICBtdXRhdGlvbnNcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9zcmMvdnVleC9tb2R1bGVzL2xpc3RzLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _defineProperty2 = __webpack_require__(24);\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _mutations;\n\nvar _mutationType = __webpack_require__(15);\n\nvar mutationType = _interopRequireWildcard(_mutationType);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar state = {\n  active: [],\n  archieved: [],\n  completed: [],\n  all: [],\n  taskDetail: null,\n  showDetail: false\n};\n\nvar mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, mutationType.FETCH_TASKS, function (state, query, tasks) {\n  console.log('mutations: FETCH_TASKS');\n  // if (query.completed) {\n  //   state.completed = tasks;\n  // } else {\n  //   state.active = tasks;\n  // }\n  if (query.completed) {\n    state.all = state.all.concat(tasks);\n  } else {\n    state.all = tasks;\n  }\n}), (0, _defineProperty3.default)(_mutations, mutationType.FETCH_TASK_DETAIL, function (state, task) {\n  console.log('mutations: FETCH_TASK_DETAIL');\n  state.showDetail = true;\n  state.taskDetail = task;\n}), (0, _defineProperty3.default)(_mutations, mutationType.HIDE_DETAIL_WINDOW, function (state) {\n  state.showDetail = false;\n}), (0, _defineProperty3.default)(_mutations, mutationType.ADD_TASK, function (state, task) {\n  state.all = [task].concat(state.all);\n}), (0, _defineProperty3.default)(_mutations, mutationType.EDIT_TASK, function (state, task) {\n  console.log('mutations: EDIT_TASK');\n  state.all = state.all.map(function (item) {\n    if (item.id === task.id) {\n      return task;\n    }\n    return item;\n  });\n  state.taskDetail = task;\n}), (0, _defineProperty3.default)(_mutations, mutationType.DELETE_TASK, function (state, task) {\n  state.all = state.all.filter(function (item) {\n    return item.id !== task.id;\n  });\n}), _mutations);\n\nexports.default = {\n  state: state,\n  mutations: mutations\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3Z1ZXgvbW9kdWxlcy90YXNrcy5qcz9jYTYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOztJQUFZLFk7Ozs7OztBQUVaLElBQU0sUUFBUTtBQUNaLFVBQVEsRUFESTtBQUVaLGFBQVcsRUFGQztBQUdaLGFBQVcsRUFIQztBQUlaLE9BQUssRUFKTztBQUtaLGNBQVksSUFMQTtBQU1aLGNBQVk7QUFOQSxDQUFkOztBQVNBLElBQU0sd0VBQ0gsYUFBYSxXQURWLFlBQ3VCLEtBRHZCLEVBQzhCLEtBRDlCLEVBQ3FDLEtBRHJDLEVBQzRDO0FBQzlDLFVBQVEsR0FBUixDQUFZLHdCQUFaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUksTUFBTSxTQUFWLEVBQXFCO0FBQ25CLFVBQU0sR0FBTixHQUFZLE1BQU0sR0FBTixDQUFVLE1BQVYsQ0FBaUIsS0FBakIsQ0FBWjtBQUNELEdBRkQsTUFFTztBQUNMLFVBQU0sR0FBTixHQUFZLEtBQVo7QUFDRDtBQUNGLENBYkcsNkNBY0gsYUFBYSxpQkFkVixZQWM2QixLQWQ3QixFQWNvQyxJQWRwQyxFQWMwQztBQUM1QyxVQUFRLEdBQVIsQ0FBWSw4QkFBWjtBQUNBLFFBQU0sVUFBTixHQUFtQixJQUFuQjtBQUNBLFFBQU0sVUFBTixHQUFtQixJQUFuQjtBQUNELENBbEJHLDZDQW9CSCxhQUFhLGtCQXBCVixZQW9COEIsS0FwQjlCLEVBb0JxQztBQUN2QyxRQUFNLFVBQU4sR0FBbUIsS0FBbkI7QUFDRCxDQXRCRyw2Q0F3QkgsYUFBYSxRQXhCVixZQXdCb0IsS0F4QnBCLEVBd0IyQixJQXhCM0IsRUF3QmlDO0FBQ25DLFFBQU0sR0FBTixHQUFZLENBQUMsSUFBRCxFQUFPLE1BQVAsQ0FBYyxNQUFNLEdBQXBCLENBQVo7QUFDRCxDQTFCRyw2Q0ErQkgsYUFBYSxTQS9CVixZQStCcUIsS0EvQnJCLEVBK0I0QixJQS9CNUIsRUErQmtDO0FBQ3BDLFVBQVEsR0FBUixDQUFZLHNCQUFaO0FBQ0EsUUFBTSxHQUFOLEdBQVksTUFBTSxHQUFOLENBQVUsR0FBVixDQUFjLFVBQUMsSUFBRCxFQUFVO0FBQ2xDLFFBQUksS0FBSyxFQUFMLEtBQVksS0FBSyxFQUFyQixFQUF5QjtBQUN2QixhQUFPLElBQVA7QUFDRDtBQUNELFdBQU8sSUFBUDtBQUNELEdBTFcsQ0FBWjtBQU1BLFFBQU0sVUFBTixHQUFtQixJQUFuQjtBQUNELENBeENHLDZDQTBDSCxhQUFhLFdBMUNWLFlBMEN1QixLQTFDdkIsRUEwQzhCLElBMUM5QixFQTBDb0M7QUFDdEMsUUFBTSxHQUFOLEdBQVksTUFBTSxHQUFOLENBQVUsTUFBVixDQUFpQixVQUFDLElBQUQsRUFBVTtBQUNyQyxXQUFPLEtBQUssRUFBTCxLQUFZLEtBQUssRUFBeEI7QUFDRCxHQUZXLENBQVo7QUFHRCxDQTlDRyxjQUFOOztrQkFrRGU7QUFDYixjQURhO0FBRWI7QUFGYSxDIiwiZmlsZSI6IjQ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbXV0YXRpb25UeXBlIGZyb20gJy4uL211dGF0aW9uVHlwZSc7XG5cbmNvbnN0IHN0YXRlID0ge1xuICBhY3RpdmU6IFtdLFxuICBhcmNoaWV2ZWQ6IFtdLFxuICBjb21wbGV0ZWQ6IFtdLFxuICBhbGw6IFtdLFxuICB0YXNrRGV0YWlsOiBudWxsLFxuICBzaG93RGV0YWlsOiBmYWxzZSxcbn07XG5cbmNvbnN0IG11dGF0aW9ucyA9IHtcbiAgW211dGF0aW9uVHlwZS5GRVRDSF9UQVNLU10oc3RhdGUsIHF1ZXJ5LCB0YXNrcykge1xuICAgIGNvbnNvbGUubG9nKCdtdXRhdGlvbnM6IEZFVENIX1RBU0tTJyk7XG4gICAgLy8gaWYgKHF1ZXJ5LmNvbXBsZXRlZCkge1xuICAgIC8vICAgc3RhdGUuY29tcGxldGVkID0gdGFza3M7XG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyAgIHN0YXRlLmFjdGl2ZSA9IHRhc2tzO1xuICAgIC8vIH1cbiAgICBpZiAocXVlcnkuY29tcGxldGVkKSB7XG4gICAgICBzdGF0ZS5hbGwgPSBzdGF0ZS5hbGwuY29uY2F0KHRhc2tzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYWxsID0gdGFza3M7XG4gICAgfVxuICB9LFxuICBbbXV0YXRpb25UeXBlLkZFVENIX1RBU0tfREVUQUlMXShzdGF0ZSwgdGFzaykge1xuICAgIGNvbnNvbGUubG9nKCdtdXRhdGlvbnM6IEZFVENIX1RBU0tfREVUQUlMJyk7XG4gICAgc3RhdGUuc2hvd0RldGFpbCA9IHRydWU7XG4gICAgc3RhdGUudGFza0RldGFpbCA9IHRhc2s7XG4gIH0sXG5cbiAgW211dGF0aW9uVHlwZS5ISURFX0RFVEFJTF9XSU5ET1ddKHN0YXRlKSB7XG4gICAgc3RhdGUuc2hvd0RldGFpbCA9IGZhbHNlO1xuICB9LFxuXG4gIFttdXRhdGlvblR5cGUuQUREX1RBU0tdKHN0YXRlLCB0YXNrKSB7XG4gICAgc3RhdGUuYWxsID0gW3Rhc2tdLmNvbmNhdChzdGF0ZS5hbGwpO1xuICB9LFxuXG4gIC8vIFttdXRhdGlvblR5cGUuVE9HR0xFX1RBU0tdKHN0YXRlLCB0YXNrKSB7XG4gIC8vIH0sXG5cbiAgW211dGF0aW9uVHlwZS5FRElUX1RBU0tdKHN0YXRlLCB0YXNrKSB7XG4gICAgY29uc29sZS5sb2coJ211dGF0aW9uczogRURJVF9UQVNLJyk7XG4gICAgc3RhdGUuYWxsID0gc3RhdGUuYWxsLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uaWQgPT09IHRhc2suaWQpIHtcbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcbiAgICBzdGF0ZS50YXNrRGV0YWlsID0gdGFzaztcbiAgfSxcblxuICBbbXV0YXRpb25UeXBlLkRFTEVURV9UQVNLXShzdGF0ZSwgdGFzaykge1xuICAgIHN0YXRlLmFsbCA9IHN0YXRlLmFsbC5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgIHJldHVybiBpdGVtLmlkICE9PSB0YXNrLmlkO1xuICAgIH0pO1xuICB9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3RhdGUsXG4gIG11dGF0aW9ucyxcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9zcmMvdnVleC9tb2R1bGVzL3Rhc2tzLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.login = exports.authenticate = undefined;\n\nvar _superagent = __webpack_require__(10);\n\nvar _superagent2 = _interopRequireDefault(_superagent);\n\nvar _mutationType = __webpack_require__(15);\n\nvar mutationType = _interopRequireWildcard(_mutationType);\n\nvar _base = __webpack_require__(16);\n\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// 用户认证\nvar authenticate = exports.authenticate = function authenticate(_ref, callback) {\n  var dispatch = _ref.dispatch;\n  var state = _ref.state;\n\n  _superagent2.default.get('/authenticate').set('x-access-token', window.localStorage.token).use(_base2.default).then(function (res) {\n    dispatch(mutationType.AUTHENTICATE, res.body);\n    if (callback) {\n      callback(res.body);\n    }\n  }, function () {\n    dispatch(mutationType.AUTHENTICATE_ERROR, {});\n    if (callback) {\n      callback(null);\n    }\n  });\n};\n\n// 用户登录\nvar login = exports.login = function login(_ref2, param) {\n  var dispatch = _ref2.dispatch;\n  var state = _ref2.state;\n\n  _superagent2.default.post('/users/login').use(_base2.default).send(param).then(function (res) {\n    window.localStorage.token = res.body.token;\n    dispatch(mutationType.LOGIN, res.body);\n  }, function () {});\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3Z1ZXgvYWN0aW9ucy91c2VyLmpzP2M2OTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7O0FBQ0E7O0lBQVksWTs7QUFDWjs7Ozs7Ozs7QUFFQTtBQUNPLElBQU0sc0NBQWUsU0FBZixZQUFlLE9BQThCLFFBQTlCLEVBQXdDO0FBQUEsTUFBN0IsUUFBNkIsUUFBN0IsUUFBNkI7QUFBQSxNQUFuQixLQUFtQixRQUFuQixLQUFtQjs7QUFDbEUsdUJBQ0csR0FESCxDQUNPLGVBRFAsRUFFRyxHQUZILENBRU8sZ0JBRlAsRUFFeUIsT0FBTyxZQUFQLENBQW9CLEtBRjdDLEVBR0csR0FISCxpQkFJRyxJQUpILENBSVEsVUFBQyxHQUFELEVBQVM7QUFDYixhQUFTLGFBQWEsWUFBdEIsRUFBb0MsSUFBSSxJQUF4QztBQUNBLFFBQUksUUFBSixFQUFjO0FBQ1osZUFBUyxJQUFJLElBQWI7QUFDRDtBQUNGLEdBVEgsRUFTSyxZQUFNO0FBQ1AsYUFBUyxhQUFhLGtCQUF0QixFQUEwQyxFQUExQztBQUNBLFFBQUksUUFBSixFQUFjO0FBQ1osZUFBUyxJQUFUO0FBQ0Q7QUFDRixHQWRIO0FBZUQsQ0FoQk07O0FBa0JQO0FBQ08sSUFBTSx3QkFBUSxTQUFSLEtBQVEsUUFBOEIsS0FBOUIsRUFBcUM7QUFBQSxNQUExQixRQUEwQixTQUExQixRQUEwQjtBQUFBLE1BQWhCLEtBQWdCLFNBQWhCLEtBQWdCOztBQUN4RCx1QkFDRyxJQURILENBQ1EsY0FEUixFQUVHLEdBRkgsaUJBR0csSUFISCxDQUdRLEtBSFIsRUFJRyxJQUpILENBSVEsVUFBQyxHQUFELEVBQVM7QUFDYixXQUFPLFlBQVAsQ0FBb0IsS0FBcEIsR0FBNEIsSUFBSSxJQUFKLENBQVMsS0FBckM7QUFDQSxhQUFTLGFBQWEsS0FBdEIsRUFBNkIsSUFBSSxJQUFqQztBQUNELEdBUEgsRUFPSyxZQUFNLENBQUUsQ0FQYjtBQVFELENBVE0iLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCAqIGFzIG11dGF0aW9uVHlwZSBmcm9tICcuLi9tdXRhdGlvblR5cGUnO1xuaW1wb3J0IGJhc2VVUkwgZnJvbSAnLi9iYXNlJztcblxuLy8g55So5oi36K6k6K+BXG5leHBvcnQgY29uc3QgYXV0aGVudGljYXRlID0gZnVuY3Rpb24oeyBkaXNwYXRjaCwgc3RhdGUgfSwgY2FsbGJhY2spIHtcbiAgcmVxdWVzdFxuICAgIC5nZXQoJy9hdXRoZW50aWNhdGUnKVxuICAgIC5zZXQoJ3gtYWNjZXNzLXRva2VuJywgd2luZG93LmxvY2FsU3RvcmFnZS50b2tlbilcbiAgICAudXNlKGJhc2VVUkwpXG4gICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgZGlzcGF0Y2gobXV0YXRpb25UeXBlLkFVVEhFTlRJQ0FURSwgcmVzLmJvZHkpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlcy5ib2R5KTtcbiAgICAgIH1cbiAgICB9LCAoKSA9PiB7XG4gICAgICBkaXNwYXRjaChtdXRhdGlvblR5cGUuQVVUSEVOVElDQVRFX0VSUk9SLCB7fSk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG4vLyDnlKjmiLfnmbvlvZVcbmV4cG9ydCBjb25zdCBsb2dpbiA9IGZ1bmN0aW9uKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIHBhcmFtKSB7XG4gIHJlcXVlc3RcbiAgICAucG9zdCgnL3VzZXJzL2xvZ2luJylcbiAgICAudXNlKGJhc2VVUkwpXG4gICAgLnNlbmQocGFyYW0pXG4gICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS50b2tlbiA9IHJlcy5ib2R5LnRva2VuO1xuICAgICAgZGlzcGF0Y2gobXV0YXRpb25UeXBlLkxPR0lOLCByZXMuYm9keSk7XG4gICAgfSwgKCkgPT4ge30pO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NyYy92dWV4L2FjdGlvbnMvdXNlci5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 46 */
/***/ function(module, exports) {

	eval("module.exports = \"\\n  <div>\\n    <router-view></router-view>\\n  <script type=\\\"x-template\\\" id=\\\"modal-template\\\">\\n    <div class=\\\"modal-mask\\\" v-if=\\\"show\\\" transition=\\\"modal-animation_default\\\">\\n      <div class=\\\"modal-wrapper\\\">\\n        <div class=\\\"modal-container\\\">\\n          <slot name=\\\"content\\\"></slot>\\n        </div>\\n      </div>\\n    </div>\\n  </script>\\n</div>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvYXBwLnZ1ZT84YjkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjQ2LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIlxcbiAgPGRpdj5cXG4gICAgPHJvdXRlci12aWV3Pjwvcm91dGVyLXZpZXc+XFxuICA8c2NyaXB0IHR5cGU9XFxcIngtdGVtcGxhdGVcXFwiIGlkPVxcXCJtb2RhbC10ZW1wbGF0ZVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLW1hc2tcXFwiIHYtaWY9XFxcInNob3dcXFwiIHRyYW5zaXRpb249XFxcIm1vZGFsLWFuaW1hdGlvbl9kZWZhdWx0XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC13cmFwcGVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWNvbnRhaW5lclxcXCI+XFxuICAgICAgICAgIDxzbG90IG5hbWU9XFxcImNvbnRlbnRcXFwiPjwvc2xvdD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvc2NyaXB0PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vYXBwL3NyYy9jb21wb25lbnRzL2FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_script__, __vue_template__\n__webpack_require__(48)\n__vue_script__ = __webpack_require__(49)\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] app/src/components/task/task.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = __webpack_require__(62)\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (false) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"_v-5ec98825/task.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrLnZ1ZT8wYjQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esc0JBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBLFlBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjQ3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhbGVzcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi90YXNrLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3Rhc2sudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIGFwcC9zcmMvY29tcG9uZW50cy90YXNrL3Rhc2sudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vdGFzay52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi01ZWM5ODgyNS90YXNrLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zcmMvY29tcG9uZW50cy90YXNrL3Rhc2sudnVlXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 48 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrLnZ1ZT8xYzlmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjQ4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vbGVzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2FwcC9zcmMvY29tcG9uZW50cy90YXNrL3Rhc2sudnVlXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _header = __webpack_require__(50);\n\nvar _header2 = _interopRequireDefault(_header);\n\nvar _sidemenu = __webpack_require__(6);\n\nvar _sidemenu2 = _interopRequireDefault(_sidemenu);\n\nvar _taskDetail = __webpack_require__(54);\n\nvar _taskDetail2 = _interopRequireDefault(_taskDetail);\n\nvar _lists = __webpack_require__(9);\n\nvar listsActions = _interopRequireWildcard(_lists);\n\nvar _getter = __webpack_require__(18);\n\nvar getters = _interopRequireWildcard(_getter);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  data: function data() {\n    return {};\n  },\n\n  vuex: {\n    actions: {\n      fetchLists: listsActions.fetchLists\n    },\n    getters: {\n      show: getters.isShowDetail,\n      auth: getters.getUserAuth\n    }\n  },\n  components: {\n    'app-header': _header2.default,\n    'side-menu': _sidemenu2.default,\n    'task-detail': _taskDetail2.default\n  },\n  created: function created() {\n    this.fetchLists();\n  },\n  ready: function ready() {},\n\n\n  methods: {}\n\n};\n\n// </script>\n// <style lang=\"less\">\n// </style>\n\n/* generated by vue-loader */\n// <template>\n//     <app-header></app-header>\n//     <div class=\"page-content\">\n//       <side-menu></side-menu>\n//       <router-view ></router-view>\n//       <task-detail v-if=\"show\"></task-detail>\n//     </div>\n// </template>\n//\n// <script>//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdGFzay52dWU/NDc3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFVQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOztJQUVBOzs7Ozs7O3dCQUVBO1dBRUE7QUFDQTs7OzsrQkFJQTtBQUZBOztvQkFJQTtvQkFHQTtBQUpBO0FBSkE7O0FBVUE7QUFDQTtBQUVBO0FBSkE7OEJBS0E7U0FDQTtBQUNBOzBCQUNBLENBRUE7OztXQUdBOztBQTNCQSIsImZpbGUiOiI0OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgICA8YXBwLWhlYWRlcj48L2FwcC1oZWFkZXI+XG4gICAgPGRpdiBjbGFzcz1cInBhZ2UtY29udGVudFwiPlxuICAgICAgPHNpZGUtbWVudT48L3NpZGUtbWVudT5cbiAgICAgIDxyb3V0ZXItdmlldyA+PC9yb3V0ZXItdmlldz5cbiAgICAgIDx0YXNrLWRldGFpbCB2LWlmPVwic2hvd1wiPjwvdGFzay1kZXRhaWw+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgSGVhZGVyVmlldyBmcm9tICcuLi9oZWFkZXIvaGVhZGVyLnZ1ZSc7XG4gIGltcG9ydCBTaWRlbWVudVZpZXcgZnJvbSAnLi9zaWRlbWVudS52dWUnO1xuICBpbXBvcnQgVGFza0RldGFpbFZpZXcgZnJvbSAnLi90YXNrRGV0YWlsLnZ1ZSc7XG5cbiAgaW1wb3J0ICogYXMgbGlzdHNBY3Rpb25zIGZyb20gJy4uLy4uL3Z1ZXgvYWN0aW9ucy9saXN0cyc7XG4gIGltcG9ydCAqIGFzIGdldHRlcnMgZnJvbSAnLi4vLi4vdnVleC9nZXR0ZXInO1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgIH07XG4gICAgfSxcbiAgICB2dWV4OiB7XG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIGZldGNoTGlzdHM6IGxpc3RzQWN0aW9ucy5mZXRjaExpc3RzLFxuICAgICAgfSxcbiAgICAgIGdldHRlcnM6IHtcbiAgICAgICAgc2hvdzogZ2V0dGVycy5pc1Nob3dEZXRhaWwsXG4gICAgICAgIGF1dGg6IGdldHRlcnMuZ2V0VXNlckF1dGgsXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAnYXBwLWhlYWRlcic6IEhlYWRlclZpZXcsXG4gICAgICAnc2lkZS1tZW51JzogU2lkZW1lbnVWaWV3LFxuICAgICAgJ3Rhc2stZGV0YWlsJzogVGFza0RldGFpbFZpZXcsXG4gICAgfSxcbiAgICBjcmVhdGVkKCkge1xuICAgICAgdGhpcy5mZXRjaExpc3RzKCk7XG4gICAgfSxcbiAgICByZWFkeSgpIHtcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgIH0sXG5cbiAgfTtcblxuPC9zY3JpcHQ+XG48c3R5bGUgbGFuZz1cImxlc3NcIj5cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB0YXNrLnZ1ZT81ZTdmODcwOVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_script__, __vue_template__\n__webpack_require__(51)\n__vue_script__ = __webpack_require__(52)\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] app/src/components/header/header.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = __webpack_require__(53)\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (false) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"_v-babe54b6/header.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvaGVhZGVyL2hlYWRlci52dWU/NGNlYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHNCQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQSxZQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI1MC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIWxlc3MhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vaGVhZGVyLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2hlYWRlci52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gYXBwL3NyYy9jb21wb25lbnRzL2hlYWRlci9oZWFkZXIudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vaGVhZGVyLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LWJhYmU1NGI2L2hlYWRlci52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hcHAvc3JjL2NvbXBvbmVudHMvaGVhZGVyL2hlYWRlci52dWVcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 51 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvaGVhZGVyL2hlYWRlci52dWU/NWIyYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI1MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L2xlc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9hcHAvc3JjL2NvbXBvbmVudHMvaGVhZGVyL2hlYWRlci52dWVcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getter = __webpack_require__(18);\n\nvar getters = _interopRequireWildcard(_getter);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nexports.default = {\n  data: function data() {\n    return {};\n  },\n\n  vuex: {\n    actions: {},\n    getters: {\n      user: getters.getUserInfo\n    }\n  },\n  ready: function ready() {},\n\n  methods: {}\n\n};\n\n// </script>\n// <style lang=\"less\">\n// @import '../../public/stylesheets/variables';\n//\n// // .logo {\n// //   font-size: 30px;\n// //   width: @sideMenuWidth;\n// //   text-indent: 24px;\n// // }\n// .navigation{\n//   &-account{\n//     width: @sideMenuWidth - 20;\n//     display: flex;\n//     align-items: center;\n//     justify-content: flex-start;\n//     img{\n//       width: 40px;\n//       height: 40px;\n//       margin-right: 10px;\n//       border-radius: 100%;\n//     }\n//   }\n//\n//   &-search{\n//     margin-left: 20px;\n//     flex: 1 0 auto;\n//   }\n// }\n// .header{\n//   display: flex;\n//   box-sizing: border-box;\n//   height: 60px;\n//   width: 100%;\n//   padding: 0 20px;\n//   background: fade(#fff, 85%);\n//   box-shadow: 0 1px 2px rgba(0,0,0,0.05);\n//   position: fixed;\n//   z-index: 100;\n//   align-items: center;\n//   flex-direction: row-reverse;\n//   // justify-content: space-between;\n//   justify-content: flex-end;\n// }\n// </style>\n\n/* generated by vue-loader */\n// <template>\n//   <header class=\"header\">\n// <!--     <div class=\"logo\">\n//       BlueRobin\n//     </div> -->\n//     <div class=\"navigation-search\">\n//       <div class=\"robin-textfield\">\n//         <input type=\"text\" class=\"robin-textfield--input robin-textfield--input_default\" />\n//       </div>\n//     </div>\n//     <div v-if=\"user\" class=\"navigation-account\">\n//       <img v-bind:src=\"user.avatar\" alt=\"\">\n//       {{user.username}}\n//     </div>\n//   </header>\n// </template>\n//\n// <script>//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vaGVhZGVyLnZ1ZT80YjliIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQWtCQTs7SUFDQTs7Ozs7d0JBRUE7V0FFQTtBQUNBOzs7YUFHQTs7b0JBSUE7QUFIQTtBQUhBOzBCQU9BLENBQ0E7O1dBR0E7O0FBaEJBIiwiZmlsZSI6IjUyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8aGVhZGVyIGNsYXNzPVwiaGVhZGVyXCI+XG48IS0tICAgICA8ZGl2IGNsYXNzPVwibG9nb1wiPlxuICAgICAgQmx1ZVJvYmluXG4gICAgPC9kaXY+IC0tPlxuICAgIDxkaXYgY2xhc3M9XCJuYXZpZ2F0aW9uLXNlYXJjaFwiPlxuICAgICAgPGRpdiBjbGFzcz1cInJvYmluLXRleHRmaWVsZFwiPlxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cInJvYmluLXRleHRmaWVsZC0taW5wdXQgcm9iaW4tdGV4dGZpZWxkLS1pbnB1dF9kZWZhdWx0XCIgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgdi1pZj1cInVzZXJcIiBjbGFzcz1cIm5hdmlnYXRpb24tYWNjb3VudFwiPlxuICAgICAgPGltZyB2LWJpbmQ6c3JjPVwidXNlci5hdmF0YXJcIiBhbHQ9XCJcIj5cbiAgICAgIHt7dXNlci51c2VybmFtZX19XG4gICAgPC9kaXY+XG4gIDwvaGVhZGVyPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbiAgaW1wb3J0ICogYXMgZ2V0dGVycyBmcm9tICcuLi8uLi92dWV4L2dldHRlcic7XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgIH07XG4gICAgfSxcbiAgICB2dWV4OiB7XG4gICAgICBhY3Rpb25zOiB7XG4gICAgICB9LFxuICAgICAgZ2V0dGVyczoge1xuICAgICAgICB1c2VyOiBnZXR0ZXJzLmdldFVzZXJJbmZvLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHJlYWR5KCkge1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgIH0sXG5cbiAgfTtcblxuPC9zY3JpcHQ+XG48c3R5bGUgbGFuZz1cImxlc3NcIj5cbkBpbXBvcnQgJy4uLy4uL3B1YmxpYy9zdHlsZXNoZWV0cy92YXJpYWJsZXMnO1xuXG4vLyAubG9nbyB7XG4vLyAgIGZvbnQtc2l6ZTogMzBweDtcbi8vICAgd2lkdGg6IEBzaWRlTWVudVdpZHRoO1xuLy8gICB0ZXh0LWluZGVudDogMjRweDtcbi8vIH1cbi5uYXZpZ2F0aW9ue1xuICAmLWFjY291bnR7XG4gICAgd2lkdGg6IEBzaWRlTWVudVdpZHRoIC0gMjA7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICBpbWd7XG4gICAgICB3aWR0aDogNDBweDtcbiAgICAgIGhlaWdodDogNDBweDtcbiAgICAgIG1hcmdpbi1yaWdodDogMTBweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XG4gICAgfVxuICB9XG5cbiAgJi1zZWFyY2h7XG4gICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgZmxleDogMSAwIGF1dG87XG4gIH1cbn1cbi5oZWFkZXJ7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIGhlaWdodDogNjBweDtcbiAgd2lkdGg6IDEwMCU7XG4gIHBhZGRpbmc6IDAgMjBweDtcbiAgYmFja2dyb3VuZDogZmFkZSgjZmZmLCA4NSUpO1xuICBib3gtc2hhZG93OiAwIDFweCAycHggcmdiYSgwLDAsMCwwLjA1KTtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB6LWluZGV4OiAxMDA7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcbiAgLy8ganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIGhlYWRlci52dWU/MGEyNjQzYTVcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 53 */
/***/ function(module, exports) {

	eval("module.exports = \"\\n  <header class=\\\"header\\\">\\n<!--     <div class=\\\"logo\\\">\\n      BlueRobin\\n    </div> -->\\n    <div class=\\\"navigation-search\\\">\\n      <div class=\\\"robin-textfield\\\">\\n        <input type=\\\"text\\\" class=\\\"robin-textfield--input robin-textfield--input_default\\\" />\\n      </div>\\n    </div>\\n    <div v-if=\\\"user\\\" class=\\\"navigation-account\\\">\\n      <img v-bind:src=\\\"user.avatar\\\" alt=\\\"\\\">\\n      {{user.username}}\\n    </div>\\n  </header>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvaGVhZGVyL2hlYWRlci52dWU/NmEzMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx5YUFBeWEsZUFBZSIsImZpbGUiOiI1My5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJcXG4gIDxoZWFkZXIgY2xhc3M9XFxcImhlYWRlclxcXCI+XFxuPCEtLSAgICAgPGRpdiBjbGFzcz1cXFwibG9nb1xcXCI+XFxuICAgICAgQmx1ZVJvYmluXFxuICAgIDwvZGl2PiAtLT5cXG4gICAgPGRpdiBjbGFzcz1cXFwibmF2aWdhdGlvbi1zZWFyY2hcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInJvYmluLXRleHRmaWVsZFxcXCI+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcInJvYmluLXRleHRmaWVsZC0taW5wdXQgcm9iaW4tdGV4dGZpZWxkLS1pbnB1dF9kZWZhdWx0XFxcIiAvPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiB2LWlmPVxcXCJ1c2VyXFxcIiBjbGFzcz1cXFwibmF2aWdhdGlvbi1hY2NvdW50XFxcIj5cXG4gICAgICA8aW1nIHYtYmluZDpzcmM9XFxcInVzZXIuYXZhdGFyXFxcIiBhbHQ9XFxcIlxcXCI+XFxuICAgICAge3t1c2VyLnVzZXJuYW1lfX1cXG4gICAgPC9kaXY+XFxuICA8L2hlYWRlcj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2FwcC9zcmMvY29tcG9uZW50cy9oZWFkZXIvaGVhZGVyLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_script__, __vue_template__\n__webpack_require__(55)\n__vue_script__ = __webpack_require__(57)\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] app/src/components/task/taskDetail.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = __webpack_require__(61)\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (false) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"_v-076c6354/taskDetail.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrRGV0YWlsLnZ1ZT82ODQ4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esc0JBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBLFlBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjU0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhbGVzcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi90YXNrRGV0YWlsLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3Rhc2tEZXRhaWwudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIGFwcC9zcmMvY29tcG9uZW50cy90YXNrL3Rhc2tEZXRhaWwudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vdGFza0RldGFpbC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0wNzZjNjM1NC90YXNrRGV0YWlsLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zcmMvY29tcG9uZW50cy90YXNrL3Rhc2tEZXRhaWwudnVlXG4gKiogbW9kdWxlIGlkID0gNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 55 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrRGV0YWlsLnZ1ZT85NzZmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjU1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vbGVzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2FwcC9zcmMvY29tcG9uZW50cy90YXNrL3Rhc2tEZXRhaWwudnVlXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 56 */,
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _tasks = __webpack_require__(58);\n\nvar tasksActions = _interopRequireWildcard(_tasks);\n\nvar _getter = __webpack_require__(18);\n\nvar getters = _interopRequireWildcard(_getter);\n\nvar _marked = __webpack_require__(59);\n\nvar _marked2 = _interopRequireDefault(_marked);\n\nvar _tool = __webpack_require__(60);\n\nvar _tool2 = _interopRequireDefault(_tool);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// <template>\n//   <div class=\"modal-mask modal-animation_sign\" transition=\"modal-animation_sign\">\n//     <div class=\"modal-wrapper\" @click=\"close()\" >\n//       <div class=\"modal-container\">\n//         <div class=\"card\" @click.stop>\n//           <div class=\"card-header\">\n//             <label class=\"robin-checkbox\" for=\"{{task.id}}\">\n//               <input type=\"checkbox\" id=\"{{task.id}}\" class=\"robin-checkbox--input\" v-on:change=\"toggleTask(task)\" :checked=\"task.completed\">\n//               <span class=\"robin-checkbox--label\"></span>\n//             </label>\n//             <input class=\"card-header--title card-header--input\" :value=\"task.title\" v-autoblur=\"isTitleEditing\" @focus=\"isTitleEditing = true\" @keyup.esc=\"cancelEdit\" @keyup.enter=\"doEditTitle\" />\n//           </div>\n//           <div class=\"card-body\">\n//             <div class=\"card-metadata\">\n//               <!--  标签 -->\n// <!--               <div class=\"card-metadata-item\">\n//                 <span class=\"material-icons card-metadata-item--icons\">label_outline</span>\n//\n//               </div> -->\n//               <div class=\"card-metadata-item\">\n//                 <span class=\"material-icons card-metadata-item--icons\">insert_invitation</span>\n//                 <span class=\"card-metadata-item--content\">{{task.deadline}}</span>\n//               </div>\n//               <div class=\"card-metadata-item\">\n//                 <span class=\"material-icons card-metadata-item--icons\">create</span>\n//                 <div class=\"card-metadata-item--content\" v-bind:class=\"{editing: isDescEditing}\" @dblclick=\"modifyDesc\">\n//                   <div class=\"content-value markdownPrased\">{{{descriptionMarked}}}</div>\n//                   <textarea class=\"content-input\" v-autofocus=\"isDescEditing\" @keyup.esc=\"doEditDesc\" @blur=\"doEditDesc\" v-model=\"task.description\"></textarea>\n//                 </div>\n//               </div>\n//               <!-- 子任务 -->\n// <!--               <div class=\"card-subtasks\">\n//                 <ul>\n//                   <li></li>\n//                 </ul>\n//                 <div class=\"card-metadata-item\">\n//                   <span class=\"material-icons card-metadata-item--icons\">add</span>\n//                 </div>\n//               </div> -->\n//             </div>\n//           </div>\n//           <div class=\"card-footer\">\n//               <span></span>\n//               <div> 创建于：{{task.create_time}}</div>\n//               <span></span>\n//           </div>\n//         </div>\n//       </div>\n//     </div>\n//   </div>\n// </template>\n// <script>\n_marked2.default.setOptions({\n  renderer: new _marked2.default.Renderer(),\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: true,\n  smartLists: true,\n  smartypants: false\n});\n\nexports.default = {\n  data: function data() {\n    return {\n      isTitleEditing: false,\n      isDescEditing: false\n    };\n  },\n\n  vuex: {\n    actions: {\n      edit: tasksActions.editTask,\n      hideTaskDetail: tasksActions.hideTaskDetail\n    },\n    getters: {\n      task: getters.getTaskDetail\n    }\n  },\n  ready: function ready() {\n    var _this = this;\n    document.addEventListener('keyup', function (e) {\n      if (e.keyCode === 27) {\n        _this.hideTaskDetail();\n      }\n    });\n  },\n\n  computed: {\n    descriptionMarked: function descriptionMarked() {\n      return (0, _marked2.default)(this.task.description || '暂无描述');\n    },\n    descriptionEncode: function descriptionEncode() {\n      return _tool2.default.htmlEncode(this.task.description);\n    }\n  },\n  directives: {\n    'autofocus': function autofocus(value) {\n      if (!value) {\n        return;\n      }\n      var el = this.el;\n      setTimeout(function () {\n        el.focus();\n      }, 0);\n    },\n    'autoblur': function autoblur(value) {\n      if (value) {\n        return;\n      }\n      var el = this.el;\n      setTimeout(function () {\n        el.blur();\n      }, 0);\n    }\n  },\n  methods: {\n    close: function close() {\n      this.hideTaskDetail();\n    },\n    cancelEdit: function cancelEdit(e) {\n      e.target.value = this.task.title;\n      this.isTitleEditing = false;\n      e.stopPropagation();\n    },\n    modifyDesc: function modifyDesc() {\n      console.log('modifyDesc');\n      this.isDescEditing = true;\n    },\n    doEditTitle: function doEditTitle(e) {\n      var task = this.task;\n      var param = {\n        title: e.target.value.trim()\n      };\n      if (!param.title) {\n        return false;\n      }\n      this.isTitleEditing = false;\n      this.edit(task.id, param);\n    },\n    doEditDesc: function doEditDesc(e) {\n      var task = this.task;\n      var param = {\n        description: e.target.value.trim()\n      };\n      if (!param.description) {\n        return false;\n      }\n      this.isDescEditing = false;\n      this.edit(task.id, param);\n      e.stopPropagation();\n    }\n  }\n};\n// </script>\n// <style lang=\"less\">\n//\n//   @container-background: #f7f7f7;\n//   @container-header-background: #fff;\n//   @modal-spearate-line: #ebebeb;\n//\n//   @card-width: 680px;\n//\n//\n//   .card {\n//     display: flex;\n//     flex-direction: column;\n//     width: @card-width;\n//     height: 540px;\n//     margin: 0 auto;\n//     background: @container-background;\n//     border-radius: 2px;\n//     box-shadow: 0 2px 8px rgba(0, 0, 0, .33);\n//     transition: all 300ms 0s;\n//   }\n//\n//   .card-header {\n//     display: flex;\n//     min-height: 55px;\n//     box-sizing: border-box;\n//     align-items: center;\n//     margin-top: 0;\n//     color: spin(#000, 60%);\n//     padding: 16px 18px;\n//     border-bottom: 1px solid @modal-spearate-line;\n//     background: @container-header-background;\n//     &--input {\n//       width: 100%;\n//       padding: 0 10px;\n//       background: @container-header-background;\n//       font-size: 18px;\n//       font-weight: bolder;\n//       box-sizing: border-box;\n//       border: none;\n//       outline: none;\n//       &:focus {\n//         background: @container-header-background;\n//       }\n//     }\n//   }\n//\n//   .card-body {\n//     overflow-y: auto;\n//     flex: 1 1 auto;\n//   }\n//\n//   .card-metadata {\n//     padding: 8px 0;\n//     &-item {\n//       display: flex;\n//       min-height: 46px;\n//       box-sizing: border-box;\n//       align-items: flex-start;\n//       padding: 6px 14px;\n//       position: relative;\n//       &::after {\n//         content: '';\n//         height: 0;\n//         border-bottom: 1px solid @modal-spearate-line;\n//         position: absolute;\n//         left: 50px;\n//         right: 50px;\n//         bottom: 0;\n//       }\n//       &--icons {\n//         margin-right: 6px;\n//         padding: 4px;\n//       }\n//       &--content {\n//         font-size: 14px;\n//         padding: 5px 0;\n//         width: @card-width - 100px;\n//         .content-input {\n//           display: none;\n//           height: 300px;\n//           width: 100%;\n//           box-sizing: border-box;\n//           border: none;\n//           resize: none;\n//           outline: none;\n//           font-size: 14px;\n//           background: none;\n//         }\n//         &.editing {\n//           .content-input {\n//             display: block;\n//           }\n//           .content-value {\n//             display: none;\n//           }\n//         }\n//       }\n//     }\n//   }\n//\n//   .card-footer {\n//     min-height: 56px;\n//     font-size: 14px;\n//     color: #a3a3a2;\n//     border-top: 1px solid @modal-spearate-line;\n//     background: @container-header-background;\n//     text-align: center;\n//     display: flex;\n//     justify-content: space-between;\n//     align-items: center;\n//   }\n//\n//\n// </style>\n/* generated by vue-loader *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdGFza0RldGFpbC52dWU/NDQ2ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFvREE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO2lDQUVBO09BQ0E7VUFDQTtVQUNBO1lBQ0E7WUFDQTtjQUNBO2VBR0E7QUFWQTs7O3dCQVlBOztzQkFFQTtxQkFFQTtBQUhBO0FBSUE7Ozs7eUJBR0E7bUNBRUE7QUFIQTs7b0JBT0E7QUFIQTtBQUxBOzBCQVNBO2dCQUNBO29EQUNBOzRCQUNBO2NBQ0E7QUFDQTtBQUNBO0FBQ0E7OztvREFFQTs0REFDQTtBQUNBO29EQUNBO2lEQUNBO0FBRUE7QUFQQTs7MkNBU0E7a0JBQ0E7QUFDQTtBQUNBO29CQUNBOzZCQUNBO1dBQ0E7U0FDQTtBQUNBO3lDQUNBO2lCQUNBO0FBQ0E7QUFDQTtvQkFDQTs2QkFDQTtXQUNBO1NBQ0E7QUFFQTtBQW5CQTs7NEJBcUJBO1dBQ0E7QUFDQTt1Q0FDQTtpQ0FDQTs0QkFDQTtRQUNBO0FBQ0E7c0NBQ0E7a0JBQ0E7MkJBQ0E7QUFDQTt5Q0FDQTtzQkFDQTs7OEJBR0E7QUFGQTt3QkFHQTtlQUNBO0FBQ0E7NEJBQ0E7eUJBQ0E7QUFDQTt1Q0FDQTtzQkFDQTs7b0NBR0E7QUFGQTs4QkFHQTtlQUNBO0FBQ0E7MkJBQ0E7eUJBQ0E7UUFDQTtBQUVBO0FBcENBO0FBcERBIiwiZmlsZSI6IjU3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibW9kYWwtbWFzayBtb2RhbC1hbmltYXRpb25fc2lnblwiIHRyYW5zaXRpb249XCJtb2RhbC1hbmltYXRpb25fc2lnblwiPlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC13cmFwcGVyXCIgQGNsaWNrPVwiY2xvc2UoKVwiID5cbiAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250YWluZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRcIiBAY2xpY2suc3RvcD5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1oZWFkZXJcIj5cbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInJvYmluLWNoZWNrYm94XCIgZm9yPVwie3t0YXNrLmlkfX1cIj5cbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwie3t0YXNrLmlkfX1cIiBjbGFzcz1cInJvYmluLWNoZWNrYm94LS1pbnB1dFwiIHYtb246Y2hhbmdlPVwidG9nZ2xlVGFzayh0YXNrKVwiIDpjaGVja2VkPVwidGFzay5jb21wbGV0ZWRcIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJyb2Jpbi1jaGVja2JveC0tbGFiZWxcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiY2FyZC1oZWFkZXItLXRpdGxlIGNhcmQtaGVhZGVyLS1pbnB1dFwiIDp2YWx1ZT1cInRhc2sudGl0bGVcIiB2LWF1dG9ibHVyPVwiaXNUaXRsZUVkaXRpbmdcIiBAZm9jdXM9XCJpc1RpdGxlRWRpdGluZyA9IHRydWVcIiBAa2V5dXAuZXNjPVwiY2FuY2VsRWRpdFwiIEBrZXl1cC5lbnRlcj1cImRvRWRpdFRpdGxlXCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1tZXRhZGF0YVwiPlxuICAgICAgICAgICAgICA8IS0tICDmoIfnrb4gLS0+XG48IS0tICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtbWV0YWRhdGEtaXRlbVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnMgY2FyZC1tZXRhZGF0YS1pdGVtLS1pY29uc1wiPmxhYmVsX291dGxpbmU8L3NwYW4+XG5cbiAgICAgICAgICAgICAgPC9kaXY+IC0tPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1tZXRhZGF0YS1pdGVtXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJtYXRlcmlhbC1pY29ucyBjYXJkLW1ldGFkYXRhLWl0ZW0tLWljb25zXCI+aW5zZXJ0X2ludml0YXRpb248L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjYXJkLW1ldGFkYXRhLWl0ZW0tLWNvbnRlbnRcIj57e3Rhc2suZGVhZGxpbmV9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLW1ldGFkYXRhLWl0ZW1cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm1hdGVyaWFsLWljb25zIGNhcmQtbWV0YWRhdGEtaXRlbS0taWNvbnNcIj5jcmVhdGU8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtbWV0YWRhdGEtaXRlbS0tY29udGVudFwiIHYtYmluZDpjbGFzcz1cIntlZGl0aW5nOiBpc0Rlc2NFZGl0aW5nfVwiIEBkYmxjbGljaz1cIm1vZGlmeURlc2NcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50LXZhbHVlIG1hcmtkb3duUHJhc2VkXCI+e3t7ZGVzY3JpcHRpb25NYXJrZWR9fX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBjbGFzcz1cImNvbnRlbnQtaW5wdXRcIiB2LWF1dG9mb2N1cz1cImlzRGVzY0VkaXRpbmdcIiBAa2V5dXAuZXNjPVwiZG9FZGl0RGVzY1wiIEBibHVyPVwiZG9FZGl0RGVzY1wiIHYtbW9kZWw9XCJ0YXNrLmRlc2NyaXB0aW9uXCI+PC90ZXh0YXJlYT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwhLS0g5a2Q5Lu75YqhIC0tPlxuPCEtLSAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLXN1YnRhc2tzXCI+XG4gICAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICAgPGxpPjwvbGk+XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1tZXRhZGF0YS1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm1hdGVyaWFsLWljb25zIGNhcmQtbWV0YWRhdGEtaXRlbS0taWNvbnNcIj5hZGQ8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PiAtLT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWZvb3RlclwiPlxuICAgICAgICAgICAgICA8c3Bhbj48L3NwYW4+XG4gICAgICAgICAgICAgIDxkaXY+IOWIm+W7uuS6ju+8mnt7dGFzay5jcmVhdGVfdGltZX19PC9kaXY+XG4gICAgICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbiAgaW1wb3J0ICogYXMgdGFza3NBY3Rpb25zIGZyb20gJy4uLy4uL3Z1ZXgvYWN0aW9ucy90YXNrcyc7XG4gIGltcG9ydCAqIGFzIGdldHRlcnMgZnJvbSAnLi4vLi4vdnVleC9nZXR0ZXInO1xuICBpbXBvcnQgbWFya2VkIGZyb20gJ21hcmtlZCc7XG4gIGltcG9ydCBUb29sIGZyb20gJ3Rvb2wnO1xuICBtYXJrZWQuc2V0T3B0aW9ucyh7XG4gICAgcmVuZGVyZXI6IG5ldyBtYXJrZWQuUmVuZGVyZXIoKSxcbiAgICBnZm06IHRydWUsXG4gICAgdGFibGVzOiB0cnVlLFxuICAgIGJyZWFrczogZmFsc2UsXG4gICAgcGVkYW50aWM6IGZhbHNlLFxuICAgIHNhbml0aXplOiB0cnVlLFxuICAgIHNtYXJ0TGlzdHM6IHRydWUsXG4gICAgc21hcnR5cGFudHM6IGZhbHNlXG4gIH0pO1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNUaXRsZUVkaXRpbmc6IGZhbHNlLFxuICAgICAgICBpc0Rlc2NFZGl0aW5nOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfSxcbiAgICB2dWV4OiB7XG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIGVkaXQ6IHRhc2tzQWN0aW9ucy5lZGl0VGFzayxcbiAgICAgICAgaGlkZVRhc2tEZXRhaWw6IHRhc2tzQWN0aW9ucy5oaWRlVGFza0RldGFpbCxcbiAgICAgIH0sXG4gICAgICBnZXR0ZXJzOiB7XG4gICAgICAgIHRhc2s6IGdldHRlcnMuZ2V0VGFza0RldGFpbCxcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlYWR5KCkge1xuICAgICAgbGV0IF90aGlzID0gdGhpcztcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGUpID0+IHtcbiAgICAgICAgaWYoZS5rZXlDb2RlID09PSAyNyl7XG4gICAgICAgICAgX3RoaXMuaGlkZVRhc2tEZXRhaWwoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgZGVzY3JpcHRpb25NYXJrZWQoKSB7XG4gICAgICAgIHJldHVybiBtYXJrZWQodGhpcy50YXNrLmRlc2NyaXB0aW9uIHx8ICfmmoLml6Dmj4/ov7AnKTtcbiAgICAgIH0sXG4gICAgICBkZXNjcmlwdGlvbkVuY29kZSgpIHtcbiAgICAgICAgcmV0dXJuIFRvb2wuaHRtbEVuY29kZSh0aGlzLnRhc2suZGVzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgJ2F1dG9mb2N1cycodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH0sXG4gICAgICAnYXV0b2JsdXInKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBlbC5ibHVyKCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuaGlkZVRhc2tEZXRhaWwoKTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWxFZGl0KGUpIHtcbiAgICAgICAgZS50YXJnZXQudmFsdWUgPSB0aGlzLnRhc2sudGl0bGU7XG4gICAgICAgIHRoaXMuaXNUaXRsZUVkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0sXG4gICAgICBtb2RpZnlEZXNjKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnbW9kaWZ5RGVzYycpO1xuICAgICAgICB0aGlzLmlzRGVzY0VkaXRpbmcgID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBkb0VkaXRUaXRsZShlKSB7XG4gICAgICAgIGxldCB0YXNrID0gdGhpcy50YXNrO1xuICAgICAgICBsZXQgcGFyYW0gPSB7XG4gICAgICAgICAgdGl0bGU6IGUudGFyZ2V0LnZhbHVlLnRyaW0oKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFwYXJhbS50aXRsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzVGl0bGVFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZWRpdCh0YXNrLmlkLCBwYXJhbSk7XG4gICAgICB9LFxuICAgICAgZG9FZGl0RGVzYyhlKSB7XG4gICAgICAgIGxldCB0YXNrID0gdGhpcy50YXNrO1xuICAgICAgICBsZXQgcGFyYW0gPSB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IGUudGFyZ2V0LnZhbHVlLnRyaW0oKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFwYXJhbS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRGVzY0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lZGl0KHRhc2suaWQsIHBhcmFtKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuPC9zY3JpcHQ+XG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblxuICBAY29udGFpbmVyLWJhY2tncm91bmQ6ICNmN2Y3Zjc7XG4gIEBjb250YWluZXItaGVhZGVyLWJhY2tncm91bmQ6ICNmZmY7XG4gIEBtb2RhbC1zcGVhcmF0ZS1saW5lOiAjZWJlYmViO1xuXG4gIEBjYXJkLXdpZHRoOiA2ODBweDtcblxuXG4gIC5jYXJkIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgd2lkdGg6IEBjYXJkLXdpZHRoO1xuICAgIGhlaWdodDogNTQwcHg7XG4gICAgbWFyZ2luOiAwIGF1dG87XG4gICAgYmFja2dyb3VuZDogQGNvbnRhaW5lci1iYWNrZ3JvdW5kO1xuICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICBib3gtc2hhZG93OiAwIDJweCA4cHggcmdiYSgwLCAwLCAwLCAuMzMpO1xuICAgIHRyYW5zaXRpb246IGFsbCAzMDBtcyAwcztcbiAgfVxuXG4gIC5jYXJkLWhlYWRlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBtaW4taGVpZ2h0OiA1NXB4O1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICAgIGNvbG9yOiBzcGluKCMwMDAsIDYwJSk7XG4gICAgcGFkZGluZzogMTZweCAxOHB4O1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBAbW9kYWwtc3BlYXJhdGUtbGluZTtcbiAgICBiYWNrZ3JvdW5kOiBAY29udGFpbmVyLWhlYWRlci1iYWNrZ3JvdW5kO1xuICAgICYtLWlucHV0IHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgcGFkZGluZzogMCAxMHB4O1xuICAgICAgYmFja2dyb3VuZDogQGNvbnRhaW5lci1oZWFkZXItYmFja2dyb3VuZDtcbiAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICY6Zm9jdXMge1xuICAgICAgICBiYWNrZ3JvdW5kOiBAY29udGFpbmVyLWhlYWRlci1iYWNrZ3JvdW5kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC5jYXJkLWJvZHkge1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgZmxleDogMSAxIGF1dG87XG4gIH1cblxuICAuY2FyZC1tZXRhZGF0YSB7XG4gICAgcGFkZGluZzogOHB4IDA7XG4gICAgJi1pdGVtIHtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBtaW4taGVpZ2h0OiA0NnB4O1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuICAgICAgcGFkZGluZzogNnB4IDE0cHg7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAmOjphZnRlciB7XG4gICAgICAgIGNvbnRlbnQ6ICcnO1xuICAgICAgICBoZWlnaHQ6IDA7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBAbW9kYWwtc3BlYXJhdGUtbGluZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiA1MHB4O1xuICAgICAgICByaWdodDogNTBweDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgfVxuICAgICAgJi0taWNvbnMge1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDZweDtcbiAgICAgICAgcGFkZGluZzogNHB4O1xuICAgICAgfVxuICAgICAgJi0tY29udGVudCB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgcGFkZGluZzogNXB4IDA7XG4gICAgICAgIHdpZHRoOiBAY2FyZC13aWR0aCAtIDEwMHB4O1xuICAgICAgICAuY29udGVudC1pbnB1dCB7XG4gICAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgICBoZWlnaHQ6IDMwMHB4O1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgIHJlc2l6ZTogbm9uZTtcbiAgICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBub25lO1xuICAgICAgICB9XG4gICAgICAgICYuZWRpdGluZyB7XG4gICAgICAgICAgLmNvbnRlbnQtaW5wdXQge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgfVxuICAgICAgICAgIC5jb250ZW50LXZhbHVlIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLmNhcmQtZm9vdGVyIHtcbiAgICBtaW4taGVpZ2h0OiA1NnB4O1xuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBjb2xvcjogI2EzYTNhMjtcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgQG1vZGFsLXNwZWFyYXRlLWxpbmU7XG4gICAgYmFja2dyb3VuZDogQGNvbnRhaW5lci1oZWFkZXItYmFja2dyb3VuZDtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxuXG5cbjwvc3R5bGU+XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogdGFza0RldGFpbC52dWU/ZDE2YjBmMTZcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.editTask = exports.deleteTask = exports.toggleTask = exports.addTask = exports.hideTaskDetail = exports.fetchTaskDetail = exports.fetchTasks = undefined;\n\nvar _superagent = __webpack_require__(10);\n\nvar _superagent2 = _interopRequireDefault(_superagent);\n\nvar _mutationType = __webpack_require__(15);\n\nvar mutationType = _interopRequireWildcard(_mutationType);\n\nvar _base = __webpack_require__(16);\n\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar requestTasks = function requestTasks(query) {\n  return _superagent2.default.get('/tasks').query(query).set('x-access-token', window.localStorage.token).use(_base2.default);\n};\n\nvar fetchTasks = exports.fetchTasks = function fetchTasks(_ref, query, callback) {\n  var dispatch = _ref.dispatch;\n  var state = _ref.state;\n\n  requestTasks(query).then(function (res) {\n    if (typeof callback === 'function') {\n      callback(res);\n    }\n    dispatch(mutationType.FETCH_TASKS, query, res.body);\n  }, function (err) {\n    dispatch(mutationType.FETCH_TASKS_ERROR, err);\n  });\n};\n\nvar fetchTaskDetail = exports.fetchTaskDetail = function fetchTaskDetail(_ref2, taskid) {\n  var dispatch = _ref2.dispatch;\n  var state = _ref2.state;\n\n  _superagent2.default.get('/tasks/' + taskid).set('x-access-token', window.localStorage.token).use(_base2.default).then(function (res) {\n    dispatch(mutationType.FETCH_TASK_DETAIL, res.body);\n  }, function (err) {\n    dispatch(mutationType.FETCH_TASK_DETAIL_ERROR, err);\n  });\n};\n\nvar hideTaskDetail = exports.hideTaskDetail = function hideTaskDetail(_ref3) {\n  var dispatch = _ref3.dispatch;\n\n  dispatch(mutationType.HIDE_DETAIL_WINDOW);\n};\n\nvar addTask = exports.addTask = function addTask(_ref4, task) {\n  var dispatch = _ref4.dispatch;\n  var state = _ref4.state;\n\n  _superagent2.default.post('/tasks').send(task).set('x-access-token', window.localStorage.token).use(_base2.default).then(function (res) {\n    dispatch(mutationType.ADD_TASK, res.body);\n    dispatch(mutationType.UPDATE_LIST, { id: task.list_id, type: 'total', update: 1 });\n  }, function (err) {\n    dispatch(mutationType.ADD_TASK_ERROR, err);\n  });\n};\n\nvar toggleTask = exports.toggleTask = function toggleTask(_ref5, taskid, param) {\n  var dispatch = _ref5.dispatch;\n  var state = _ref5.state;\n\n  _superagent2.default.put('/tasks/' + taskid).send(param).set('x-access-token', window.localStorage.token).use(_base2.default).then(function (res) {\n    dispatch(mutationType.EDIT_TASK, res.body);\n    if (param.completed) {\n      dispatch(mutationType.UPDATE_LIST, { id: res.body.list_id, type: 'completed', update: 1 });\n    } else {\n      dispatch(mutationType.UPDATE_LIST, { id: res.body.list_id, type: 'completed', update: -1 });\n    }\n  }, function (err) {\n    dispatch(mutationType.EDIT_TASK_ERROR, err);\n  });\n};\n\nvar deleteTask = exports.deleteTask = function deleteTask(_ref6, taskid) {\n  var dispatch = _ref6.dispatch;\n  var state = _ref6.state;\n\n  _superagent2.default.delete('/tasks/' + taskid).set('x-access-token', window.localStorage.token).use(_base2.default).then(function (res) {\n    dispatch(mutationType.DELETE_TASK, res.body);\n    dispatch(mutationType.UPDATE_LIST, { id: res.body.list_id, type: 'total', update: -1 });\n    if (res.body.completed) {\n      dispatch(mutationType.UPDATE_LIST, { id: res.body.list_id, type: 'completed', update: -1 });\n    }\n  }, function (err) {\n    dispatch(mutationType.EDIT_TASK_ERROR, err);\n  });\n};\n\nvar editTask = exports.editTask = function editTask(_ref7, taskid, param) {\n  var dispatch = _ref7.dispatch;\n  var state = _ref7.state;\n\n  _superagent2.default.put('/tasks/' + taskid).set('x-access-token', window.localStorage.token).send(param).use(_base2.default).then(function (res) {\n    dispatch(mutationType.EDIT_TASK, res.body);\n  });\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3Z1ZXgvYWN0aW9ucy90YXNrcy5qcz80MmUxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUNBOztJQUFZLFk7O0FBQ1o7Ozs7Ozs7O0FBRUEsSUFBSSxlQUFlLFNBQWYsWUFBZSxDQUFDLEtBQUQsRUFBVztBQUM1QixTQUFPLHFCQUNKLEdBREksQ0FDQSxRQURBLEVBRUosS0FGSSxDQUVFLEtBRkYsRUFHSixHQUhJLENBR0EsZ0JBSEEsRUFHa0IsT0FBTyxZQUFQLENBQW9CLEtBSHRDLEVBSUosR0FKSSxnQkFBUDtBQUtELENBTkQ7O0FBUU8sSUFBTSxrQ0FBYSxTQUFiLFVBQWEsT0FBc0IsS0FBdEIsRUFBNkIsUUFBN0IsRUFBMEM7QUFBQSxNQUF2QyxRQUF1QyxRQUF2QyxRQUF1QztBQUFBLE1BQTdCLEtBQTZCLFFBQTdCLEtBQTZCOztBQUNsRSxlQUFhLEtBQWIsRUFBb0IsSUFBcEIsQ0FBeUIsVUFBQyxHQUFELEVBQVM7QUFDaEMsUUFBSSxPQUFPLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbEMsZUFBUyxHQUFUO0FBQ0Q7QUFDRCxhQUFTLGFBQWEsV0FBdEIsRUFBbUMsS0FBbkMsRUFBMEMsSUFBSSxJQUE5QztBQUNELEdBTEQsRUFLRyxVQUFDLEdBQUQsRUFBUztBQUNWLGFBQVMsYUFBYSxpQkFBdEIsRUFBeUMsR0FBekM7QUFDRCxHQVBEO0FBUUQsQ0FUTTs7QUFXQSxJQUFNLDRDQUFrQixTQUFsQixlQUFrQixRQUFzQixNQUF0QixFQUFpQztBQUFBLE1BQTlCLFFBQThCLFNBQTlCLFFBQThCO0FBQUEsTUFBcEIsS0FBb0IsU0FBcEIsS0FBb0I7O0FBQzlELHVCQUNHLEdBREgsQ0FDTyxZQUFZLE1BRG5CLEVBRUcsR0FGSCxDQUVPLGdCQUZQLEVBRXlCLE9BQU8sWUFBUCxDQUFvQixLQUY3QyxFQUdHLEdBSEgsaUJBSUcsSUFKSCxDQUlRLFVBQUMsR0FBRCxFQUFTO0FBQ2Is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O0FBQ0YsR0FWSCxFQVVLLFVBQUMsR0FBRCxFQUFTO0FBQ1YsYUFBUyxhQUFhLGVBQXRCLEVBQXVDLEdBQXZDO0FBQ0QsR0FaSDtBQWFELENBZE07O0FBZ0JBLElBQU0sOEJBQVcsU0FBWCxRQUFXLFFBQXNCLE1BQXRCLEVBQThCLEtBQTlCLEVBQXdDO0FBQUEsTUFBckMsUUFBcUMsU0FBckMsUUFBcUM7QUFBQSxNQUEzQixLQUEyQixTQUEzQixLQUEyQjs7QUFDOUQsdUJBQ0csR0FESCxDQUNPLFlBQVksTUFEbkIsRUFFRyxHQUZILENBRU8sZ0JBRlAsRUFFeUIsT0FBTyxZQUFQLENBQW9CLEtBRjdDLEVBR0csSUFISCxDQUdRLEtBSFIsRUFJRyxHQUpILGlCQUtHLElBTEgsQ0FLUSxVQUFDLEdBQUQsRUFBUztBQUNiLGFBQVMsYUFBYSxTQUF0QixFQUFpQyxJQUFJLElBQXJDO0FBQ0QsR0FQSDtBQVFELENBVE0iLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCAqIGFzIG11dGF0aW9uVHlwZSBmcm9tICcuLi9tdXRhdGlvblR5cGUnO1xuaW1wb3J0IGJhc2VVUkwgZnJvbSAnLi9iYXNlJztcblxubGV0IHJlcXVlc3RUYXNrcyA9IChxdWVyeSkgPT4ge1xuICByZXR1cm4gcmVxdWVzdFxuICAgIC5nZXQoJy90YXNrcycpXG4gICAgLnF1ZXJ5KHF1ZXJ5KVxuICAgIC5zZXQoJ3gtYWNjZXNzLXRva2VuJywgd2luZG93LmxvY2FsU3RvcmFnZS50b2tlbilcbiAgICAudXNlKGJhc2VVUkwpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZldGNoVGFza3MgPSAoeyBkaXNwYXRjaCwgc3RhdGUgfSwgcXVlcnksIGNhbGxiYWNrKSA9PiB7XG4gIHJlcXVlc3RUYXNrcyhxdWVyeSkudGhlbigocmVzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2socmVzKTtcbiAgICB9XG4gICAgZGlzcGF0Y2gobXV0YXRpb25UeXBlLkZFVENIX1RBU0tTLCBxdWVyeSwgcmVzLmJvZHkpO1xuICB9LCAoZXJyKSA9PiB7XG4gICAgZGlzcGF0Y2gobXV0YXRpb25UeXBlLkZFVENIX1RBU0tTX0VSUk9SLCBlcnIpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBmZXRjaFRhc2tEZXRhaWwgPSAoeyBkaXNwYXRjaCwgc3RhdGUgfSwgdGFza2lkKSA9PiB7XG4gIHJlcXVlc3RcbiAgICAuZ2V0KCcvdGFza3MvJyArIHRhc2tpZClcbiAgICAuc2V0KCd4LWFjY2Vzcy10b2tlbicsIHdpbmRvdy5sb2NhbFN0b3JhZ2UudG9rZW4pXG4gICAgLnVzZShiYXNlVVJMKVxuICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgIGRpc3BhdGNoKG11dGF0aW9uVHlwZS5GRVRDSF9UQVNLX0RFVEFJTCwgcmVzLmJvZHkpO1xuICAgIH0sIChlcnIpID0+IHtcbiAgICAgIGRpc3BhdGNoKG11dGF0aW9uVHlwZS5GRVRDSF9UQVNLX0RFVEFJTF9FUlJPUiwgZXJyKTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBoaWRlVGFza0RldGFpbCA9ICh7IGRpc3BhdGNoIH0pID0+IHtcbiAgZGlzcGF0Y2gobXV0YXRpb25UeXBlLkhJREVfREVUQUlMX1dJTkRPVyk7XG59O1xuXG5leHBvcnQgY29uc3QgYWRkVGFzayA9ICh7IGRpc3BhdGNoLCBzdGF0ZSB9LCB0YXNrKSA9PiB7XG4gIHJlcXVlc3RcbiAgICAucG9zdCgnL3Rhc2tzJylcbiAgICAuc2VuZCh0YXNrKVxuICAgIC5zZXQoJ3gtYWNjZXNzLXRva2VuJywgd2luZG93LmxvY2FsU3RvcmFnZS50b2tlbilcbiAgICAudXNlKGJhc2VVUkwpXG4gICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgZGlzcGF0Y2gobXV0YXRpb25UeXBlLkFERF9UQVNLLCByZXMuYm9keSk7XG4gICAgICBkaXNwYXRjaChtdXRhdGlvblR5cGUuVVBEQVRFX0xJU1QsIHsgaWQ6IHRhc2subGlzdF9pZCwgdHlwZTogJ3RvdGFsJywgdXBkYXRlOiAxIH0pO1xuICAgIH0sIChlcnIpID0+IHtcbiAgICAgIGRpc3BhdGNoKG11dGF0aW9uVHlwZS5BRERfVEFTS19FUlJPUiwgZXJyKTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVUYXNrID0gKHsgZGlzcGF0Y2gsIHN0YXRlIH0sIHRhc2tpZCwgcGFyYW0pID0+IHtcbiAgcmVxdWVzdFxuICAgIC5wdXQoJy90YXNrcy8nICsgdGFza2lkKVxuICAgIC5zZW5kKHBhcmFtKVxuICAgIC5zZXQoJ3gtYWNjZXNzLXRva2VuJywgd2luZG93LmxvY2FsU3RvcmFnZS50b2tlbilcbiAgICAudXNlKGJhc2VVUkwpXG4gICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgZGlzcGF0Y2gobXV0YXRpb25UeXBlLkVESVRfVEFTSywgcmVzLmJvZHkpO1xuICAgICAgaWYgKHBhcmFtLmNvbXBsZXRlZCkge1xuICAgICAgICBkaXNwYXRjaChtdXRhdGlvblR5cGUuVVBEQVRFX0xJU1QsIHsgaWQ6IHJlcy5ib2R5Lmxpc3RfaWQsIHR5cGU6ICdjb21wbGV0ZWQnLCB1cGRhdGU6IDEgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaChtdXRhdGlvblR5cGUuVVBEQVRFX0xJU1QsIHsgaWQ6IHJlcy5ib2R5Lmxpc3RfaWQsIHR5cGU6ICdjb21wbGV0ZWQnLCB1cGRhdGU6IC0xIH0pO1xuICAgICAgfVxuICAgIH0sIChlcnIpID0+IHtcbiAgICAgIGRpc3BhdGNoKG11dGF0aW9uVHlwZS5FRElUX1RBU0tfRVJST1IsIGVycik7XG4gICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgZGVsZXRlVGFzayA9ICh7IGRpc3BhdGNoLCBzdGF0ZSB9LCB0YXNraWQpID0+IHtcbiAgcmVxdWVzdFxuICAgIC5kZWxldGUoJy90YXNrcy8nICsgdGFza2lkKVxuICAgIC5zZXQoJ3gtYWNjZXNzLXRva2VuJywgd2luZG93LmxvY2FsU3RvcmFnZS50b2tlbilcbiAgICAudXNlKGJhc2VVUkwpXG4gICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgZGlzcGF0Y2gobXV0YXRpb25UeXBlLkRFTEVURV9UQVNLLCByZXMuYm9keSk7XG4gICAgICBkaXNwYXRjaChtdXRhdGlvblR5cGUuVVBEQVRFX0xJU1QsIHsgaWQ6IHJlcy5ib2R5Lmxpc3RfaWQsIHR5cGU6ICd0b3RhbCcsIHVwZGF0ZTogLTEgfSk7XG4gICAgICBpZiAocmVzLmJvZHkuY29tcGxldGVkKSB7XG4gICAgICAgIGRpc3BhdGNoKG11dGF0aW9uVHlwZS5VUERBVEVfTElTVCwgeyBpZDogcmVzLmJvZHkubGlzdF9pZCwgdHlwZTogJ2NvbXBsZXRlZCcsIHVwZGF0ZTogLTEgfSk7XG4gICAgICB9XG4gICAgfSwgKGVycikgPT4ge1xuICAgICAgZGlzcGF0Y2gobXV0YXRpb25UeXBlLkVESVRfVEFTS19FUlJPUiwgZXJyKTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBlZGl0VGFzayA9ICh7IGRpc3BhdGNoLCBzdGF0ZSB9LCB0YXNraWQsIHBhcmFtKSA9PiB7XG4gIHJlcXVlc3RcbiAgICAucHV0KCcvdGFza3MvJyArIHRhc2tpZClcbiAgICAuc2V0KCd4LWFjY2Vzcy10b2tlbicsIHdpbmRvdy5sb2NhbFN0b3JhZ2UudG9rZW4pXG4gICAgLnNlbmQocGFyYW0pXG4gICAgLnVzZShiYXNlVVJMKVxuICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgIGRpc3BhdGNoKG11dGF0aW9uVHlwZS5FRElUX1RBU0ssIHJlcy5ib2R5KTtcbiAgICB9KTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9zcmMvdnVleC9hY3Rpb25zL3Rhc2tzLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * marked - a markdown parser\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n */\n\n;(function() {\n\n/**\n * Block-Level Grammar\n */\n\nvar block = {\n  newline: /^\\n+/,\n  code: /^( {4}[^\\n]+\\n*)+/,\n  fences: noop,\n  hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\n  heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\n  nptable: noop,\n  lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n  blockquote: /^( *>[^\\n]+(\\n(?!def)[^\\n]+)*\\n*)+/,\n  list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n  html: /^ *(?:comment *(?:\\n|\\s*$)|closed *(?:\\n{2,}|\\s*$)|closing *(?:\\n{2,}|\\s*$))/,\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\n  table: noop,\n  paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\n  text: /^[^\\n]+/\n};\n\nblock.bullet = /(?:[*+-]|\\d+\\.)/;\nblock.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\nblock.item = replace(block.item, 'gm')\n  (/bull/g, block.bullet)\n  ();\n\nblock.list = replace(block.list)\n  (/bull/g, block.bullet)\n  ('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')\n  ('def', '\\\\n+(?=' + block.def.source + ')')\n  ();\n\nblock.blockquote = replace(block.blockquote)\n  ('def', block.def)\n  ();\n\nblock._tag = '(?!(?:'\n  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'\n  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'\n  + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b';\n\nblock.html = replace(block.html)\n  ('comment', /<!--[\\s\\S]*?-->/)\n  ('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\n  ('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\n  (/tag/g, block._tag)\n  ();\n\nblock.paragraph = replace(block.paragraph)\n  ('hr', block.hr)\n  ('heading', block.heading)\n  ('lheading', block.lheading)\n  ('blockquote', block.blockquote)\n  ('tag', '<' + block._tag)\n  ('def', block.def)\n  ();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  fences: /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\s*\\1 *(?:\\n+|$)/,\n  paragraph: /^/,\n  heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/\n});\n\nblock.gfm.paragraph = replace(block.paragraph)\n  ('(?!', '(?!'\n    + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|'\n    + block.list.source.replace('\\\\1', '\\\\3') + '|')\n  ();\n\n/**\n * GFM + Tables Block Grammar\n */\n\nblock.tables = merge({}, block.gfm, {\n  nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n  table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/\n});\n\n/**\n * Block Lexer\n */\n\nfunction Lexer(options) {\n  this.tokens = [];\n  this.tokens.links = {};\n  this.options = options || marked.defaults;\n  this.rules = block.normal;\n\n  if (this.options.gfm) {\n    if (this.options.tables) {\n      this.rules = block.tables;\n    } else {\n      this.rules = block.gfm;\n    }\n  }\n}\n\n/**\n * Expose Block Rules\n */\n\nLexer.rules = block;\n\n/**\n * Static Lex Method\n */\n\nLexer.lex = function(src, options) {\n  var lexer = new Lexer(options);\n  return lexer.lex(src);\n};\n\n/**\n * Preprocessing\n */\n\nLexer.prototype.lex = function(src) {\n  src = src\n    .replace(/\\r\\n|\\r/g, '\\n')\n    .replace(/\\t/g, '    ')\n    .replace(/\\u00a0/g, ' ')\n    .replace(/\\u2424/g, '\\n');\n\n  return this.token(src, true);\n};\n\n/**\n * Lexing\n */\n\nLexer.prototype.token = function(src, top, bq) {\n  var src = src.replace(/^ +$/gm, '')\n    , next\n    , loose\n    , cap\n    , bull\n    , b\n    , item\n    , space\n    , i\n    , l;\n\n  while (src) {\n    // newline\n    if (cap = this.rules.newline.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[0].length > 1) {\n        this.tokens.push({\n          type: 'space'\n        });\n      }\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      cap = cap[0].replace(/^ {4}/gm, '');\n      this.tokens.push({\n        type: 'code',\n        text: !this.options.pedantic\n          ? cap.replace(/\\n+$/, '')\n          : cap\n      });\n      continue;\n    }\n\n    // fences (gfm)\n    if (cap = this.rules.fences.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'code',\n        lang: cap[2],\n        text: cap[3] || ''\n      });\n      continue;\n    }\n\n    // heading\n    if (cap = this.rules.heading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[1].length,\n        text: cap[2]\n      });\n      continue;\n    }\n\n    // table no leading pipe (gfm)\n    if (top && (cap = this.rules.nptable.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i].split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // lheading\n    if (cap = this.rules.lheading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[2] === '=' ? 1 : 2,\n        text: cap[1]\n      });\n      continue;\n    }\n\n    // hr\n    if (cap = this.rules.hr.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'hr'\n      });\n      continue;\n    }\n\n    // blockquote\n    if (cap = this.rules.blockquote.exec(src)) {\n      src = src.substring(cap[0].length);\n\n      this.tokens.push({\n        type: 'blockquote_start'\n      });\n\n      cap = cap[0].replace(/^ *> ?/gm, '');\n\n      // Pass `top` to keep the current\n      // \"toplevel\" state. This is exactly\n      // how markdown.pl works.\n      this.token(cap, top, true);\n\n      this.tokens.push({\n        type: 'blockquote_end'\n      });\n\n      continue;\n    }\n\n    // list\n    if (cap = this.rules.list.exec(src)) {\n      src = src.substring(cap[0].length);\n      bull = cap[2];\n\n      this.tokens.push({\n        type: 'list_start',\n        ordered: bull.length > 1\n      });\n\n      // Get each top-level item.\n      cap = cap[0].match(this.rules.item);\n\n      next = false;\n      l = cap.length;\n      i = 0;\n\n      for (; i < l; i++) {\n        item = cap[i];\n\n        // Remove the list item's bullet\n        // so it is seen as the next token.\n        space = item.length;\n        item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length;\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '');\n        }\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (this.options.smartLists && i !== l - 1) {\n          b = block.bullet.exec(cap[i + 1])[0];\n          if (bull !== b && !(bull.length > 1 && b.length > 1)) {\n            src = cap.slice(i + 1).join('\\n') + src;\n            i = l - 1;\n          }\n        }\n\n        // Determine whether item is loose or not.\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n        // for discount behavior.\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\n        if (i !== l - 1) {\n          next = item.charAt(item.length - 1) === '\\n';\n          if (!loose) loose = next;\n        }\n\n        this.tokens.push({\n          type: loose\n            ? 'loose_item_start'\n            : 'list_item_start'\n        });\n\n        // Recurse.\n        this.token(item, false, bq);\n\n        this.tokens.push({\n          type: 'list_item_end'\n        });\n      }\n\n      this.tokens.push({\n        type: 'list_end'\n      });\n\n      continue;\n    }\n\n    // html\n    if (cap = this.rules.html.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: this.options.sanitize\n          ? 'paragraph'\n          : 'html',\n        pre: !this.options.sanitizer\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: cap[0]\n      });\n      continue;\n    }\n\n    // def\n    if ((!bq && top) && (cap = this.rules.def.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.links[cap[1].toLowerCase()] = {\n        href: cap[2],\n        title: cap[3]\n      };\n      continue;\n    }\n\n    // table (gfm)\n    if (top && (cap = this.rules.table.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i]\n          .replace(/^ *\\| *| *\\| *$/g, '')\n          .split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // top-level paragraph\n    if (top && (cap = this.rules.paragraph.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'paragraph',\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1]\n      });\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      // Top-level should never reach here.\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'text',\n        text: cap[0]\n      });\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return this.tokens;\n};\n\n/**\n * Inline-Level Grammar\n */\n\nvar inline = {\n  escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\n  autolink: /^<([^ >]+(@|:\\/)[^ >]+)>/,\n  url: noop,\n  tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/,\n  link: /^!?\\[(inside)\\]\\(href\\)/,\n  reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\n  nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\n  strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\n  em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n  code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n  br: /^ {2,}\\n(?!\\s*$)/,\n  del: noop,\n  text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/\n};\n\ninline._inside = /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/;\ninline._href = /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/;\n\ninline.link = replace(inline.link)\n  ('inside', inline._inside)\n  ('href', inline._href)\n  ();\n\ninline.reflink = replace(inline.reflink)\n  ('inside', inline._inside)\n  ();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: replace(inline.escape)('])', '~|])')(),\n  url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n  del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\n  text: replace(inline.text)\n    (']|', '~]|')\n    ('|', '|https?://|')\n    ()\n});\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: replace(inline.br)('{2,}', '*')(),\n  text: replace(inline.gfm.text)('{2,}', '*')()\n});\n\n/**\n * Inline Lexer & Compiler\n */\n\nfunction InlineLexer(links, options) {\n  this.options = options || marked.defaults;\n  this.links = links;\n  this.rules = inline.normal;\n  this.renderer = this.options.renderer || new Renderer;\n  this.renderer.options = this.options;\n\n  if (!this.links) {\n    throw new\n      Error('Tokens array requires a `links` property.');\n  }\n\n  if (this.options.gfm) {\n    if (this.options.breaks) {\n      this.rules = inline.breaks;\n    } else {\n      this.rules = inline.gfm;\n    }\n  } else if (this.options.pedantic) {\n    this.rules = inline.pedantic;\n  }\n}\n\n/**\n * Expose Inline Rules\n */\n\nInlineLexer.rules = inline;\n\n/**\n * Static Lexing/Compiling Method\n */\n\nInlineLexer.output = function(src, links, options) {\n  var inline = new InlineLexer(links, options);\n  return inline.output(src);\n};\n\n/**\n * Lexing/Compiling\n */\n\nInlineLexer.prototype.output = function(src) {\n  var out = ''\n    , link\n    , text\n    , href\n    , cap;\n\n  while (src) {\n    // escape\n    if (cap = this.rules.escape.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += cap[1];\n      continue;\n    }\n\n    // autolink\n    if (cap = this.rules.autolink.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[2] === '@') {\n        text = cap[1].charAt(6) === ':'\n          ? this.mangle(cap[1].substring(7))\n          : this.mangle(cap[1]);\n        href = this.mangle('mailto:') + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // url (gfm)\n    if (!this.inLink && (cap = this.rules.url.exec(src))) {\n      src = src.substring(cap[0].length);\n      text = escape(cap[1]);\n      href = text;\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // tag\n    if (cap = this.rules.tag.exec(src)) {\n      if (!this.inLink && /^<a /i.test(cap[0])) {\n        this.inLink = true;\n      } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\n        this.inLink = false;\n      }\n      src = src.substring(cap[0].length);\n      out += this.options.sanitize\n        ? this.options.sanitizer\n          ? this.options.sanitizer(cap[0])\n          : escape(cap[0])\n        : cap[0]\n      continue;\n    }\n\n    // link\n    if (cap = this.rules.link.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.inLink = true;\n      out += this.outputLink(cap, {\n        href: cap[2],\n        title: cap[3]\n      });\n      this.inLink = false;\n      continue;\n    }\n\n    // reflink, nolink\n    if ((cap = this.rules.reflink.exec(src))\n        || (cap = this.rules.nolink.exec(src))) {\n      src = src.substring(cap[0].length);\n      link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = this.links[link.toLowerCase()];\n      if (!link || !link.href) {\n        out += cap[0].charAt(0);\n        src = cap[0].substring(1) + src;\n        continue;\n      }\n      this.inLink = true;\n      out += this.outputLink(cap, link);\n      this.inLink = false;\n      continue;\n    }\n\n    // strong\n    if (cap = this.rules.strong.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.strong(this.output(cap[2] || cap[1]));\n      continue;\n    }\n\n    // em\n    if (cap = this.rules.em.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.em(this.output(cap[2] || cap[1]));\n      continue;\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.codespan(escape(cap[2], true));\n      continue;\n    }\n\n    // br\n    if (cap = this.rules.br.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.br();\n      continue;\n    }\n\n    // del (gfm)\n    if (cap = this.rules.del.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.del(this.output(cap[1]));\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.text(escape(this.smartypants(cap[0])));\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return out;\n};\n\n/**\n * Compile Link\n */\n\nInlineLexer.prototype.outputLink = function(cap, link) {\n  var href = escape(link.href)\n    , title = link.title ? escape(link.title) : null;\n\n  return cap[0].charAt(0) !== '!'\n    ? this.renderer.link(href, title, this.output(cap[1]))\n    : this.renderer.image(href, title, escape(cap[1]));\n};\n\n/**\n * Smartypants Transformations\n */\n\nInlineLexer.prototype.smartypants = function(text) {\n  if (!this.options.smartypants) return text;\n  return text\n    // em-dashes\n    .replace(/---/g, '\\u2014')\n    // en-dashes\n    .replace(/--/g, '\\u2013')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n};\n\n/**\n * Mangle Links\n */\n\nInlineLexer.prototype.mangle = function(text) {\n  if (!this.options.mangle) return text;\n  var out = ''\n    , l = text.length\n    , i = 0\n    , ch;\n\n  for (; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n};\n\n/**\n * Renderer\n */\n\nfunction Renderer(options) {\n  this.options = options || {};\n}\n\nRenderer.prototype.code = function(code, lang, escaped) {\n  if (this.options.highlight) {\n    var out = this.options.highlight(code, lang);\n    if (out != null && out !== code) {\n      escaped = true;\n      code = out;\n    }\n  }\n\n  if (!lang) {\n    return '<pre><code>'\n      + (escaped ? code : escape(code, true))\n      + '\\n</code></pre>';\n  }\n\n  return '<pre><code class=\"'\n    + this.options.langPrefix\n    + escape(lang, true)\n    + '\">'\n    + (escaped ? code : escape(code, true))\n    + '\\n</code></pre>\\n';\n};\n\nRenderer.prototype.blockquote = function(quote) {\n  return '<blockquote>\\n' + quote + '</blockquote>\\n';\n};\n\nRenderer.prototype.html = function(html) {\n  return html;\n};\n\nRenderer.prototype.heading = function(text, level, raw) {\n  return '<h'\n    + level\n    + ' id=\"'\n    + this.options.headerPrefix\n    + raw.toLowerCase().replace(/[^\\w]+/g, '-')\n    + '\">'\n    + text\n    + '</h'\n    + level\n    + '>\\n';\n};\n\nRenderer.prototype.hr = function() {\n  return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n};\n\nRenderer.prototype.list = function(body, ordered) {\n  var type = ordered ? 'ol' : 'ul';\n  return '<' + type + '>\\n' + body + '</' + type + '>\\n';\n};\n\nRenderer.prototype.listitem = function(text) {\n  return '<li>' + text + '</li>\\n';\n};\n\nRenderer.prototype.paragraph = function(text) {\n  return '<p>' + text + '</p>\\n';\n};\n\nRenderer.prototype.table = function(header, body) {\n  return '<table>\\n'\n    + '<thead>\\n'\n    + header\n    + '</thead>\\n'\n    + '<tbody>\\n'\n    + body\n    + '</tbody>\\n'\n    + '</table>\\n';\n};\n\nRenderer.prototype.tablerow = function(content) {\n  return '<tr>\\n' + content + '</tr>\\n';\n};\n\nRenderer.prototype.tablecell = function(content, flags) {\n  var type = flags.header ? 'th' : 'td';\n  var tag = flags.align\n    ? '<' + type + ' style=\"text-align:' + flags.align + '\">'\n    : '<' + type + '>';\n  return tag + content + '</' + type + '>\\n';\n};\n\n// span level renderer\nRenderer.prototype.strong = function(text) {\n  return '<strong>' + text + '</strong>';\n};\n\nRenderer.prototype.em = function(text) {\n  return '<em>' + text + '</em>';\n};\n\nRenderer.prototype.codespan = function(text) {\n  return '<code>' + text + '</code>';\n};\n\nRenderer.prototype.br = function() {\n  return this.options.xhtml ? '<br/>' : '<br>';\n};\n\nRenderer.prototype.del = function(text) {\n  return '<del>' + text + '</del>';\n};\n\nRenderer.prototype.link = function(href, title, text) {\n  if (this.options.sanitize) {\n    try {\n      var prot = decodeURIComponent(unescape(href))\n        .replace(/[^\\w:]/g, '')\n        .toLowerCase();\n    } catch (e) {\n      return '';\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {\n      return '';\n    }\n  }\n  var out = '<a href=\"' + href + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += '>' + text + '</a>';\n  return out;\n};\n\nRenderer.prototype.image = function(href, title, text) {\n  var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += this.options.xhtml ? '/>' : '>';\n  return out;\n};\n\nRenderer.prototype.text = function(text) {\n  return text;\n};\n\n/**\n * Parsing & Compiling\n */\n\nfunction Parser(options) {\n  this.tokens = [];\n  this.token = null;\n  this.options = options || marked.defaults;\n  this.options.renderer = this.options.renderer || new Renderer;\n  this.renderer = this.options.renderer;\n  this.renderer.options = this.options;\n}\n\n/**\n * Static Parse Method\n */\n\nParser.parse = function(src, options, renderer) {\n  var parser = new Parser(options, renderer);\n  return parser.parse(src);\n};\n\n/**\n * Parse Loop\n */\n\nParser.prototype.parse = function(src) {\n  this.inline = new InlineLexer(src.links, this.options, this.renderer);\n  this.tokens = src.reverse();\n\n  var out = '';\n  while (this.next()) {\n    out += this.tok();\n  }\n\n  return out;\n};\n\n/**\n * Next Token\n */\n\nParser.prototype.next = function() {\n  return this.token = this.tokens.pop();\n};\n\n/**\n * Preview Next Token\n */\n\nParser.prototype.peek = function() {\n  return this.tokens[this.tokens.length - 1] || 0;\n};\n\n/**\n * Parse Text Tokens\n */\n\nParser.prototype.parseText = function() {\n  var body = this.token.text;\n\n  while (this.peek().type === 'text') {\n    body += '\\n' + this.next().text;\n  }\n\n  return this.inline.output(body);\n};\n\n/**\n * Parse Current Token\n */\n\nParser.prototype.tok = function() {\n  switch (this.token.type) {\n    case 'space': {\n      return '';\n    }\n    case 'hr': {\n      return this.renderer.hr();\n    }\n    case 'heading': {\n      return this.renderer.heading(\n        this.inline.output(this.token.text),\n        this.token.depth,\n        this.token.text);\n    }\n    case 'code': {\n      return this.renderer.code(this.token.text,\n        this.token.lang,\n        this.token.escaped);\n    }\n    case 'table': {\n      var header = ''\n        , body = ''\n        , i\n        , row\n        , cell\n        , flags\n        , j;\n\n      // header\n      cell = '';\n      for (i = 0; i < this.token.header.length; i++) {\n        flags = { header: true, align: this.token.align[i] };\n        cell += this.renderer.tablecell(\n          this.inline.output(this.token.header[i]),\n          { header: true, align: this.token.align[i] }\n        );\n      }\n      header += this.renderer.tablerow(cell);\n\n      for (i = 0; i < this.token.cells.length; i++) {\n        row = this.token.cells[i];\n\n        cell = '';\n        for (j = 0; j < row.length; j++) {\n          cell += this.renderer.tablecell(\n            this.inline.output(row[j]),\n            { header: false, align: this.token.align[j] }\n          );\n        }\n\n        body += this.renderer.tablerow(cell);\n      }\n      return this.renderer.table(header, body);\n    }\n    case 'blockquote_start': {\n      var body = '';\n\n      while (this.next().type !== 'blockquote_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.blockquote(body);\n    }\n    case 'list_start': {\n      var body = ''\n        , ordered = this.token.ordered;\n\n      while (this.next().type !== 'list_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.list(body, ordered);\n    }\n    case 'list_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.token.type === 'text'\n          ? this.parseText()\n          : this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'loose_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'html': {\n      var html = !this.token.pre && !this.options.pedantic\n        ? this.inline.output(this.token.text)\n        : this.token.text;\n      return this.renderer.html(html);\n    }\n    case 'paragraph': {\n      return this.renderer.paragraph(this.inline.output(this.token.text));\n    }\n    case 'text': {\n      return this.renderer.paragraph(this.parseText());\n    }\n  }\n};\n\n/**\n * Helpers\n */\n\nfunction escape(html, encode) {\n  return html\n    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction unescape(html) {\n  return html.replace(/&([#\\w]+);/g, function(_, n) {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nfunction replace(regex, opt) {\n  regex = regex.source;\n  opt = opt || '';\n  return function self(name, val) {\n    if (!name) return new RegExp(regex, opt);\n    val = val.source || val;\n    val = val.replace(/(^|[^\\[])\\^/g, '$1');\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\n\nfunction noop() {}\nnoop.exec = noop;\n\nfunction merge(obj) {\n  var i = 1\n    , target\n    , key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\n\n/**\n * Marked\n */\n\nfunction marked(src, opt, callback) {\n  if (callback || typeof opt === 'function') {\n    if (!callback) {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n\n    var highlight = opt.highlight\n      , tokens\n      , pending\n      , i = 0;\n\n    try {\n      tokens = Lexer.lex(src, opt)\n    } catch (e) {\n      return callback(e);\n    }\n\n    pending = tokens.length;\n\n    var done = function(err) {\n      if (err) {\n        opt.highlight = highlight;\n        return callback(err);\n      }\n\n      var out;\n\n      try {\n        out = Parser.parse(tokens, opt);\n      } catch (e) {\n        err = e;\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!pending) return done();\n\n    for (; i < tokens.length; i++) {\n      (function(token) {\n        if (token.type !== 'code') {\n          return --pending || done();\n        }\n        return highlight(token.text, token.lang, function(err, code) {\n          if (err) return done(err);\n          if (code == null || code === token.text) {\n            return --pending || done();\n          }\n          token.text = code;\n          token.escaped = true;\n          --pending || done();\n        });\n      })(tokens[i]);\n    }\n\n    return;\n  }\n  try {\n    if (opt) opt = merge({}, marked.defaults, opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/chjj/marked.';\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occured:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  return marked;\n};\n\nmarked.defaults = {\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: false,\n  sanitizer: null,\n  mangle: true,\n  smartLists: false,\n  silent: false,\n  highlight: null,\n  langPrefix: 'lang-',\n  smartypants: false,\n  headerPrefix: '',\n  renderer: new Renderer,\n  xhtml: false\n};\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Renderer = Renderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\n\nmarked.parse = marked;\n\nif (true) {\n  module.exports = marked;\n} else if (typeof define === 'function' && define.amd) {\n  define(function() { return marked; });\n} else {\n  this.marked = marked;\n}\n\n}).call(function() {\n  return this || (typeof window !== 'undefined' ? window : global);\n}());\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcmtlZC9saWIvbWFya2VkLmpzP2JkYzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2Y7QUFDQSxrQkFBa0IsR0FBRztBQUNyQixrQkFBa0IsSUFBSTtBQUN0QjtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0EsMENBQTBDLEdBQUc7QUFDN0Msa0RBQWtELEdBQUcsc0JBQXNCLEdBQUc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsR0FBRztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLGlCQUFpQixHQUFHLEdBQUcsR0FBRztBQUMxQjtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FB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QUFDckI7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QiwyQkFBMkIsR0FBRztBQUM5QixtQ0FBbUMsR0FBRztBQUN0QyxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQUU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFCQUFxQixlQUFlLEVBQUU7QUFDdEMsQ0FBQztBQUNEO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsQ0FBQyIsImZpbGUiOiI1OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbWFya2VkIC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE0LCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NoamovbWFya2VkXG4gKi9cblxuOyhmdW5jdGlvbigpIHtcblxuLyoqXG4gKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gKi9cblxudmFyIGJsb2NrID0ge1xuICBuZXdsaW5lOiAvXlxcbisvLFxuICBjb2RlOiAvXiggezR9W15cXG5dK1xcbiopKy8sXG4gIGZlbmNlczogbm9vcCxcbiAgaHI6IC9eKCAqWy0qX10pezMsfSAqKD86XFxuK3wkKS8sXG4gIGhlYWRpbmc6IC9eICooI3sxLDZ9KSAqKFteXFxuXSs/KSAqIyogKig/Olxcbit8JCkvLFxuICBucHRhYmxlOiBub29wLFxuICBsaGVhZGluZzogL14oW15cXG5dKylcXG4gKig9fC0pezIsfSAqKD86XFxuK3wkKS8sXG4gIGJsb2NrcXVvdGU6IC9eKCAqPlteXFxuXSsoXFxuKD8hZGVmKVteXFxuXSspKlxcbiopKy8sXG4gIGxpc3Q6IC9eKCAqKShidWxsKSBbXFxzXFxTXSs/KD86aHJ8ZGVmfFxcbnsyLH0oPyEgKSg/IVxcMWJ1bGwgKVxcbip8XFxzKiQpLyxcbiAgaHRtbDogL14gKig/OmNvbW1lbnQgKig/OlxcbnxcXHMqJCl8Y2xvc2VkICooPzpcXG57Mix9fFxccyokKXxjbG9zaW5nICooPzpcXG57Mix9fFxccyokKSkvLFxuICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArW1wiKF0oW15cXG5dKylbXCIpXSk/ICooPzpcXG4rfCQpLyxcbiAgdGFibGU6IG5vb3AsXG4gIHBhcmFncmFwaDogL14oKD86W15cXG5dK1xcbj8oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8dGFnfGRlZikpKylcXG4qLyxcbiAgdGV4dDogL15bXlxcbl0rL1xufTtcblxuYmxvY2suYnVsbGV0ID0gLyg/OlsqKy1dfFxcZCtcXC4pLztcbmJsb2NrLml0ZW0gPSAvXiggKikoYnVsbCkgW15cXG5dKig/Olxcbig/IVxcMWJ1bGwgKVteXFxuXSopKi87XG5ibG9jay5pdGVtID0gcmVwbGFjZShibG9jay5pdGVtLCAnZ20nKVxuICAoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAoKTtcblxuYmxvY2subGlzdCA9IHJlcGxhY2UoYmxvY2subGlzdClcbiAgKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgKCdocicsICdcXFxcbisoPz1cXFxcMT8oPzpbLSpfXSAqKXszLH0oPzpcXFxcbit8JCkpJylcbiAgKCdkZWYnLCAnXFxcXG4rKD89JyArIGJsb2NrLmRlZi5zb3VyY2UgKyAnKScpXG4gICgpO1xuXG5ibG9jay5ibG9ja3F1b3RlID0gcmVwbGFjZShibG9jay5ibG9ja3F1b3RlKVxuICAoJ2RlZicsIGJsb2NrLmRlZilcbiAgKCk7XG5cbmJsb2NrLl90YWcgPSAnKD8hKD86J1xuICArICdhfGVtfHN0cm9uZ3xzbWFsbHxzfGNpdGV8cXxkZm58YWJicnxkYXRhfHRpbWV8Y29kZSdcbiAgKyAnfHZhcnxzYW1wfGtiZHxzdWJ8c3VwfGl8Ynx1fG1hcmt8cnVieXxydHxycHxiZGl8YmRvJ1xuICArICd8c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpXFxcXGIpXFxcXHcrKD8hOi98W15cXFxcd1xcXFxzQF0qQClcXFxcYic7XG5cbmJsb2NrLmh0bWwgPSByZXBsYWNlKGJsb2NrLmh0bWwpXG4gICgnY29tbWVudCcsIC88IS0tW1xcc1xcU10qPy0tPi8pXG4gICgnY2xvc2VkJywgLzwodGFnKVtcXHNcXFNdKz88XFwvXFwxPi8pXG4gICgnY2xvc2luZycsIC88dGFnKD86XCJbXlwiXSpcInwnW14nXSonfFteJ1wiPl0pKj8+LylcbiAgKC90YWcvZywgYmxvY2suX3RhZylcbiAgKCk7XG5cbmJsb2NrLnBhcmFncmFwaCA9IHJlcGxhY2UoYmxvY2sucGFyYWdyYXBoKVxuICAoJ2hyJywgYmxvY2suaHIpXG4gICgnaGVhZGluZycsIGJsb2NrLmhlYWRpbmcpXG4gICgnbGhlYWRpbmcnLCBibG9jay5saGVhZGluZylcbiAgKCdibG9ja3F1b3RlJywgYmxvY2suYmxvY2txdW90ZSlcbiAgKCd0YWcnLCAnPCcgKyBibG9jay5fdGFnKVxuICAoJ2RlZicsIGJsb2NrLmRlZilcbiAgKCk7XG5cbi8qKlxuICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5ub3JtYWwgPSBtZXJnZSh7fSwgYmxvY2spO1xuXG4vKipcbiAqIEdGTSBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2suZ2ZtID0gbWVyZ2Uoe30sIGJsb2NrLm5vcm1hbCwge1xuICBmZW5jZXM6IC9eICooYHszLH18fnszLH0pWyBcXC5dKihcXFMrKT8gKlxcbihbXFxzXFxTXSo/KVxccypcXDEgKig/Olxcbit8JCkvLFxuICBwYXJhZ3JhcGg6IC9eLyxcbiAgaGVhZGluZzogL14gKigjezEsNn0pICsoW15cXG5dKz8pICojKiAqKD86XFxuK3wkKS9cbn0pO1xuXG5ibG9jay5nZm0ucGFyYWdyYXBoID0gcmVwbGFjZShibG9jay5wYXJhZ3JhcGgpXG4gICgnKD8hJywgJyg/ISdcbiAgICArIGJsb2NrLmdmbS5mZW5jZXMuc291cmNlLnJlcGxhY2UoJ1xcXFwxJywgJ1xcXFwyJykgKyAnfCdcbiAgICArIGJsb2NrLmxpc3Quc291cmNlLnJlcGxhY2UoJ1xcXFwxJywgJ1xcXFwzJykgKyAnfCcpXG4gICgpO1xuXG4vKipcbiAqIEdGTSArIFRhYmxlcyBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2sudGFibGVzID0gbWVyZ2Uoe30sIGJsb2NrLmdmbSwge1xuICBucHRhYmxlOiAvXiAqKFxcUy4qXFx8LiopXFxuICooWy06XSsgKlxcfFstfCA6XSopXFxuKCg/Oi4qXFx8LiooPzpcXG58JCkpKilcXG4qLyxcbiAgdGFibGU6IC9eICpcXHwoLispXFxuICpcXHwoICpbLTpdK1stfCA6XSopXFxuKCg/OiAqXFx8LiooPzpcXG58JCkpKilcXG4qL1xufSk7XG5cbi8qKlxuICogQmxvY2sgTGV4ZXJcbiAqL1xuXG5mdW5jdGlvbiBMZXhlcihvcHRpb25zKSB7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMudG9rZW5zLmxpbmtzID0ge307XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLnJ1bGVzID0gYmxvY2subm9ybWFsO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50YWJsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMgPSBibG9jay50YWJsZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVsZXMgPSBibG9jay5nZm07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIEJsb2NrIFJ1bGVzXG4gKi9cblxuTGV4ZXIucnVsZXMgPSBibG9jaztcblxuLyoqXG4gKiBTdGF0aWMgTGV4IE1ldGhvZFxuICovXG5cbkxleGVyLmxleCA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucykge1xuICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbn07XG5cbi8qKlxuICogUHJlcHJvY2Vzc2luZ1xuICovXG5cbkxleGVyLnByb3RvdHlwZS5sZXggPSBmdW5jdGlvbihzcmMpIHtcbiAgc3JjID0gc3JjXG4gICAgLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpXG4gICAgLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpXG4gICAgLnJlcGxhY2UoL1xcdTAwYTAvZywgJyAnKVxuICAgIC5yZXBsYWNlKC9cXHUyNDI0L2csICdcXG4nKTtcblxuICByZXR1cm4gdGhpcy50b2tlbihzcmMsIHRydWUpO1xufTtcblxuLyoqXG4gKiBMZXhpbmdcbiAqL1xuXG5MZXhlci5wcm90b3R5cGUudG9rZW4gPSBmdW5jdGlvbihzcmMsIHRvcCwgYnEpIHtcbiAgdmFyIHNyYyA9IHNyYy5yZXBsYWNlKC9eICskL2dtLCAnJylcbiAgICAsIG5leHRcbiAgICAsIGxvb3NlXG4gICAgLCBjYXBcbiAgICAsIGJ1bGxcbiAgICAsIGJcbiAgICAsIGl0ZW1cbiAgICAsIHNwYWNlXG4gICAgLCBpXG4gICAgLCBsO1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICAvLyBuZXdsaW5lXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubmV3bGluZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ3NwYWNlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBjYXAgPSBjYXBbMF0ucmVwbGFjZSgvXiB7NH0vZ20sICcnKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICA/IGNhcC5yZXBsYWNlKC9cXG4rJC8sICcnKVxuICAgICAgICAgIDogY2FwXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGZlbmNlcyAoZ2ZtKVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmZlbmNlcy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICBsYW5nOiBjYXBbMl0sXG4gICAgICAgIHRleHQ6IGNhcFszXSB8fCAnJ1xuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoZWFkaW5nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgdGV4dDogY2FwWzJdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIG5vIGxlYWRpbmcgcGlwZSAoZ2ZtKVxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMubnB0YWJsZS5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKVxuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtLmNlbGxzW2ldID0gaXRlbS5jZWxsc1tpXS5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKGl0ZW0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaGVhZGluZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxoZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIGRlcHRoOiBjYXBbMl0gPT09ICc9JyA/IDEgOiAyLFxuICAgICAgICB0ZXh0OiBjYXBbMV1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaHJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5oci5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hyJ1xuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBibG9ja3F1b3RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYmxvY2txdW90ZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9zdGFydCdcbiAgICAgIH0pO1xuXG4gICAgICBjYXAgPSBjYXBbMF0ucmVwbGFjZSgvXiAqPiA/L2dtLCAnJyk7XG5cbiAgICAgIC8vIFBhc3MgYHRvcGAgdG8ga2VlcCB0aGUgY3VycmVudFxuICAgICAgLy8gXCJ0b3BsZXZlbFwiIHN0YXRlLiBUaGlzIGlzIGV4YWN0bHlcbiAgICAgIC8vIGhvdyBtYXJrZG93bi5wbCB3b3Jrcy5cbiAgICAgIHRoaXMudG9rZW4oY2FwLCB0b3AsIHRydWUpO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGVfZW5kJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpc3RcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saXN0LmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGJ1bGwgPSBjYXBbMl07XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlzdF9zdGFydCcsXG4gICAgICAgIG9yZGVyZWQ6IGJ1bGwubGVuZ3RoID4gMVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEdldCBlYWNoIHRvcC1sZXZlbCBpdGVtLlxuICAgICAgY2FwID0gY2FwWzBdLm1hdGNoKHRoaXMucnVsZXMuaXRlbSk7XG5cbiAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgIGwgPSBjYXAubGVuZ3RoO1xuICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBjYXBbaV07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0IGl0ZW0ncyBidWxsZXRcbiAgICAgICAgLy8gc28gaXQgaXMgc2VlbiBhcyB0aGUgbmV4dCB0b2tlbi5cbiAgICAgICAgc3BhY2UgPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgaXRlbSA9IGl0ZW0ucmVwbGFjZSgvXiAqKFsqKy1dfFxcZCtcXC4pICsvLCAnJyk7XG5cbiAgICAgICAgLy8gT3V0ZGVudCB3aGF0ZXZlciB0aGVcbiAgICAgICAgLy8gbGlzdCBpdGVtIGNvbnRhaW5zLiBIYWNreS5cbiAgICAgICAgaWYgKH5pdGVtLmluZGV4T2YoJ1xcbiAnKSkge1xuICAgICAgICAgIHNwYWNlIC09IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgIGl0ZW0gPSAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgICA/IGl0ZW0ucmVwbGFjZShuZXcgUmVnRXhwKCdeIHsxLCcgKyBzcGFjZSArICd9JywgJ2dtJyksICcnKVxuICAgICAgICAgICAgOiBpdGVtLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBuZXh0IGxpc3QgaXRlbSBiZWxvbmdzIGhlcmUuXG4gICAgICAgIC8vIEJhY2twZWRhbCBpZiBpdCBkb2VzIG5vdCBiZWxvbmcgaW4gdGhpcyBsaXN0LlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtYXJ0TGlzdHMgJiYgaSAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBiID0gYmxvY2suYnVsbGV0LmV4ZWMoY2FwW2kgKyAxXSlbMF07XG4gICAgICAgICAgaWYgKGJ1bGwgIT09IGIgJiYgIShidWxsLmxlbmd0aCA+IDEgJiYgYi5sZW5ndGggPiAxKSkge1xuICAgICAgICAgICAgc3JjID0gY2FwLnNsaWNlKGkgKyAxKS5qb2luKCdcXG4nKSArIHNyYztcbiAgICAgICAgICAgIGkgPSBsIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBpdGVtIGlzIGxvb3NlIG9yIG5vdC5cbiAgICAgICAgLy8gVXNlOiAvKF58XFxuKSg/ISApW15cXG5dK1xcblxcbig/IVxccyokKS9cbiAgICAgICAgLy8gZm9yIGRpc2NvdW50IGJlaGF2aW9yLlxuICAgICAgICBsb29zZSA9IG5leHQgfHwgL1xcblxcbig/IVxccyokKS8udGVzdChpdGVtKTtcbiAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgbmV4dCA9IGl0ZW0uY2hhckF0KGl0ZW0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nO1xuICAgICAgICAgIGlmICghbG9vc2UpIGxvb3NlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGxvb3NlXG4gICAgICAgICAgICA/ICdsb29zZV9pdGVtX3N0YXJ0J1xuICAgICAgICAgICAgOiAnbGlzdF9pdGVtX3N0YXJ0J1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZWN1cnNlLlxuICAgICAgICB0aGlzLnRva2VuKGl0ZW0sIGZhbHNlLCBicSk7XG5cbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2xpc3RfaXRlbV9lbmQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpc3RfZW5kJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGh0bWxcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5odG1sLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgICA/ICdwYXJhZ3JhcGgnXG4gICAgICAgICAgOiAnaHRtbCcsXG4gICAgICAgIHByZTogIXRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICAmJiAoY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyksXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBkZWZcbiAgICBpZiAoKCFicSAmJiB0b3ApICYmIChjYXAgPSB0aGlzLnJ1bGVzLmRlZi5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMubGlua3NbY2FwWzFdLnRvTG93ZXJDYXNlKCldID0ge1xuICAgICAgICBocmVmOiBjYXBbMl0sXG4gICAgICAgIHRpdGxlOiBjYXBbM11cbiAgICAgIH07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWJsZSAoZ2ZtKVxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMudGFibGUuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGNlbGxzOiBjYXBbM10ucmVwbGFjZSgvKD86ICpcXHwgKik/XFxuJC8sICcnKS5zcGxpdCgnXFxuJylcbiAgICAgIH07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbS5jZWxsc1tpXSA9IGl0ZW0uY2VsbHNbaV1cbiAgICAgICAgICAucmVwbGFjZSgvXiAqXFx8ICp8ICpcXHwgKiQvZywgJycpXG4gICAgICAgICAgLnNwbGl0KC8gKlxcfCAqLyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goaXRlbSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLnBhcmFncmFwaC5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICB0ZXh0OiBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbidcbiAgICAgICAgICA/IGNhcFsxXS5zbGljZSgwLCAtMSlcbiAgICAgICAgICA6IGNhcFsxXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0ZXh0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGV4dC5leGVjKHNyYykpIHtcbiAgICAgIC8vIFRvcC1sZXZlbCBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZS5cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3XG4gICAgICAgIEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMudG9rZW5zO1xufTtcblxuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBpbmxpbmUgPSB7XG4gIGVzY2FwZTogL15cXFxcKFtcXFxcYCp7fVxcW1xcXSgpIytcXC0uIV8+XSkvLFxuICBhdXRvbGluazogL148KFteID5dKyhAfDpcXC8pW14gPl0rKT4vLFxuICB1cmw6IG5vb3AsXG4gIHRhZzogL148IS0tW1xcc1xcU10qPy0tPnxePFxcLz9cXHcrKD86XCJbXlwiXSpcInwnW14nXSonfFteJ1wiPl0pKj8+LyxcbiAgbGluazogL14hP1xcWyhpbnNpZGUpXFxdXFwoaHJlZlxcKS8sXG4gIHJlZmxpbms6IC9eIT9cXFsoaW5zaWRlKVxcXVxccypcXFsoW15cXF1dKilcXF0vLFxuICBub2xpbms6IC9eIT9cXFsoKD86XFxbW15cXF1dKlxcXXxbXlxcW1xcXV0pKilcXF0vLFxuICBzdHJvbmc6IC9eX18oW1xcc1xcU10rPylfXyg/IV8pfF5cXCpcXCooW1xcc1xcU10rPylcXCpcXCooPyFcXCopLyxcbiAgZW06IC9eXFxiXygoPzpbXl9dfF9fKSs/KV9cXGJ8XlxcKigoPzpcXCpcXCp8W1xcc1xcU10pKz8pXFwqKD8hXFwqKS8sXG4gIGNvZGU6IC9eKGArKVxccyooW1xcc1xcU10qP1teYF0pXFxzKlxcMSg/IWApLyxcbiAgYnI6IC9eIHsyLH1cXG4oPyFcXHMqJCkvLFxuICBkZWw6IG5vb3AsXG4gIHRleHQ6IC9eW1xcc1xcU10rPyg/PVtcXFxcPCFcXFtfKmBdfCB7Mix9XFxufCQpL1xufTtcblxuaW5saW5lLl9pbnNpZGUgPSAvKD86XFxbW15cXF1dKlxcXXxbXlxcW1xcXV18XFxdKD89W15cXFtdKlxcXSkpKi87XG5pbmxpbmUuX2hyZWYgPSAvXFxzKjw/KFtcXHNcXFNdKj8pPj8oPzpcXHMrWydcIl0oW1xcc1xcU10qPylbJ1wiXSk/XFxzKi87XG5cbmlubGluZS5saW5rID0gcmVwbGFjZShpbmxpbmUubGluaylcbiAgKCdpbnNpZGUnLCBpbmxpbmUuX2luc2lkZSlcbiAgKCdocmVmJywgaW5saW5lLl9ocmVmKVxuICAoKTtcblxuaW5saW5lLnJlZmxpbmsgPSByZXBsYWNlKGlubGluZS5yZWZsaW5rKVxuICAoJ2luc2lkZScsIGlubGluZS5faW5zaWRlKVxuICAoKTtcblxuLyoqXG4gKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUubm9ybWFsID0gbWVyZ2Uoe30sIGlubGluZSk7XG5cbi8qKlxuICogUGVkYW50aWMgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUucGVkYW50aWMgPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBzdHJvbmc6IC9eX18oPz1cXFMpKFtcXHNcXFNdKj9cXFMpX18oPyFfKXxeXFwqXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKlxcKig/IVxcKikvLFxuICBlbTogL15fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKXxeXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKig/IVxcKikvXG59KTtcblxuLyoqXG4gKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuZ2ZtID0gbWVyZ2Uoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgZXNjYXBlOiByZXBsYWNlKGlubGluZS5lc2NhcGUpKCddKScsICd+fF0pJykoKSxcbiAgdXJsOiAvXihodHRwcz86XFwvXFwvW15cXHM8XStbXjwuLDo7XCInKVxcXVxcc10pLyxcbiAgZGVsOiAvXn5+KD89XFxTKShbXFxzXFxTXSo/XFxTKX5+LyxcbiAgdGV4dDogcmVwbGFjZShpbmxpbmUudGV4dClcbiAgICAoJ118JywgJ35dfCcpXG4gICAgKCd8JywgJ3xodHRwcz86Ly98JylcbiAgICAoKVxufSk7XG5cbi8qKlxuICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuYnJlYWtzID0gbWVyZ2Uoe30sIGlubGluZS5nZm0sIHtcbiAgYnI6IHJlcGxhY2UoaW5saW5lLmJyKSgnezIsfScsICcqJykoKSxcbiAgdGV4dDogcmVwbGFjZShpbmxpbmUuZ2ZtLnRleHQpKCd7Mix9JywgJyonKSgpXG59KTtcblxuLyoqXG4gKiBJbmxpbmUgTGV4ZXIgJiBDb21waWxlclxuICovXG5cbmZ1bmN0aW9uIElubGluZUxleGVyKGxpbmtzLCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLmxpbmtzID0gbGlua3M7XG4gIHRoaXMucnVsZXMgPSBpbmxpbmUubm9ybWFsO1xuICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmICghdGhpcy5saW5rcykge1xuICAgIHRocm93IG5ld1xuICAgICAgRXJyb3IoJ1Rva2VucyBhcnJheSByZXF1aXJlcyBhIGBsaW5rc2AgcHJvcGVydHkuJyk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gaW5saW5lLmJyZWFrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5nZm07XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgIHRoaXMucnVsZXMgPSBpbmxpbmUucGVkYW50aWM7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgSW5saW5lIFJ1bGVzXG4gKi9cblxuSW5saW5lTGV4ZXIucnVsZXMgPSBpbmxpbmU7XG5cbi8qKlxuICogU3RhdGljIExleGluZy9Db21waWxpbmcgTWV0aG9kXG4gKi9cblxuSW5saW5lTGV4ZXIub3V0cHV0ID0gZnVuY3Rpb24oc3JjLCBsaW5rcywgb3B0aW9ucykge1xuICB2YXIgaW5saW5lID0gbmV3IElubGluZUxleGVyKGxpbmtzLCBvcHRpb25zKTtcbiAgcmV0dXJuIGlubGluZS5vdXRwdXQoc3JjKTtcbn07XG5cbi8qKlxuICogTGV4aW5nL0NvbXBpbGluZ1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbihzcmMpIHtcbiAgdmFyIG91dCA9ICcnXG4gICAgLCBsaW5rXG4gICAgLCB0ZXh0XG4gICAgLCBocmVmXG4gICAgLCBjYXA7XG5cbiAgd2hpbGUgKHNyYykge1xuICAgIC8vIGVzY2FwZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmVzY2FwZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gY2FwWzFdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYXV0b2xpbmtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5hdXRvbGluay5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGNhcFsxXS5jaGFyQXQoNikgPT09ICc6J1xuICAgICAgICAgID8gdGhpcy5tYW5nbGUoY2FwWzFdLnN1YnN0cmluZyg3KSlcbiAgICAgICAgICA6IHRoaXMubWFuZ2xlKGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSB0aGlzLm1hbmdsZSgnbWFpbHRvOicpICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICB9XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdXJsIChnZm0pXG4gICAgaWYgKCF0aGlzLmluTGluayAmJiAoY2FwID0gdGhpcy5ydWxlcy51cmwuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGluayhocmVmLCBudWxsLCB0ZXh0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRhZy5leGVjKHNyYykpIHtcbiAgICAgIGlmICghdGhpcy5pbkxpbmsgJiYgL148YSAvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmluTGluayAmJiAvXjxcXC9hPi9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmluTGluayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyXG4gICAgICAgICAgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGNhcFswXSlcbiAgICAgICAgICA6IGVzY2FwZShjYXBbMF0pXG4gICAgICAgIDogY2FwWzBdXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaW5rXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGluay5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLmluTGluayA9IHRydWU7XG4gICAgICBvdXQgKz0gdGhpcy5vdXRwdXRMaW5rKGNhcCwge1xuICAgICAgICBocmVmOiBjYXBbMl0sXG4gICAgICAgIHRpdGxlOiBjYXBbM11cbiAgICAgIH0pO1xuICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHJlZmxpbmssIG5vbGlua1xuICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5yZWZsaW5rLmV4ZWMoc3JjKSlcbiAgICAgICAgfHwgKGNhcCA9IHRoaXMucnVsZXMubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgIGxpbmsgPSB0aGlzLmxpbmtzW2xpbmsudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoIWxpbmsgfHwgIWxpbmsuaHJlZikge1xuICAgICAgICBvdXQgKz0gY2FwWzBdLmNoYXJBdCgwKTtcbiAgICAgICAgc3JjID0gY2FwWzBdLnN1YnN0cmluZygxKSArIHNyYztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmluTGluayA9IHRydWU7XG4gICAgICBvdXQgKz0gdGhpcy5vdXRwdXRMaW5rKGNhcCwgbGluayk7XG4gICAgICB0aGlzLmluTGluayA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gc3Ryb25nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuc3Ryb25nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnN0cm9uZyh0aGlzLm91dHB1dChjYXBbMl0gfHwgY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBlbVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmVtLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmVtKHRoaXMub3V0cHV0KGNhcFsyXSB8fCBjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGNvZGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5jb2RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmNvZGVzcGFuKGVzY2FwZShjYXBbMl0sIHRydWUpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGJyXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYnIuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYnIoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlbCAoZ2ZtKVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmRlbC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5kZWwodGhpcy5vdXRwdXQoY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0ZXh0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGV4dC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci50ZXh0KGVzY2FwZSh0aGlzLnNtYXJ0eXBhbnRzKGNhcFswXSkpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzcmMpIHtcbiAgICAgIHRocm93IG5ld1xuICAgICAgICBFcnJvcignSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvbXBpbGUgTGlua1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5vdXRwdXRMaW5rID0gZnVuY3Rpb24oY2FwLCBsaW5rKSB7XG4gIHZhciBocmVmID0gZXNjYXBlKGxpbmsuaHJlZilcbiAgICAsIHRpdGxlID0gbGluay50aXRsZSA/IGVzY2FwZShsaW5rLnRpdGxlKSA6IG51bGw7XG5cbiAgcmV0dXJuIGNhcFswXS5jaGFyQXQoMCkgIT09ICchJ1xuICAgID8gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIHRpdGxlLCB0aGlzLm91dHB1dChjYXBbMV0pKVxuICAgIDogdGhpcy5yZW5kZXJlci5pbWFnZShocmVmLCB0aXRsZSwgZXNjYXBlKGNhcFsxXSkpO1xufTtcblxuLyoqXG4gKiBTbWFydHlwYW50cyBUcmFuc2Zvcm1hdGlvbnNcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUuc21hcnR5cGFudHMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzKSByZXR1cm4gdGV4dDtcbiAgcmV0dXJuIHRleHRcbiAgICAvLyBlbS1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0tL2csICdcXHUyMDE0JylcbiAgICAvLyBlbi1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0vZywgJ1xcdTIwMTMnKVxuICAgIC8vIG9wZW5pbmcgc2luZ2xlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcIlxcc10pJy9nLCAnJDFcXHUyMDE4JylcbiAgICAvLyBjbG9zaW5nIHNpbmdsZXMgJiBhcG9zdHJvcGhlc1xuICAgIC5yZXBsYWNlKC8nL2csICdcXHUyMDE5JylcbiAgICAvLyBvcGVuaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XFx1MjAxOFxcc10pXCIvZywgJyQxXFx1MjAxYycpXG4gICAgLy8gY2xvc2luZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoL1wiL2csICdcXHUyMDFkJylcbiAgICAvLyBlbGxpcHNlc1xuICAgIC5yZXBsYWNlKC9cXC57M30vZywgJ1xcdTIwMjYnKTtcbn07XG5cbi8qKlxuICogTWFuZ2xlIExpbmtzXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm1hbmdsZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMubWFuZ2xlKSByZXR1cm4gdGV4dDtcbiAgdmFyIG91dCA9ICcnXG4gICAgLCBsID0gdGV4dC5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBjaDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJlbmRlcmVyXG4gKi9cblxuZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xufVxuXG5SZW5kZXJlci5wcm90b3R5cGUuY29kZSA9IGZ1bmN0aW9uKGNvZGUsIGxhbmcsIGVzY2FwZWQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5vcHRpb25zLmhpZ2hsaWdodChjb2RlLCBsYW5nKTtcbiAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBjb2RlKSB7XG4gICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgIGNvZGUgPSBvdXQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFsYW5nKSB7XG4gICAgcmV0dXJuICc8cHJlPjxjb2RlPidcbiAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICAgKyAnXFxuPC9jb2RlPjwvcHJlPic7XG4gIH1cblxuICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInXG4gICAgKyB0aGlzLm9wdGlvbnMubGFuZ1ByZWZpeFxuICAgICsgZXNjYXBlKGxhbmcsIHRydWUpXG4gICAgKyAnXCI+J1xuICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICsgJ1xcbjwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJsb2NrcXVvdGUgPSBmdW5jdGlvbihxdW90ZSkge1xuICByZXR1cm4gJzxibG9ja3F1b3RlPlxcbicgKyBxdW90ZSArICc8L2Jsb2NrcXVvdGU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24oaHRtbCkge1xuICByZXR1cm4gaHRtbDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5oZWFkaW5nID0gZnVuY3Rpb24odGV4dCwgbGV2ZWwsIHJhdykge1xuICByZXR1cm4gJzxoJ1xuICAgICsgbGV2ZWxcbiAgICArICcgaWQ9XCInXG4gICAgKyB0aGlzLm9wdGlvbnMuaGVhZGVyUHJlZml4XG4gICAgKyByYXcudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXlxcd10rL2csICctJylcbiAgICArICdcIj4nXG4gICAgKyB0ZXh0XG4gICAgKyAnPC9oJ1xuICAgICsgbGV2ZWxcbiAgICArICc+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5ociA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxoci8+XFxuJyA6ICc8aHI+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24oYm9keSwgb3JkZXJlZCkge1xuICB2YXIgdHlwZSA9IG9yZGVyZWQgPyAnb2wnIDogJ3VsJztcbiAgcmV0dXJuICc8JyArIHR5cGUgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGlzdGl0ZW0gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGxpPicgKyB0ZXh0ICsgJzwvbGk+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5wYXJhZ3JhcGggPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPHA+JyArIHRleHQgKyAnPC9wPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbihoZWFkZXIsIGJvZHkpIHtcbiAgcmV0dXJuICc8dGFibGU+XFxuJ1xuICAgICsgJzx0aGVhZD5cXG4nXG4gICAgKyBoZWFkZXJcbiAgICArICc8L3RoZWFkPlxcbidcbiAgICArICc8dGJvZHk+XFxuJ1xuICAgICsgYm9keVxuICAgICsgJzwvdGJvZHk+XFxuJ1xuICAgICsgJzwvdGFibGU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZXJvdyA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgcmV0dXJuICc8dHI+XFxuJyArIGNvbnRlbnQgKyAnPC90cj5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlY2VsbCA9IGZ1bmN0aW9uKGNvbnRlbnQsIGZsYWdzKSB7XG4gIHZhciB0eXBlID0gZmxhZ3MuaGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gIHZhciB0YWcgPSBmbGFncy5hbGlnblxuICAgID8gJzwnICsgdHlwZSArICcgc3R5bGU9XCJ0ZXh0LWFsaWduOicgKyBmbGFncy5hbGlnbiArICdcIj4nXG4gICAgOiAnPCcgKyB0eXBlICsgJz4nO1xuICByZXR1cm4gdGFnICsgY29udGVudCArICc8LycgKyB0eXBlICsgJz5cXG4nO1xufTtcblxuLy8gc3BhbiBsZXZlbCByZW5kZXJlclxuUmVuZGVyZXIucHJvdG90eXBlLnN0cm9uZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8c3Ryb25nPicgKyB0ZXh0ICsgJzwvc3Ryb25nPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZW0gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGVtPicgKyB0ZXh0ICsgJzwvZW0+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jb2Rlc3BhbiA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8Y29kZT4nICsgdGV4dCArICc8L2NvZGU+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5iciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxici8+JyA6ICc8YnI+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGRlbD4nICsgdGV4dCArICc8L2RlbD4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpbmsgPSBmdW5jdGlvbihocmVmLCB0aXRsZSwgdGV4dCkge1xuICBpZiAodGhpcy5vcHRpb25zLnNhbml0aXplKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBwcm90ID0gZGVjb2RlVVJJQ29tcG9uZW50KHVuZXNjYXBlKGhyZWYpKVxuICAgICAgICAucmVwbGFjZSgvW15cXHc6XS9nLCAnJylcbiAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAocHJvdC5pbmRleE9mKCdqYXZhc2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZigndmJzY3JpcHQ6JykgPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbiAgdmFyIG91dCA9ICc8YSBocmVmPVwiJyArIGhyZWYgKyAnXCInO1xuICBpZiAodGl0bGUpIHtcbiAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gIH1cbiAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaW1hZ2UgPSBmdW5jdGlvbihocmVmLCB0aXRsZSwgdGV4dCkge1xuICB2YXIgb3V0ID0gJzxpbWcgc3JjPVwiJyArIGhyZWYgKyAnXCIgYWx0PVwiJyArIHRleHQgKyAnXCInO1xuICBpZiAodGl0bGUpIHtcbiAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gIH1cbiAgb3V0ICs9IHRoaXMub3B0aW9ucy54aHRtbCA/ICcvPicgOiAnPic7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuIHRleHQ7XG59O1xuXG4vKipcbiAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAqL1xuXG5mdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLnRva2VuID0gbnVsbDtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbn1cblxuLyoqXG4gKiBTdGF0aWMgUGFyc2UgTWV0aG9kXG4gKi9cblxuUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zLCByZW5kZXJlcikge1xuICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zLCByZW5kZXJlcik7XG4gIHJldHVybiBwYXJzZXIucGFyc2Uoc3JjKTtcbn07XG5cbi8qKlxuICogUGFyc2UgTG9vcFxuICovXG5cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzcmMpIHtcbiAgdGhpcy5pbmxpbmUgPSBuZXcgSW5saW5lTGV4ZXIoc3JjLmxpbmtzLCB0aGlzLm9wdGlvbnMsIHRoaXMucmVuZGVyZXIpO1xuICB0aGlzLnRva2VucyA9IHNyYy5yZXZlcnNlKCk7XG5cbiAgdmFyIG91dCA9ICcnO1xuICB3aGlsZSAodGhpcy5uZXh0KCkpIHtcbiAgICBvdXQgKz0gdGhpcy50b2soKTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5leHQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9rZW4gPSB0aGlzLnRva2Vucy5wb3AoKTtcbn07XG5cbi8qKlxuICogUHJldmlldyBOZXh0IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXSB8fCAwO1xufTtcblxuLyoqXG4gKiBQYXJzZSBUZXh0IFRva2Vuc1xuICovXG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VUZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBib2R5ID0gdGhpcy50b2tlbi50ZXh0O1xuXG4gIHdoaWxlICh0aGlzLnBlZWsoKS50eXBlID09PSAndGV4dCcpIHtcbiAgICBib2R5ICs9ICdcXG4nICsgdGhpcy5uZXh0KCkudGV4dDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmlubGluZS5vdXRwdXQoYm9keSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIEN1cnJlbnQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnRvayA9IGZ1bmN0aW9uKCkge1xuICBzd2l0Y2ggKHRoaXMudG9rZW4udHlwZSkge1xuICAgIGNhc2UgJ3NwYWNlJzoge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjYXNlICdocic6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmhyKCk7XG4gICAgfVxuICAgIGNhc2UgJ2hlYWRpbmcnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5oZWFkaW5nKFxuICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KSxcbiAgICAgICAgdGhpcy50b2tlbi5kZXB0aCxcbiAgICAgICAgdGhpcy50b2tlbi50ZXh0KTtcbiAgICB9XG4gICAgY2FzZSAnY29kZSc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmNvZGUodGhpcy50b2tlbi50ZXh0LFxuICAgICAgICB0aGlzLnRva2VuLmxhbmcsXG4gICAgICAgIHRoaXMudG9rZW4uZXNjYXBlZCk7XG4gICAgfVxuICAgIGNhc2UgJ3RhYmxlJzoge1xuICAgICAgdmFyIGhlYWRlciA9ICcnXG4gICAgICAgICwgYm9keSA9ICcnXG4gICAgICAgICwgaVxuICAgICAgICAsIHJvd1xuICAgICAgICAsIGNlbGxcbiAgICAgICAgLCBmbGFnc1xuICAgICAgICAsIGo7XG5cbiAgICAgIC8vIGhlYWRlclxuICAgICAgY2VsbCA9ICcnO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudG9rZW4uaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZsYWdzID0geyBoZWFkZXI6IHRydWUsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2ldIH07XG4gICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4uaGVhZGVyW2ldKSxcbiAgICAgICAgICB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25baV0gfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaGVhZGVyICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRva2VuLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvdyA9IHRoaXMudG9rZW4uY2VsbHNbaV07XG5cbiAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbChcbiAgICAgICAgICAgIHRoaXMuaW5saW5lLm91dHB1dChyb3dbal0pLFxuICAgICAgICAgICAgeyBoZWFkZXI6IGZhbHNlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltqXSB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2Jsb2NrcXVvdGVfc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2Jsb2NrcXVvdGVfZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUoYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2xpc3Rfc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnXG4gICAgICAgICwgb3JkZXJlZCA9IHRoaXMudG9rZW4ub3JkZXJlZDtcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0KGJvZHksIG9yZGVyZWQpO1xuICAgIH1cbiAgICBjYXNlICdsaXN0X2l0ZW1fc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfaXRlbV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2tlbi50eXBlID09PSAndGV4dCdcbiAgICAgICAgICA/IHRoaXMucGFyc2VUZXh0KClcbiAgICAgICAgICA6IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdsb29zZV9pdGVtX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2l0ZW1fZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdodG1sJzoge1xuICAgICAgdmFyIGh0bWwgPSAhdGhpcy50b2tlbi5wcmUgJiYgIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICA/IHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpXG4gICAgICAgIDogdGhpcy50b2tlbi50ZXh0O1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaHRtbChodG1sKTtcbiAgICB9XG4gICAgY2FzZSAncGFyYWdyYXBoJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSAndGV4dCc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLnBhcnNlVGV4dCgpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShodG1sLCBlbmNvZGUpIHtcbiAgcmV0dXJuIGh0bWxcbiAgICAucmVwbGFjZSghZW5jb2RlID8gLyYoPyEjP1xcdys7KS9nIDogLyYvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAucmVwbGFjZSgvJy9nLCAnJiMzOTsnKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGUoaHRtbCkge1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKC8mKFsjXFx3XSspOy9nLCBmdW5jdGlvbihfLCBuKSB7XG4gICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobiA9PT0gJ2NvbG9uJykgcmV0dXJuICc6JztcbiAgICBpZiAobi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG4uc3Vic3RyaW5nKDIpLCAxNikpXG4gICAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlKHJlZ2V4LCBvcHQpIHtcbiAgcmVnZXggPSByZWdleC5zb3VyY2U7XG4gIG9wdCA9IG9wdCB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlbGYobmFtZSwgdmFsKSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICB2YWwgPSB2YWwuc291cmNlIHx8IHZhbDtcbiAgICB2YWwgPSB2YWwucmVwbGFjZSgvKF58W15cXFtdKVxcXi9nLCAnJDEnKTtcbiAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5ub29wLmV4ZWMgPSBub29wO1xuXG5mdW5jdGlvbiBtZXJnZShvYmopIHtcbiAgdmFyIGkgPSAxXG4gICAgLCB0YXJnZXRcbiAgICAsIGtleTtcblxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIG9ialtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuXG4vKipcbiAqIE1hcmtlZFxuICovXG5cbmZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrIHx8IHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdDtcbiAgICAgIG9wdCA9IG51bGw7XG4gICAgfVxuXG4gICAgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcblxuICAgIHZhciBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0XG4gICAgICAsIHRva2Vuc1xuICAgICAgLCBwZW5kaW5nXG4gICAgICAsIGkgPSAwO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRva2VucyA9IExleGVyLmxleChzcmMsIG9wdClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgfVxuXG4gICAgcGVuZGluZyA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgb3V0ID0gUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gZTtcbiAgICAgIH1cblxuICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcblxuICAgICAgcmV0dXJuIGVyclxuICAgICAgICA/IGNhbGxiYWNrKGVycilcbiAgICAgICAgOiBjYWxsYmFjayhudWxsLCBvdXQpO1xuICAgIH07XG5cbiAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcblxuICAgIGlmICghcGVuZGluZykgcmV0dXJuIGRvbmUoKTtcblxuICAgIGZvciAoOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAoZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdjb2RlJykge1xuICAgICAgICAgIHJldHVybiAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdobGlnaHQodG9rZW4udGV4dCwgdG9rZW4ubGFuZywgZnVuY3Rpb24oZXJyLCBjb2RlKSB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICBpZiAoY29kZSA9PSBudWxsIHx8IGNvZGUgPT09IHRva2VuLnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbi50ZXh0ID0gY29kZTtcbiAgICAgICAgICB0b2tlbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKHRva2Vuc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdCkgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0KTtcbiAgICByZXR1cm4gUGFyc2VyLnBhcnNlKExleGVyLmxleChzcmMsIG9wdCksIG9wdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vY2hqai9tYXJrZWQuJztcbiAgICBpZiAoKG9wdCB8fCBtYXJrZWQuZGVmYXVsdHMpLnNpbGVudCkge1xuICAgICAgcmV0dXJuICc8cD5BbiBlcnJvciBvY2N1cmVkOjwvcD48cHJlPidcbiAgICAgICAgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICsgJzwvcHJlPic7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zXG4gKi9cblxubWFya2VkLm9wdGlvbnMgPVxubWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHQpIHtcbiAgbWVyZ2UobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICByZXR1cm4gbWFya2VkO1xufTtcblxubWFya2VkLmRlZmF1bHRzID0ge1xuICBnZm06IHRydWUsXG4gIHRhYmxlczogdHJ1ZSxcbiAgYnJlYWtzOiBmYWxzZSxcbiAgcGVkYW50aWM6IGZhbHNlLFxuICBzYW5pdGl6ZTogZmFsc2UsXG4gIHNhbml0aXplcjogbnVsbCxcbiAgbWFuZ2xlOiB0cnVlLFxuICBzbWFydExpc3RzOiBmYWxzZSxcbiAgc2lsZW50OiBmYWxzZSxcbiAgaGlnaGxpZ2h0OiBudWxsLFxuICBsYW5nUHJlZml4OiAnbGFuZy0nLFxuICBzbWFydHlwYW50czogZmFsc2UsXG4gIGhlYWRlclByZWZpeDogJycsXG4gIHJlbmRlcmVyOiBuZXcgUmVuZGVyZXIsXG4gIHhodG1sOiBmYWxzZVxufTtcblxuLyoqXG4gKiBFeHBvc2VcbiAqL1xuXG5tYXJrZWQuUGFyc2VyID0gUGFyc2VyO1xubWFya2VkLnBhcnNlciA9IFBhcnNlci5wYXJzZTtcblxubWFya2VkLlJlbmRlcmVyID0gUmVuZGVyZXI7XG5cbm1hcmtlZC5MZXhlciA9IExleGVyO1xubWFya2VkLmxleGVyID0gTGV4ZXIubGV4O1xuXG5tYXJrZWQuSW5saW5lTGV4ZXIgPSBJbmxpbmVMZXhlcjtcbm1hcmtlZC5pbmxpbmVMZXhlciA9IElubGluZUxleGVyLm91dHB1dDtcblxubWFya2VkLnBhcnNlID0gbWFya2VkO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbWFya2VkO1xufSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFya2VkOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMubWFya2VkID0gbWFya2VkO1xufVxuXG59KS5jYWxsKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpO1xufSgpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21hcmtlZC9saWIvbWFya2VkLmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 60 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Tool = {};\n\nTool.uploadImageSrc = function (filename, w, h) {\n  var query = '';\n  if (w && h) {\n    query = '?imageView2/1/w/' + w + '/h/' + h;\n  }\n  return 'http://7xnrrd.com1.z0.glb.clouddn.com/' + filename + query;\n};\n\nTool.createImagePreviewUrl = function (origin, w, h) {\n  w = w || 40;\n  h = h || 40;\n  return origin + '?imageView2/1/w/' + w + '/h/' + h;\n};\n\nTool.guid = function () {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n};\n\nTool.htmlDecode = function (str) {\n  var s = \"\";\n  if (str.length == 0) return \"\";\n  s = str.replace(/&/g, \"&amp;\");\n  s = s.replace(/</g, \"&lt;\");\n  s = s.replace(/>/g, \"&gt;\");\n  s = s.replace(/ /g, \"&nbsp;\");\n  s = s.replace(/\\'/g, \"&#39;\");\n  s = s.replace(/\\\"/g, \"&quot;\");\n  s = s.replace(/\\n/g, \"<br>\");\n  return s;\n};\n\nTool.htmlEncode = function (str) {\n  var s = \"\";\n  if (str.length == 0) return \"\";\n  s = str.replace(/&amp;/g, \"&\");\n  s = s.replace(/&lt;/g, \"<\");\n  s = s.replace(/&gt;/g, \">\");\n  s = s.replace(/&nbsp;/g, \" \");\n  s = s.replace(/&#39;/g, \"\\'\");\n  s = s.replace(/&quot;/g, \"\\\"\");\n  s = s.replace(/<br>/g, \"\\n\");\n  return s;\n};\n\nexports.default = Tool;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3NlcnZpY2VzL3Rvb2wuYmFiZWwuanM/MWM1NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLElBQUksT0FBTyxFQUFYOztBQUVBLEtBQUssY0FBTCxHQUFzQixVQUFDLFFBQUQsRUFBVyxDQUFYLEVBQWMsQ0FBZCxFQUFvQjtBQUN4QyxNQUFJLFFBQVEsRUFBWjtBQUNBLE1BQUksS0FBSyxDQUFULEVBQVk7QUFDVixZQUFRLHFCQUFxQixDQUFyQixHQUF5QixLQUF6QixHQUFpQyxDQUF6QztBQUNEO0FBQ0QsU0FBTywyQ0FBMkMsUUFBM0MsR0FBc0QsS0FBN0Q7QUFDRCxDQU5EOztBQVFBLEtBQUsscUJBQUwsR0FBNkIsVUFBQyxNQUFELEVBQVMsQ0FBVCxFQUFZLENBQVosRUFBa0I7QUFDN0MsTUFBSSxLQUFLLEVBQVQ7QUFDQSxNQUFJLEtBQUssRUFBVDtBQUNBLFNBQU8sU0FBUyxrQkFBVCxHQUE4QixDQUE5QixHQUFrQyxLQUFsQyxHQUEwQyxDQUFqRDtBQUNELENBSkQ7O0FBTUEsS0FBSyxJQUFMLEdBQVksWUFBTTtBQUNoQixXQUFTLEVBQVQsR0FBYztBQUNaLFdBQU8sS0FBSyxLQUFMLENBQVcsQ0FBQyxJQUFJLEtBQUssTUFBTCxFQUFMLElBQXNCLE9BQWpDLEVBQ0osUUFESSxDQUNLLEVBREwsRUFFSixTQUZJLENBRU0sQ0FGTixDQUFQO0FBR0Q7QUFDRCxTQUFPLE9BQU8sSUFBUCxHQUFjLEdBQWQsR0FBb0IsSUFBcEIsR0FBMkIsR0FBM0IsR0FBaUMsSUFBakMsR0FBd0MsR0FBeEMsR0FDTCxJQURLLEdBQ0UsR0FERixHQUNRLElBRFIsR0FDZSxJQURmLEdBQ3NCLElBRDdCO0FBRUQsQ0FSRDs7QUFVQSxLQUFLLFVBQUwsR0FBa0IsVUFBQyxHQUFELEVBQVM7QUFDekIsTUFBSSxJQUFJLEVBQVI7QUFDQSxNQUFJLElBQUksTUFBSixJQUFjLENBQWxCLEVBQXFCLE9BQU8sRUFBUDtBQUNyQixNQUFJLElBQUksT0FBSixDQUFZLElBQVosRUFBa0IsT0FBbEIsQ0FBSjtBQUNBLE1BQUksRUFBRSxPQUFGLENBQVUsSUFBVixFQUFnQixNQUFoQixDQUFKO0FBQ0EsTUFBSSxFQUFFLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLE1BQWhCLENBQUo7QUFDQSxNQUFJLEVBQUUsT0FBRixDQUFVLElBQVYsRUFBZ0IsUUFBaEIsQ0FBSjtBQUNBLE1BQUksRUFBRSxPQUFGLENBQVUsS0FBVixFQUFpQixPQUFqQixDQUFKO0FBQ0EsTUFBSSxFQUFFLE9BQUYsQ0FBVSxLQUFWLEVBQWlCLFFBQWpCLENBQUo7QUFDQSxNQUFJLEVBQUUsT0FBRixDQUFVLEtBQVYsRUFBaUIsTUFBakIsQ0FBSjtBQUNBLFNBQU8sQ0FBUDtBQUNELENBWEQ7O0FBYUEsS0FBSyxVQUFMLEdBQWtCLFVBQUMsR0FBRCxFQUFTO0FBQ3pCLE1BQUksSUFBSSxFQUFSO0FBQ0EsTUFBSSxJQUFJLE1BQUosSUFBYyxDQUFsQixFQUFxQixPQUFPLEVBQVA7QUFDckIsTUFBSSxJQUFJLE9BQUosQ0FBWSxRQUFaLEVBQXNCLEdBQXRCLENBQUo7QUFDQSxNQUFJLEVBQUUsT0FBRixDQUFVLE9BQVYsRUFBbUIsR0FBbkIsQ0FBSjtBQUNBLE1BQUksRUFBRSxPQUFGLENBQVUsT0FBVixFQUFtQixHQUFuQixDQUFKO0FBQ0EsTUFBSSxFQUFFLE9BQUYsQ0FBVSxTQUFWLEVBQXFCLEdBQXJCLENBQUo7QUFDQSxNQUFJLEVBQUUsT0FBRixDQUFVLFFBQVYsRUFBb0IsSUFBcEIsQ0FBSjtBQUNBLE1BQUksRUFBRSxPQUFGLENBQVUsU0FBVixFQUFxQixJQUFyQixDQUFKO0FBQ0EsTUFBSSxFQUFFLE9BQUYsQ0FBVSxPQUFWLEVBQW1CLElBQW5CLENBQUo7QUFDQSxTQUFPLENBQVA7QUFDRCxDQVhEOztrQkFhZSxJIiwiZmlsZSI6IjYwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibGV0IFRvb2wgPSB7fTtcblxuVG9vbC51cGxvYWRJbWFnZVNyYyA9IChmaWxlbmFtZSwgdywgaCkgPT4ge1xuICB2YXIgcXVlcnkgPSAnJztcbiAgaWYgKHcgJiYgaCkge1xuICAgIHF1ZXJ5ID0gJz9pbWFnZVZpZXcyLzEvdy8nICsgdyArICcvaC8nICsgaDtcbiAgfVxuICByZXR1cm4gJ2h0dHA6Ly83eG5ycmQuY29tMS56MC5nbGIuY2xvdWRkbi5jb20vJyArIGZpbGVuYW1lICsgcXVlcnk7XG59O1xuXG5Ub29sLmNyZWF0ZUltYWdlUHJldmlld1VybCA9IChvcmlnaW4sIHcsIGgpID0+IHtcbiAgdyA9IHcgfHwgNDA7XG4gIGggPSBoIHx8IDQwO1xuICByZXR1cm4gb3JpZ2luICsgJz9pbWFnZVZpZXcyLzEvdy8nICsgdyArICcvaC8nICsgaDtcbn07XG5cblRvb2wuZ3VpZCA9ICgpID0+IHtcbiAgZnVuY3Rpb24gczQoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXG4gICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAuc3Vic3RyaW5nKDEpO1xuICB9XG4gIHJldHVybiBzNCgpICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICtcbiAgICBzNCgpICsgJy0nICsgczQoKSArIHM0KCkgKyBzNCgpO1xufTtcblxuVG9vbC5odG1sRGVjb2RlID0gKHN0cikgPT4ge1xuICBsZXQgcyA9IFwiXCI7XG4gIGlmIChzdHIubGVuZ3RoID09IDApIHJldHVybiBcIlwiO1xuICBzID0gc3RyLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKTtcbiAgcyA9IHMucmVwbGFjZSgvPC9nLCBcIiZsdDtcIik7XG4gIHMgPSBzLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpO1xuICBzID0gcy5yZXBsYWNlKC8gL2csIFwiJm5ic3A7XCIpO1xuICBzID0gcy5yZXBsYWNlKC9cXCcvZywgXCImIzM5O1wiKTtcbiAgcyA9IHMucmVwbGFjZSgvXFxcIi9nLCBcIiZxdW90O1wiKTtcbiAgcyA9IHMucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKTtcbiAgcmV0dXJuIHM7XG59O1xuXG5Ub29sLmh0bWxFbmNvZGUgPSAoc3RyKSA9PiB7XG4gIGxldCBzID0gXCJcIjtcbiAgaWYgKHN0ci5sZW5ndGggPT0gMCkgcmV0dXJuIFwiXCI7XG4gIHMgPSBzdHIucmVwbGFjZSgvJmFtcDsvZywgXCImXCIpO1xuICBzID0gcy5yZXBsYWNlKC8mbHQ7L2csIFwiPFwiKTtcbiAgcyA9IHMucmVwbGFjZSgvJmd0Oy9nLCBcIj5cIik7XG4gIHMgPSBzLnJlcGxhY2UoLyZuYnNwOy9nLCBcIiBcIik7XG4gIHMgPSBzLnJlcGxhY2UoLyYjMzk7L2csIFwiXFwnXCIpO1xuICBzID0gcy5yZXBsYWNlKC8mcXVvdDsvZywgXCJcXFwiXCIpO1xuICBzID0gcy5yZXBsYWNlKC88YnI+L2csIFwiXFxuXCIpO1xuICByZXR1cm4gcztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRvb2w7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9zcmMvc2VydmljZXMvdG9vbC5iYWJlbC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 61 */
/***/ function(module, exports) {

	eval("module.exports = \"\\n  <div class=\\\"modal-mask modal-animation_sign\\\" transition=\\\"modal-animation_sign\\\">\\n    <div class=\\\"modal-wrapper\\\" @click=\\\"close()\\\" >\\n      <div class=\\\"modal-container\\\">\\n        <div class=\\\"card\\\" @click.stop>\\n          <div class=\\\"card-header\\\">\\n            <label class=\\\"robin-checkbox\\\" for=\\\"{{task.id}}\\\">\\n              <input type=\\\"checkbox\\\" id=\\\"{{task.id}}\\\" class=\\\"robin-checkbox--input\\\" v-on:change=\\\"toggleTask(task)\\\" :checked=\\\"task.completed\\\">\\n              <span class=\\\"robin-checkbox--label\\\"></span>\\n            </label>\\n            <input class=\\\"card-header--title card-header--input\\\" :value=\\\"task.title\\\" v-autoblur=\\\"isTitleEditing\\\" @focus=\\\"isTitleEditing = true\\\" @keyup.esc=\\\"cancelEdit\\\" @keyup.enter=\\\"doEditTitle\\\" />\\n          </div>\\n          <div class=\\\"card-body\\\">\\n            <div class=\\\"card-metadata\\\">\\n              <!--  标签 -->\\n<!--               <div class=\\\"card-metadata-item\\\">\\n                <span class=\\\"material-icons card-metadata-item--icons\\\">label_outline</span>\\n\\n              </div> -->\\n              <div class=\\\"card-metadata-item\\\">\\n                <span class=\\\"material-icons card-metadata-item--icons\\\">insert_invitation</span>\\n                <span class=\\\"card-metadata-item--content\\\">{{task.deadline}}</span>\\n              </div>\\n              <div class=\\\"card-metadata-item\\\">\\n                <span class=\\\"material-icons card-metadata-item--icons\\\">create</span>\\n                <div class=\\\"card-metadata-item--content\\\" v-bind:class=\\\"{editing: isDescEditing}\\\" @dblclick=\\\"modifyDesc\\\">\\n                  <div class=\\\"content-value markdownPrased\\\">{{{descriptionMarked}}}</div>\\n                  <textarea class=\\\"content-input\\\" v-autofocus=\\\"isDescEditing\\\" @keyup.esc=\\\"doEditDesc\\\" @blur=\\\"doEditDesc\\\" v-model=\\\"task.description\\\"></textarea>\\n                </div>\\n              </div>\\n              <!-- 子任务 -->\\n<!--               <div class=\\\"card-subtasks\\\">\\n                <ul>\\n                  <li></li>\\n                </ul>\\n                <div class=\\\"card-metadata-item\\\">\\n                  <span class=\\\"material-icons card-metadata-item--icons\\\">add</span>\\n                </div>\\n              </div> -->\\n            </div>\\n          </div>\\n          <div class=\\\"card-footer\\\">\\n              <span></span>\\n              <div> 创建于：{{task.create_time}}</div>\\n              <span></span>\\n          </div>\\n        </div>\\n      </div>\\n    </div>\\n  </div>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrRGV0YWlsLnZ1ZT9hOTU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDhVQUE4VSxTQUFTLG1EQUFtRCxTQUFTLDI0QkFBMjRCLGVBQWUsb1BBQW9QLHVCQUF1QiwrRkFBK0Ysb0JBQW9CLDByQkFBMHJCLGtCQUFrQiIsImZpbGUiOiI2MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJcXG4gIDxkaXYgY2xhc3M9XFxcIm1vZGFsLW1hc2sgbW9kYWwtYW5pbWF0aW9uX3NpZ25cXFwiIHRyYW5zaXRpb249XFxcIm1vZGFsLWFuaW1hdGlvbl9zaWduXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtd3JhcHBlclxcXCIgQGNsaWNrPVxcXCJjbG9zZSgpXFxcIiA+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmRcXFwiIEBjbGljay5zdG9wPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkLWhlYWRlclxcXCI+XFxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJyb2Jpbi1jaGVja2JveFxcXCIgZm9yPVxcXCJ7e3Rhc2suaWR9fVxcXCI+XFxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGlkPVxcXCJ7e3Rhc2suaWR9fVxcXCIgY2xhc3M9XFxcInJvYmluLWNoZWNrYm94LS1pbnB1dFxcXCIgdi1vbjpjaGFuZ2U9XFxcInRvZ2dsZVRhc2sodGFzaylcXFwiIDpjaGVja2VkPVxcXCJ0YXNrLmNvbXBsZXRlZFxcXCI+XFxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicm9iaW4tY2hlY2tib3gtLWxhYmVsXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcImNhcmQtaGVhZGVyLS10aXRsZSBjYXJkLWhlYWRlci0taW5wdXRcXFwiIDp2YWx1ZT1cXFwidGFzay50aXRsZVxcXCIgdi1hdXRvYmx1cj1cXFwiaXNUaXRsZUVkaXRpbmdcXFwiIEBmb2N1cz1cXFwiaXNUaXRsZUVkaXRpbmcgPSB0cnVlXFxcIiBAa2V5dXAuZXNjPVxcXCJjYW5jZWxFZGl0XFxcIiBAa2V5dXAuZW50ZXI9XFxcImRvRWRpdFRpdGxlXFxcIiAvPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZC1ib2R5XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkLW1ldGFkYXRhXFxcIj5cXG4gICAgICAgICAgICAgIDwhLS0gIOagh+etviAtLT5cXG48IS0tICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZC1tZXRhZGF0YS1pdGVtXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm1hdGVyaWFsLWljb25zIGNhcmQtbWV0YWRhdGEtaXRlbS0taWNvbnNcXFwiPmxhYmVsX291dGxpbmU8L3NwYW4+XFxuXFxuICAgICAgICAgICAgICA8L2Rpdj4gLS0+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkLW1ldGFkYXRhLWl0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibWF0ZXJpYWwtaWNvbnMgY2FyZC1tZXRhZGF0YS1pdGVtLS1pY29uc1xcXCI+aW5zZXJ0X2ludml0YXRpb248L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJjYXJkLW1ldGFkYXRhLWl0ZW0tLWNvbnRlbnRcXFwiPnt7dGFzay5kZWFkbGluZX19PC9zcGFuPlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkLW1ldGFkYXRhLWl0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibWF0ZXJpYWwtaWNvbnMgY2FyZC1tZXRhZGF0YS1pdGVtLS1pY29uc1xcXCI+Y3JlYXRlPC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkLW1ldGFkYXRhLWl0ZW0tLWNvbnRlbnRcXFwiIHYtYmluZDpjbGFzcz1cXFwie2VkaXRpbmc6IGlzRGVzY0VkaXRpbmd9XFxcIiBAZGJsY2xpY2s9XFxcIm1vZGlmeURlc2NcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRlbnQtdmFsdWUgbWFya2Rvd25QcmFzZWRcXFwiPnt7e2Rlc2NyaXB0aW9uTWFya2VkfX19PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgPHRleHRhcmVhIGNsYXNzPVxcXCJjb250ZW50LWlucHV0XFxcIiB2LWF1dG9mb2N1cz1cXFwiaXNEZXNjRWRpdGluZ1xcXCIgQGtleXVwLmVzYz1cXFwiZG9FZGl0RGVzY1xcXCIgQGJsdXI9XFxcImRvRWRpdERlc2NcXFwiIHYtbW9kZWw9XFxcInRhc2suZGVzY3JpcHRpb25cXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICA8IS0tIOWtkOS7u+WKoSAtLT5cXG48IS0tICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZC1zdWJ0YXNrc1xcXCI+XFxuICAgICAgICAgICAgICAgIDx1bD5cXG4gICAgICAgICAgICAgICAgICA8bGk+PC9saT5cXG4gICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZC1tZXRhZGF0YS1pdGVtXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibWF0ZXJpYWwtaWNvbnMgY2FyZC1tZXRhZGF0YS1pdGVtLS1pY29uc1xcXCI+YWRkPC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgIDwvZGl2PiAtLT5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtZm9vdGVyXFxcIj5cXG4gICAgICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cXG4gICAgICAgICAgICAgIDxkaXY+IOWIm+W7uuS6ju+8mnt7dGFzay5jcmVhdGVfdGltZX19PC9kaXY+XFxuICAgICAgICAgICAgICA8c3Bhbj48L3NwYW4+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrRGV0YWlsLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 62 */
/***/ function(module, exports) {

	eval("module.exports = \"\\n<app-header></app-header>\\n<div class=\\\"page-content\\\">\\n  <side-menu></side-menu>\\n  <router-view ></router-view>\\n  <task-detail v-if=\\\"show\\\"></task-detail>\\n</div>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrLnZ1ZT80ZTdkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjYyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxhcHAtaGVhZGVyPjwvYXBwLWhlYWRlcj5cXG48ZGl2IGNsYXNzPVxcXCJwYWdlLWNvbnRlbnRcXFwiPlxcbiAgPHNpZGUtbWVudT48L3NpZGUtbWVudT5cXG4gIDxyb3V0ZXItdmlldyA+PC9yb3V0ZXItdmlldz5cXG4gIDx0YXNrLWRldGFpbCB2LWlmPVxcXCJzaG93XFxcIj48L3Rhc2stZGV0YWlsPlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vYXBwL3NyYy9jb21wb25lbnRzL3Rhc2svdGFzay52dWVcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_script__, __vue_template__\n__webpack_require__(64)\n__vue_script__ = __webpack_require__(65)\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] app/src/components/task/taskList.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = __webpack_require__(76)\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (false) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"_v-69fce13a/taskList.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrTGlzdC52dWU/ODE2MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHNCQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQSxZQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI2My5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIWxlc3MhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vdGFza0xpc3QudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vdGFza0xpc3QudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIGFwcC9zcmMvY29tcG9uZW50cy90YXNrL3Rhc2tMaXN0LnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3Rhc2tMaXN0LnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTY5ZmNlMTNhL3Rhc2tMaXN0LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zcmMvY29tcG9uZW50cy90YXNrL3Rhc2tMaXN0LnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 64 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrTGlzdC52dWU/NGJiMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI2NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L2xlc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrTGlzdC52dWVcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _taskItem = __webpack_require__(66);\n\nvar _taskItem2 = _interopRequireDefault(_taskItem);\n\nvar _addItem = __webpack_require__(70);\n\nvar _addItem2 = _interopRequireDefault(_addItem);\n\nvar _tasks = __webpack_require__(58);\n\nvar tasksActions = _interopRequireWildcard(_tasks);\n\nvar _getter = __webpack_require__(18);\n\nvar getters = _interopRequireWildcard(_getter);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// <template>\n//   <div class=\"main-container\" transition=\"animate_routerview\">\n//     <div class=\"main\">\n//       <additem :listid=\"listId\"></additem>\n//       <div class=\"tasklist\">\n//         <taskitem v-for=\"task in tasklist\" :task=\"task\" :index=\"$index\" track-by=\"id\"></taskitem>\n//       </div>\n//       <div class=\"label-trigger\" @click=\"toggleShowCompletedTask\">\n//         显示已完成的task\n//       </div>\n//       <div class=\"tasklist--finished\" transition=\"animation_showtask\" v-show=\"completedShow\">\n//         <taskitem v-for=\"task in completedTasklist\" :task=\"task\" :index=\"$index\" track-by=\"id\"></taskitem>\n//       </div>\n//     </div>\n//   </div>\n// </template>\n// <script>\nexports.default = {\n  route: {\n    data: function data(transition) {\n      this.list_id = this.$route.params.id;\n      var query = {\n        list_id: this.list_id,\n        completed: false,\n        sort: '-update_time'\n      };\n      this.fetchTasks(query);\n      transition.next();\n    },\n    activate: function activate(transition) {\n      transition.next();\n    },\n    deactivate: function deactivate(transition) {\n      transition.next();\n    },\n    canDeactivate: function canDeactivate() {\n      return true;\n    },\n    canReuse: function canReuse() {\n      return false;\n    }\n  },\n  vuex: {\n    actions: {\n      fetchTasks: tasksActions.fetchTasks\n    },\n    getters: {\n      tasks: getters.getTasks,\n      auth: getters.getUserAuth\n    }\n  },\n  computed: {\n    tasklist: function tasklist() {\n      var _this = this;\n\n      var result = this.tasks.filter(function (item) {\n        return item.list_id === _this.list_id && !item.completed;\n      });\n      return result;\n    },\n    completedTasklist: function completedTasklist() {\n      var _this2 = this;\n\n      return this.tasks.filter(function (item) {\n        return item.list_id === _this2.list_id && item.completed;\n      });\n    }\n  },\n  data: function data() {\n    return {\n      list_id: '',\n      completedShow: false,\n      loaded: false\n    };\n  },\n\n  watch: {\n    auth: function auth(val) {\n      if (!val) {\n        this.$router.go('/login');\n      }\n    }\n  },\n  created: function created() {},\n  ready: function ready() {},\n\n  components: {\n    additem: _addItem2.default,\n    taskitem: _taskItem2.default\n  },\n  methods: {\n    'loadCompletedTask': function loadCompletedTask() {\n      var _this3 = this;\n\n      var param = {\n        list_id: this.list_id,\n        completed: true,\n        sort: '-update_time'\n      };\n      this.fetchTasks(param, function () {\n        _this3.loaded = true;\n      });\n    },\n    'toggleShowCompletedTask': function toggleShowCompletedTask() {\n      if (!this.loaded) {\n        this.loadCompletedTask();\n      }\n      this.$data.completedShow = !this.$data.completedShow;\n    }\n  }\n};\n// </script>\n// <style lang=\"less\">\n//   @import '../../public/stylesheets/variables';\n//\n//   @labelTriggerBg: #d8d8d8;\n//\n//   .main-container {\n//     padding-left: @sideMenuWidth + 20;\n//     padding-right: 20px;\n//     width: 100%;\n//     box-sizing: border-box;\n//   }\n//   .main {\n//     // max-width: 980px;\n//     // margin: 0 auto;\n//   }\n//   .tasklist {\n//     display: flex;\n//     flex-wrap: wrap;\n//   }\n//   .label-trigger {\n//     display: inline-block;\n//     margin: 6px 0;\n//     padding: 6px 12px;\n//     background: fade(@labelTriggerBg, 80%);\n//     cursor: pointer;\n//     &:hover{\n//       background: @labelTriggerBg;\n//     }\n//   }\n// </style>\n\n/* generated by vue-loader *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdGFza0xpc3QudnVlP2EyZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBaUJBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztJQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29DQUdBO3dDQUNBOztzQkFFQTttQkFDQTtjQUVBO0FBSkE7c0JBS0E7aUJBQ0E7QUFDQTs0Q0FDQTtpQkFDQTtBQUNBO2dEQUNBO2lCQUNBO0FBQ0E7NENBQ0E7YUFDQTtBQUNBO2tDQUNBO2FBQ0E7QUFFQTtBQXZCQTs7OytCQTJCQTtBQUZBOztxQkFJQTtvQkFHQTtBQUpBO0FBSkE7OztBQVVBOztxREFDQTt1REFDQTtBQUNBO2FBQ0E7QUFDQTs7QUFDQTs7K0NBQ0E7dURBQ0E7QUFDQTtBQUVBO0FBWkE7d0JBYUE7O2VBRUE7cUJBQ0E7Y0FFQTtBQUpBO0FBS0E7Ozs2QkFFQTtnQkFDQTt3QkFDQTtBQUNBO0FBRUE7QUFOQTs4QkFRQSxDQUNBOzBCQUNBLENBQ0E7OztBQUVBO0FBRUE7QUFIQTs7O0FBS0E7OztzQkFFQTttQkFDQTtjQUVBO0FBSkE7eUNBS0E7d0JBQ0E7QUFDQTtBQUNBO2tFQUNBO3dCQUNBO2FBQ0E7QUFDQTs2Q0FDQTtBQWtCQTtBQWpDQTtBQXRFQSIsImZpbGUiOiI2NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1haW4tY29udGFpbmVyXCIgdHJhbnNpdGlvbj1cImFuaW1hdGVfcm91dGVydmlld1wiPlxuICAgIDxkaXYgY2xhc3M9XCJtYWluXCI+XG4gICAgICA8YWRkaXRlbSA6bGlzdGlkPVwibGlzdElkXCI+PC9hZGRpdGVtPlxuICAgICAgPGRpdiBjbGFzcz1cInRhc2tsaXN0XCI+XG4gICAgICAgIDx0YXNraXRlbSB2LWZvcj1cInRhc2sgaW4gdGFza2xpc3RcIiA6dGFzaz1cInRhc2tcIiA6aW5kZXg9XCIkaW5kZXhcIiB0cmFjay1ieT1cImlkXCI+PC90YXNraXRlbT5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImxhYmVsLXRyaWdnZXJcIiBAY2xpY2s9XCJ0b2dnbGVTaG93Q29tcGxldGVkVGFza1wiPlxuICAgICAgICDmmL7npLrlt7LlrozmiJDnmoR0YXNrXG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJ0YXNrbGlzdC0tZmluaXNoZWRcIiB0cmFuc2l0aW9uPVwiYW5pbWF0aW9uX3Nob3d0YXNrXCIgdi1zaG93PVwiY29tcGxldGVkU2hvd1wiPlxuICAgICAgICA8dGFza2l0ZW0gdi1mb3I9XCJ0YXNrIGluIGNvbXBsZXRlZFRhc2tsaXN0XCIgOnRhc2s9XCJ0YXNrXCIgOmluZGV4PVwiJGluZGV4XCIgdHJhY2stYnk9XCJpZFwiPjwvdGFza2l0ZW0+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbiAgaW1wb3J0IFRhc2tJdGVtVmlldyBmcm9tICcuL3Rhc2tJdGVtLnZ1ZSc7XG4gIGltcG9ydCBhZGRJdGVtVmlldyBmcm9tICcuL2FkZEl0ZW0udnVlJztcbiAgaW1wb3J0ICogYXMgdGFza3NBY3Rpb25zIGZyb20gJy4uLy4uL3Z1ZXgvYWN0aW9ucy90YXNrcyc7XG4gIGltcG9ydCAqIGFzIGdldHRlcnMgZnJvbSAnLi4vLi4vdnVleC9nZXR0ZXInO1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICByb3V0ZToge1xuICAgICAgZGF0YSh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoaXMubGlzdF9pZCA9IHRoaXMuJHJvdXRlLnBhcmFtcy5pZDtcbiAgICAgICAgdmFyIHF1ZXJ5ID0ge1xuICAgICAgICAgIGxpc3RfaWQ6IHRoaXMubGlzdF9pZCxcbiAgICAgICAgICBjb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgICAgIHNvcnQ6ICctdXBkYXRlX3RpbWUnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZldGNoVGFza3MocXVlcnkpO1xuICAgICAgICB0cmFuc2l0aW9uLm5leHQoKTtcbiAgICAgIH0sXG4gICAgICBhY3RpdmF0ZSh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRyYW5zaXRpb24ubmV4dCgpO1xuICAgICAgfSxcbiAgICAgIGRlYWN0aXZhdGUodHJhbnNpdGlvbikge1xuICAgICAgICB0cmFuc2l0aW9uLm5leHQoKTtcbiAgICAgIH0sXG4gICAgICBjYW5EZWFjdGl2YXRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBjYW5SZXVzZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICB9LFxuICAgIHZ1ZXg6IHtcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgZmV0Y2hUYXNrczogdGFza3NBY3Rpb25zLmZldGNoVGFza3MsXG4gICAgICB9LFxuICAgICAgZ2V0dGVyczoge1xuICAgICAgICB0YXNrczogZ2V0dGVycy5nZXRUYXNrcyxcbiAgICAgICAgYXV0aDogZ2V0dGVycy5nZXRVc2VyQXV0aCxcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICB0YXNrbGlzdCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMudGFza3MuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0ubGlzdF9pZCA9PT0gdGhpcy5saXN0X2lkICYmICFpdGVtLmNvbXBsZXRlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgY29tcGxldGVkVGFza2xpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2tzLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgIHJldHVybiBpdGVtLmxpc3RfaWQgPT09IHRoaXMubGlzdF9pZCAmJiBpdGVtLmNvbXBsZXRlZDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpc3RfaWQ6ICcnLFxuICAgICAgICBjb21wbGV0ZWRTaG93OiBmYWxzZSxcbiAgICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgYXV0aDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgdGhpcy4kcm91dGVyLmdvKCcvbG9naW4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZCgpIHtcblxuICAgIH0sXG4gICAgcmVhZHkoKSB7XG4gICAgfSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBhZGRpdGVtOiBhZGRJdGVtVmlldyxcbiAgICAgIHRhc2tpdGVtOiBUYXNrSXRlbVZpZXcsXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAnbG9hZENvbXBsZXRlZFRhc2snKCkge1xuICAgICAgICBsZXQgcGFyYW0gPSB7XG4gICAgICAgICAgbGlzdF9pZDogdGhpcy5saXN0X2lkLFxuICAgICAgICAgIGNvbXBsZXRlZDogdHJ1ZSxcbiAgICAgICAgICBzb3J0OiAnLXVwZGF0ZV90aW1lJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mZXRjaFRhc2tzKHBhcmFtLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAndG9nZ2xlU2hvd0NvbXBsZXRlZFRhc2snKCkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2FkQ29tcGxldGVkVGFzaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGRhdGEuY29tcGxldGVkU2hvdyA9ICF0aGlzLiRkYXRhLmNvbXBsZXRlZFNob3c7XG4gICAgICB9LFxuICAgIH0sXG4gICAgLy8gZXZlbnRzOiB7XG4gICAgLy8gICAnZWRpdCB0YXNrJyh0YXNrKSB7XG4gICAgLy8gICAgIGxldCB2bSA9IHRoaXM7XG4gICAgLy8gICAgIHZtLiRodHRwLnB1dCgndGFza3MvJyArIHRhc2suaWQsIHRhc2spXG4gICAgLy8gICAgICAgLnRoZW4oKCkgPT4ge1xuICAgIC8vICAgICAgICAgY29uc29sZS5sb2coJ2VkaXQgdGFzayBzdWNjZXNzIScpO1xuICAgIC8vICAgICAgICAgaWYgKHRhc2suY29tcGxldGVkKSB7XG4gICAgLy8gICAgICAgICAgIHZtLnRhc2tsaXN0LiRyZW1vdmUodGFzayk7XG4gICAgLy8gICAgICAgICAgIHZtLmNvbXBsZXRlZFRhc2tsaXN0LnVuc2hpZnQodGFzayk7XG4gICAgLy8gICAgICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgICAgICB2bS5jb21wbGV0ZWRUYXNrbGlzdC4kcmVtb3ZlKHRhc2spO1xuICAgIC8vICAgICAgICAgICB2bS50YXNrbGlzdC51bnNoaWZ0KHRhc2spO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICAgIH0pO1xuICAgIC8vICAgfSxcbiAgICAvLyB9LFxuICB9O1xuPC9zY3JpcHQ+XG48c3R5bGUgbGFuZz1cImxlc3NcIj5cbiAgQGltcG9ydCAnLi4vLi4vcHVibGljL3N0eWxlc2hlZXRzL3ZhcmlhYmxlcyc7XG5cbiAgQGxhYmVsVHJpZ2dlckJnOiAjZDhkOGQ4O1xuXG4gIC5tYWluLWNvbnRhaW5lciB7XG4gICAgcGFkZGluZy1sZWZ0OiBAc2lkZU1lbnVXaWR0aCArIDIwO1xuICAgIHBhZGRpbmctcmlnaHQ6IDIwcHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgfVxuICAubWFpbiB7XG4gICAgLy8gbWF4LXdpZHRoOiA5ODBweDtcbiAgICAvLyBtYXJnaW46IDAgYXV0bztcbiAgfVxuICAudGFza2xpc3Qge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICB9XG4gIC5sYWJlbC10cmlnZ2VyIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgbWFyZ2luOiA2cHggMDtcbiAgICBwYWRkaW5nOiA2cHggMTJweDtcbiAgICBiYWNrZ3JvdW5kOiBmYWRlKEBsYWJlbFRyaWdnZXJCZywgODAlKTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgJjpob3ZlcntcbiAgICAgIGJhY2tncm91bmQ6IEBsYWJlbFRyaWdnZXJCZztcbiAgICB9XG4gIH1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB0YXNrTGlzdC52dWU/NjM1ZmZjNzFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_script__, __vue_template__\n__webpack_require__(67)\n__vue_script__ = __webpack_require__(68)\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] app/src/components/task/taskItem.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = __webpack_require__(69)\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (false) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"_v-7e07d150/taskItem.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrSXRlbS52dWU/MTBkYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHNCQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQSxZQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI2Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIWxlc3MhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vdGFza0l0ZW0udnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vdGFza0l0ZW0udnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIGFwcC9zcmMvY29tcG9uZW50cy90YXNrL3Rhc2tJdGVtLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3Rhc2tJdGVtLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTdlMDdkMTUwL3Rhc2tJdGVtLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zcmMvY29tcG9uZW50cy90YXNrL3Rhc2tJdGVtLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 67 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrSXRlbS52dWU/ZDFiNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI2Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L2xlc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrSXRlbS52dWVcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _tasks = __webpack_require__(58);\n\nvar tasksActions = _interopRequireWildcard(_tasks);\n\nvar _getter = __webpack_require__(18);\n\nvar getters = _interopRequireWildcard(_getter);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// <template>\n//   <div class=\"task\" transition=\"animation_showtask\" v-bind:class=\"{finished: task.completed, editing: task == taskEditing}\" >\n//     <div class=\"task-checkbox\">\n//       <label class=\"robin-checkbox\" for=\"{{task.id}}\">\n//         <input type=\"checkbox\" id=\"{{task.id}}\" class=\"robin-checkbox--input\" v-on:change=\"toggleTask(task)\" :checked=\"task.completed\">\n//         <span class=\"robin-checkbox--label\"></span>\n//       </label>\n//     </div>\n//     <div class=\"task-content\">\n//       <div class=\"task-content-box\" @click=\"showTaskDetail(task)\">{{task.title}}</div>\n//       <!-- <div class=\"task-content-box\" @dblclick=\"modifyTask(task)\">{{task.title}}</div> -->\n//       <div class=\"robin-textfield task-content-input\">\n//         <input class=\"robin-textfield--input robin-textfield--input_default\" type=\"text\" v-task-autofocus=\"task == taskEditing\" v-model=\"task.title\" class=\"edit\" v-on:blur=\"doEdit(task)\"  v-on:keyup.esc=\"doEdit(task)\" v-on:keyup.enter=\"doEdit(task, $event)\" />\n//       </div>\n//       <div class=\"task-metadata\" v-if=\"task.completed\">\n//         <span>更新时间：{{task.update_time}}</span>\n//         <span>创建时间：{{task.create_time}}</span>\n//       </div>\n//     </div>\n//     <span class=\"task-controller\">\n//       <i class=\"material-icons\" @click=\"deleteTask(task)\">clear</i>\n//     </span>\n//   </div>\n// </template>\n//\n// <script>\nexports.default = {\n  props: ['tasktitle', 'task', 'index'],\n  data: function data() {\n    return {\n      editing: false,\n      titleAfterParse: '',\n      taskEditing: null,\n      taskDetail: {}\n    };\n  },\n\n  vuex: {\n    actions: {\n      toggle: tasksActions.toggleTask,\n      delete: tasksActions.deleteTask,\n      edit: tasksActions.editTask,\n      fetchDetail: tasksActions.fetchTaskDetail\n    },\n    getters: {\n      showDetail: getters.isShowDetail\n    }\n  },\n  computed: {\n    titleAfterParse: function titleAfterParse() {\n      return twemoji.parse(this.task.title);\n    }\n  },\n  ready: function ready() {},\n\n\n  directives: {\n    'task-autofocus': function taskAutofocus(value) {\n      if (!value) {\n        return;\n      }\n      var el = this.el;\n      setTimeout(function () {\n        el.focus();\n      }, 0);\n    }\n  },\n  methods: {\n    toggleTask: function toggleTask() {\n      this.task.completed = !this.task.completed;\n      this.toggle(this.task.id, { completed: this.task.completed });\n    },\n    modifyTask: function modifyTask(task) {\n      if (task.completed) {\n        return false;\n      }\n      this.taskEditing = task;\n    },\n    showTaskDetail: function showTaskDetail(task) {\n      this.fetchDetail(task.id);\n    },\n    deleteTask: function deleteTask(task) {\n      this.delete(task.id);\n    },\n    doEdit: function doEdit(task) {\n      // 如果没有正在编辑的task说明目前并没有编辑操作\n      // 这里也解决了 一个问题：在 input上绑定了 blur 和 keyup两个事件\n      // 按下 enter 执行完成之后，会触发 blur，所以应该执行之后将 taskEditing 置为 null\n      console.log('taskitem do edit');\n      if (!this.taskEditing) {\n        return false;\n      }\n      // if (this.taskEditing.title === task.title) {\n      this.taskEditing = null;\n      //   return false;\n      // }\n      task.title = task.title.replace(/</g, \"&lt\").replace(/>/g, \"&gt;\");\n      this.titleAfterParse = twemoji.parse(task.title);\n      this.edit(task);\n    }\n  }\n};\n// </script>\n//\n// <style lang=\"less\">\n//\n// @import '../../public/stylesheets/variables';\n//\n// @editbox-height: 34px;\n//\n// .modify {\n//   width: 100%;\n//   box-sizing: border-box;\n//   line-height: @editbox-height;\n//   height: @editbox-height;\n//   padding: 0 4px;\n// }\n// .task {\n//   // flex: 1 1 320px;\n//   width: 100%;\n//   height: 50px;\n//   box-sizing: border-box;\n//   font-size: 1.6rem;\n//   color: #343434;\n//   background: fade(@white, 85%);\n//   border-bottom: 1px solid #DCDCDC;\n//   padding: 0 0.5em;\n//   display: flex;\n//   flex-direction: row;\n//   align-items: center;\n//   position: relative;\n//   &:hover {\n//     background: fade(#000, 10%)\n//   }\n//   &.finished {\n//     font-size: 12px;\n//     .task-content {\n//       cursor: default;\n//       text-decoration: line-through;\n//       color: lighten(#343434, 40%);\n//     }\n//   }\n//   &.editing {\n//     .task-content {\n//       &-box {\n//         display: none;\n//       }\n//       &-input {\n//         display: block;\n//       }\n//     }\n//   }\n//   &:hover {\n//     .task-controller {\n//       display: block;\n//     }\n//   }\n// }\n// .task-content {\n//   flex: 1 1 auto;\n//   overflow: hidden;\n//   margin-right: 6rem;\n//   padding: 11px 0;\n//   cursor: pointer;\n//   &-input {\n//     display: none;\n//     width: 100%;\n//     box-sizing: border-box;\n//   }\n//   &-box {\n//     line-height: 31px;\n//     margin-top: -3px;\n//     white-space: nowrap;\n//     overflow: hidden;\n//     text-overflow: ellipsis;\n//     // -webkit-user-select: none;\n//   }\n// }\n// .task-controller {\n//   display: none;\n//   position: absolute;\n//   right: 8px;\n//   top: 30%;\n// }\n//\n// /*\n//   Task item animation\n//  */\n// .animation_showtask-transition {\n//   transition: all 0.5s ease;\n// }\n// .animation_showtask-enter, .animation_showtask-leave {\n//   opacity: 0;\n//   transform: rotateX(180deg);\n// }\n// .animation_showtask {\n//   &-enter {\n//     opacity: 0;\n//     transform: rotateX(180deg);\n//   }\n//   &-levae {\n//     opacity: 0;\n//     transform: rotateX(180deg);\n//     transition: all 0.3s ease;\n//   }\n// }\n// </style>\n\n/* generated by vue-loader *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdGFza0l0ZW0udnVlPzU3NjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBMEJBOzs7O0FBQ0E7O0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBRUE7d0JBQ0E7O2VBRUE7dUJBQ0E7bUJBQ0E7a0JBRUE7QUFMQTtBQU1BOzs7OzJCQUdBOzJCQUNBO3lCQUNBO2dDQUVBO0FBTEE7OzBCQVNBO0FBSEE7QUFQQTs7Z0RBWUE7cUNBQ0E7QUFFQTtBQUpBOzBCQUtBLENBRUE7Ozs7b0RBRUE7a0JBQ0E7QUFDQTtBQUNBO29CQUNBOzZCQUNBO1dBQ0E7U0FDQTtBQUVBO0FBVkE7O3NDQVlBO3VDQUNBO3VEQUNBO0FBQ0E7MENBQ0E7MEJBQ0E7ZUFDQTtBQUNBO3lCQUNBO0FBQ0E7a0RBQ0E7NEJBQ0E7QUFDQTswQ0FDQTt1QkFDQTtBQUVBO2tDQUNBO0FBQ0E7QUFDQTtBQUNBO2tCQUNBOzZCQUNBO2VBQ0E7QUFDQTtBQUNBO3lCQUNBO0FBQ0E7QUFDQTtpRUFDQTtnREFDQTtnQkFDQTtBQUVBO0FBbENBO0FBeENBIiwiZmlsZSI6IjY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwidGFza1wiIHRyYW5zaXRpb249XCJhbmltYXRpb25fc2hvd3Rhc2tcIiB2LWJpbmQ6Y2xhc3M9XCJ7ZmluaXNoZWQ6IHRhc2suY29tcGxldGVkLCBlZGl0aW5nOiB0YXNrID09IHRhc2tFZGl0aW5nfVwiID5cbiAgICA8ZGl2IGNsYXNzPVwidGFzay1jaGVja2JveFwiPlxuICAgICAgPGxhYmVsIGNsYXNzPVwicm9iaW4tY2hlY2tib3hcIiBmb3I9XCJ7e3Rhc2suaWR9fVwiPlxuICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJ7e3Rhc2suaWR9fVwiIGNsYXNzPVwicm9iaW4tY2hlY2tib3gtLWlucHV0XCIgdi1vbjpjaGFuZ2U9XCJ0b2dnbGVUYXNrKHRhc2spXCIgOmNoZWNrZWQ9XCJ0YXNrLmNvbXBsZXRlZFwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cInJvYmluLWNoZWNrYm94LS1sYWJlbFwiPjwvc3Bhbj5cbiAgICAgIDwvbGFiZWw+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInRhc2stY29udGVudFwiPlxuICAgICAgPGRpdiBjbGFzcz1cInRhc2stY29udGVudC1ib3hcIiBAY2xpY2s9XCJzaG93VGFza0RldGFpbCh0YXNrKVwiPnt7dGFzay50aXRsZX19PC9kaXY+XG4gICAgICA8IS0tIDxkaXYgY2xhc3M9XCJ0YXNrLWNvbnRlbnQtYm94XCIgQGRibGNsaWNrPVwibW9kaWZ5VGFzayh0YXNrKVwiPnt7dGFzay50aXRsZX19PC9kaXY+IC0tPlxuICAgICAgPGRpdiBjbGFzcz1cInJvYmluLXRleHRmaWVsZCB0YXNrLWNvbnRlbnQtaW5wdXRcIj5cbiAgICAgICAgPGlucHV0IGNsYXNzPVwicm9iaW4tdGV4dGZpZWxkLS1pbnB1dCByb2Jpbi10ZXh0ZmllbGQtLWlucHV0X2RlZmF1bHRcIiB0eXBlPVwidGV4dFwiIHYtdGFzay1hdXRvZm9jdXM9XCJ0YXNrID09IHRhc2tFZGl0aW5nXCIgdi1tb2RlbD1cInRhc2sudGl0bGVcIiBjbGFzcz1cImVkaXRcIiB2LW9uOmJsdXI9XCJkb0VkaXQodGFzaylcIiAgdi1vbjprZXl1cC5lc2M9XCJkb0VkaXQodGFzaylcIiB2LW9uOmtleXVwLmVudGVyPVwiZG9FZGl0KHRhc2ssICRldmVudClcIiAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwidGFzay1tZXRhZGF0YVwiIHYtaWY9XCJ0YXNrLmNvbXBsZXRlZFwiPlxuICAgICAgICA8c3Bhbj7mm7TmlrDml7bpl7TvvJp7e3Rhc2sudXBkYXRlX3RpbWV9fTwvc3Bhbj5cbiAgICAgICAgPHNwYW4+5Yib5bu65pe26Ze077yae3t0YXNrLmNyZWF0ZV90aW1lfX08L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8c3BhbiBjbGFzcz1cInRhc2stY29udHJvbGxlclwiPlxuICAgICAgPGkgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiIEBjbGljaz1cImRlbGV0ZVRhc2sodGFzaylcIj5jbGVhcjwvaT5cbiAgICA8L3NwYW4+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCAqIGFzIHRhc2tzQWN0aW9ucyBmcm9tICcuLi8uLi92dWV4L2FjdGlvbnMvdGFza3MnO1xuaW1wb3J0ICogYXMgZ2V0dGVycyBmcm9tICcuLi8uLi92dWV4L2dldHRlcic7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiBbJ3Rhc2t0aXRsZScsICd0YXNrJywgJ2luZGV4J10sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVkaXRpbmc6IGZhbHNlLFxuICAgICAgdGl0bGVBZnRlclBhcnNlOiAnJyxcbiAgICAgIHRhc2tFZGl0aW5nOiBudWxsLFxuICAgICAgdGFza0RldGFpbDoge31cbiAgICB9O1xuICB9LFxuICB2dWV4OiB7XG4gICAgYWN0aW9uczoge1xuICAgICAgdG9nZ2xlOiB0YXNrc0FjdGlvbnMudG9nZ2xlVGFzayxcbiAgICAgIGRlbGV0ZTogdGFza3NBY3Rpb25zLmRlbGV0ZVRhc2ssXG4gICAgICBlZGl0OiB0YXNrc0FjdGlvbnMuZWRpdFRhc2ssXG4gICAgICBmZXRjaERldGFpbDogdGFza3NBY3Rpb25zLmZldGNoVGFza0RldGFpbCxcbiAgICB9LFxuICAgIGdldHRlcnM6IHtcbiAgICAgIHNob3dEZXRhaWw6IGdldHRlcnMuaXNTaG93RGV0YWlsLFxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICB0aXRsZUFmdGVyUGFyc2UoKSB7XG4gICAgICByZXR1cm4gdHdlbW9qaS5wYXJzZSh0aGlzLnRhc2sudGl0bGUpO1xuICAgIH1cbiAgfSxcbiAgcmVhZHkoKSB7XG4gIH0sXG5cbiAgZGlyZWN0aXZlczoge1xuICAgICd0YXNrLWF1dG9mb2N1cycodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdG9nZ2xlVGFzaygpIHtcbiAgICAgIHRoaXMudGFzay5jb21wbGV0ZWQgPSAhdGhpcy50YXNrLmNvbXBsZXRlZDtcbiAgICAgIHRoaXMudG9nZ2xlKHRoaXMudGFzay5pZCwge2NvbXBsZXRlZDogdGhpcy50YXNrLmNvbXBsZXRlZH0pO1xuICAgIH0sXG4gICAgbW9kaWZ5VGFzayh0YXNrKSB7XG4gICAgICBpZiAodGFzay5jb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy50YXNrRWRpdGluZyA9IHRhc2s7XG4gICAgfSxcbiAgICBzaG93VGFza0RldGFpbCh0YXNrKSB7XG4gICAgICB0aGlzLmZldGNoRGV0YWlsKHRhc2suaWQpO1xuICAgIH0sXG4gICAgZGVsZXRlVGFzayh0YXNrKSB7XG4gICAgICB0aGlzLmRlbGV0ZSh0YXNrLmlkKTtcbiAgICB9LFxuXG4gICAgZG9FZGl0KHRhc2spIHtcbiAgICAgIC8vIOWmguaenOayoeacieato+WcqOe8lui+keeahHRhc2vor7TmmI7nm67liY3lubbmsqHmnInnvJbovpHmk43kvZxcbiAgICAgIC8vIOi/memHjOS5n+ino+WGs+S6hiDkuIDkuKrpl67popjvvJrlnKggaW5wdXTkuIrnu5HlrprkuoYgYmx1ciDlkowga2V5dXDkuKTkuKrkuovku7ZcbiAgICAgIC8vIOaMieS4iyBlbnRlciDmiafooYzlrozmiJDkuYvlkI7vvIzkvJrop6blj5EgYmx1cu+8jOaJgOS7peW6lOivpeaJp+ihjOS5i+WQjuWwhiB0YXNrRWRpdGluZyDnva7kuLogbnVsbFxuICAgICAgY29uc29sZS5sb2coJ3Rhc2tpdGVtIGRvIGVkaXQnKTtcbiAgICAgIGlmICghdGhpcy50YXNrRWRpdGluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBpZiAodGhpcy50YXNrRWRpdGluZy50aXRsZSA9PT0gdGFzay50aXRsZSkge1xuICAgICAgdGhpcy50YXNrRWRpdGluZyA9IG51bGw7XG4gICAgICAvLyAgIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIH1cbiAgICAgIHRhc2sudGl0bGUgPSB0YXNrLnRpdGxlLnJlcGxhY2UoLzwvZywgXCImbHRcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7XG4gICAgICB0aGlzLnRpdGxlQWZ0ZXJQYXJzZSA9IHR3ZW1vamkucGFyc2UodGFzay50aXRsZSk7XG4gICAgICB0aGlzLmVkaXQodGFzayk7XG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cbkBpbXBvcnQgJy4uLy4uL3B1YmxpYy9zdHlsZXNoZWV0cy92YXJpYWJsZXMnO1xuXG5AZWRpdGJveC1oZWlnaHQ6IDM0cHg7XG5cbi5tb2RpZnkge1xuICB3aWR0aDogMTAwJTtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgbGluZS1oZWlnaHQ6IEBlZGl0Ym94LWhlaWdodDtcbiAgaGVpZ2h0OiBAZWRpdGJveC1oZWlnaHQ7XG4gIHBhZGRpbmc6IDAgNHB4O1xufVxuLnRhc2sge1xuICAvLyBmbGV4OiAxIDEgMzIwcHg7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDUwcHg7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIGZvbnQtc2l6ZTogMS42cmVtO1xuICBjb2xvcjogIzM0MzQzNDtcbiAgYmFja2dyb3VuZDogZmFkZShAd2hpdGUsIDg1JSk7XG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjRENEQ0RDO1xuICBwYWRkaW5nOiAwIDAuNWVtO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICY6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6IGZhZGUoIzAwMCwgMTAlKVxuICB9XG4gICYuZmluaXNoZWQge1xuICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAudGFzay1jb250ZW50IHtcbiAgICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoO1xuICAgICAgY29sb3I6IGxpZ2h0ZW4oIzM0MzQzNCwgNDAlKTtcbiAgICB9XG4gIH1cbiAgJi5lZGl0aW5nIHtcbiAgICAudGFzay1jb250ZW50IHtcbiAgICAgICYtYm94IHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIH1cbiAgICAgICYtaW5wdXQge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgJjpob3ZlciB7XG4gICAgLnRhc2stY29udHJvbGxlciB7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICB9XG4gIH1cbn1cbi50YXNrLWNvbnRlbnQge1xuICBmbGV4OiAxIDEgYXV0bztcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgbWFyZ2luLXJpZ2h0OiA2cmVtO1xuICBwYWRkaW5nOiAxMXB4IDA7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgJi1pbnB1dCB7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICB9XG4gICYtYm94IHtcbiAgICBsaW5lLWhlaWdodDogMzFweDtcbiAgICBtYXJnaW4tdG9wOiAtM3B4O1xuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAvLyAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICB9XG59XG4udGFzay1jb250cm9sbGVyIHtcbiAgZGlzcGxheTogbm9uZTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICByaWdodDogOHB4O1xuICB0b3A6IDMwJTtcbn1cblxuLypcbiAgVGFzayBpdGVtIGFuaW1hdGlvblxuICovXG4uYW5pbWF0aW9uX3Nob3d0YXNrLXRyYW5zaXRpb24ge1xuICB0cmFuc2l0aW9uOiBhbGwgMC41cyBlYXNlO1xufVxuLmFuaW1hdGlvbl9zaG93dGFzay1lbnRlciwgLmFuaW1hdGlvbl9zaG93dGFzay1sZWF2ZSB7XG4gIG9wYWNpdHk6IDA7XG4gIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpO1xufVxuLmFuaW1hdGlvbl9zaG93dGFzayB7XG4gICYtZW50ZXIge1xuICAgIG9wYWNpdHk6IDA7XG4gICAgdHJhbnNmb3JtOiByb3RhdGVYKDE4MGRlZyk7XG4gIH1cbiAgJi1sZXZhZSB7XG4gICAgb3BhY2l0eTogMDtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZVgoMTgwZGVnKTtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xuICB9XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogdGFza0l0ZW0udnVlP2I5NmRjNjQwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 69 */
/***/ function(module, exports) {

	eval("module.exports = \"\\n<div class=\\\"task\\\" transition=\\\"animation_showtask\\\" v-bind:class=\\\"{finished: task.completed, editing: task == taskEditing}\\\" >\\n  <div class=\\\"task-checkbox\\\">\\n    <label class=\\\"robin-checkbox\\\" for=\\\"{{task.id}}\\\">\\n      <input type=\\\"checkbox\\\" id=\\\"{{task.id}}\\\" class=\\\"robin-checkbox--input\\\" v-on:change=\\\"toggleTask(task)\\\" :checked=\\\"task.completed\\\">\\n      <span class=\\\"robin-checkbox--label\\\"></span>\\n    </label>\\n  </div>\\n  <div class=\\\"task-content\\\">\\n    <div class=\\\"task-content-box\\\" @click=\\\"showTaskDetail(task)\\\">{{task.title}}</div>\\n    <!-- <div class=\\\"task-content-box\\\" @dblclick=\\\"modifyTask(task)\\\">{{task.title}}</div> -->\\n    <div class=\\\"robin-textfield task-content-input\\\">\\n      <input class=\\\"robin-textfield--input robin-textfield--input_default\\\" type=\\\"text\\\" v-task-autofocus=\\\"task == taskEditing\\\" v-model=\\\"task.title\\\" class=\\\"edit\\\" v-on:blur=\\\"doEdit(task)\\\"  v-on:keyup.esc=\\\"doEdit(task)\\\" v-on:keyup.enter=\\\"doEdit(task, $event)\\\" />\\n    </div>\\n    <div class=\\\"task-metadata\\\" v-if=\\\"task.completed\\\">\\n      <span>更新时间：{{task.update_time}}</span>\\n      <span>创建时间：{{task.create_time}}</span>\\n    </div>\\n  </div>\\n  <span class=\\\"task-controller\\\">\\n    <i class=\\\"material-icons\\\" @click=\\\"deleteTask(task)\\\">clear</i>\\n  </span>\\n</div>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrSXRlbS52dWU/ZmIyMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwwRkFBMEYsdURBQXVELG1GQUFtRixTQUFTLDJDQUEyQyxTQUFTLHFSQUFxUixZQUFZLGtGQUFrRixZQUFZLGtiQUFrYixrQkFBa0IsNEJBQTRCLGtCQUFrQiIsImZpbGUiOiI2OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJ0YXNrXFxcIiB0cmFuc2l0aW9uPVxcXCJhbmltYXRpb25fc2hvd3Rhc2tcXFwiIHYtYmluZDpjbGFzcz1cXFwie2ZpbmlzaGVkOiB0YXNrLmNvbXBsZXRlZCwgZWRpdGluZzogdGFzayA9PSB0YXNrRWRpdGluZ31cXFwiID5cXG4gIDxkaXYgY2xhc3M9XFxcInRhc2stY2hlY2tib3hcXFwiPlxcbiAgICA8bGFiZWwgY2xhc3M9XFxcInJvYmluLWNoZWNrYm94XFxcIiBmb3I9XFxcInt7dGFzay5pZH19XFxcIj5cXG4gICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGlkPVxcXCJ7e3Rhc2suaWR9fVxcXCIgY2xhc3M9XFxcInJvYmluLWNoZWNrYm94LS1pbnB1dFxcXCIgdi1vbjpjaGFuZ2U9XFxcInRvZ2dsZVRhc2sodGFzaylcXFwiIDpjaGVja2VkPVxcXCJ0YXNrLmNvbXBsZXRlZFxcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInJvYmluLWNoZWNrYm94LS1sYWJlbFxcXCI+PC9zcGFuPlxcbiAgICA8L2xhYmVsPlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJ0YXNrLWNvbnRlbnRcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0YXNrLWNvbnRlbnQtYm94XFxcIiBAY2xpY2s9XFxcInNob3dUYXNrRGV0YWlsKHRhc2spXFxcIj57e3Rhc2sudGl0bGV9fTwvZGl2PlxcbiAgICA8IS0tIDxkaXYgY2xhc3M9XFxcInRhc2stY29udGVudC1ib3hcXFwiIEBkYmxjbGljaz1cXFwibW9kaWZ5VGFzayh0YXNrKVxcXCI+e3t0YXNrLnRpdGxlfX08L2Rpdj4gLS0+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvYmluLXRleHRmaWVsZCB0YXNrLWNvbnRlbnQtaW5wdXRcXFwiPlxcbiAgICAgIDxpbnB1dCBjbGFzcz1cXFwicm9iaW4tdGV4dGZpZWxkLS1pbnB1dCByb2Jpbi10ZXh0ZmllbGQtLWlucHV0X2RlZmF1bHRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHYtdGFzay1hdXRvZm9jdXM9XFxcInRhc2sgPT0gdGFza0VkaXRpbmdcXFwiIHYtbW9kZWw9XFxcInRhc2sudGl0bGVcXFwiIGNsYXNzPVxcXCJlZGl0XFxcIiB2LW9uOmJsdXI9XFxcImRvRWRpdCh0YXNrKVxcXCIgIHYtb246a2V5dXAuZXNjPVxcXCJkb0VkaXQodGFzaylcXFwiIHYtb246a2V5dXAuZW50ZXI9XFxcImRvRWRpdCh0YXNrLCAkZXZlbnQpXFxcIiAvPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidGFzay1tZXRhZGF0YVxcXCIgdi1pZj1cXFwidGFzay5jb21wbGV0ZWRcXFwiPlxcbiAgICAgIDxzcGFuPuabtOaWsOaXtumXtO+8mnt7dGFzay51cGRhdGVfdGltZX19PC9zcGFuPlxcbiAgICAgIDxzcGFuPuWIm+W7uuaXtumXtO+8mnt7dGFzay5jcmVhdGVfdGltZX19PC9zcGFuPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPHNwYW4gY2xhc3M9XFxcInRhc2stY29udHJvbGxlclxcXCI+XFxuICAgIDxpIGNsYXNzPVxcXCJtYXRlcmlhbC1pY29uc1xcXCIgQGNsaWNrPVxcXCJkZWxldGVUYXNrKHRhc2spXFxcIj5jbGVhcjwvaT5cXG4gIDwvc3Bhbj5cXG48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2FwcC9zcmMvY29tcG9uZW50cy90YXNrL3Rhc2tJdGVtLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_script__, __vue_template__\n__webpack_require__(71)\n__vue_script__ = __webpack_require__(72)\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] app/src/components/task/addItem.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = __webpack_require__(75)\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (false) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"_v-2bdcc064/addItem.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay9hZGRJdGVtLnZ1ZT83MTRhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esc0JBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBLFlBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhbGVzcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9hZGRJdGVtLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2FkZEl0ZW0udnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIGFwcC9zcmMvY29tcG9uZW50cy90YXNrL2FkZEl0ZW0udnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vYWRkSXRlbS52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0yYmRjYzA2NC9hZGRJdGVtLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zcmMvY29tcG9uZW50cy90YXNrL2FkZEl0ZW0udnVlXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 71 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay9hZGRJdGVtLnZ1ZT8zMmJjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjcxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcInJlbW92ZVwiOnRydWV9IS4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vbGVzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2FwcC9zcmMvY29tcG9uZW50cy90YXNrL2FkZEl0ZW0udnVlXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = __webpack_require__(73);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _tasks = __webpack_require__(58);\n\nvar taskActions = _interopRequireWildcard(_tasks);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import * as getters from '../../vuex/getter';\n\nexports.default = {\n  data: function data() {\n    return {\n      list_id: '',\n      newTask: {\n        title: '',\n        list_id: '',\n        create_time: '',\n        attachments: []\n      }\n    };\n  },\n\n  vuex: {\n    actions: {\n      addTask: taskActions.addTask\n    }\n  },\n  watch: {\n    'newTask.title': function newTaskTitle() {\n      localStorage.newTask = (0, _stringify2.default)(this.newTask);\n    }\n  },\n  ready: function ready() {\n    this.list_id = this.$route.params.id;\n    this.newTask = window.localStorage.newTask ? JSON.parse(localStorage.newTask) : {};\n  },\n\n\n  methods: {\n    // 创建任务\n    createTask: function createTask(listid) {\n      if (!this.newTask.title) {\n        return false;\n      }\n\n      this.$set('newTask.create_time', new Date());\n      this.$set('newTask.list_id', listid);\n\n      this.addTask(this.newTask);\n\n      this.$set('newTask', {\n        title: '',\n        create_time: '',\n        attachments: []\n      });\n    }\n  }\n\n};\n\n// </script>\n//\n// <style lang=\"less\">\n//\n// @import '../../public/stylesheets/variables';\n//\n// .modal.bottom-sheet{\n//   max-height: 60%;\n// }\n//\n// .task-textfield{\n//   width: 100%;\n//   background: #fff;\n//   margin-bottom: 20px;\n//   box-sizing: border-box;\n//   &--input{\n//     width: 100%;\n//     height: 40px;\n//     font-size: 18px;\n//     padding: 6px 10px;\n//     box-sizing: border-box;\n//     border: none;\n//     outline: none;\n//     &:focus{\n//       box-shadow: 0 0 5px #ABABAB;\n//     }\n//   }\n// }\n//\n// </style>\n\n/* generated by vue-loader */\n// <template>\n//     <div class=\"task-textfield\">\n//       <input class=\"task-textfield--input\" type=\"text\" v-model=\"newTask.title\" @keyup.enter=\"createTask(list_id)\">\n//     </div>\n// </template>\n//\n// <script>//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYWRkSXRlbS52dWU/ZWUyMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBT0E7Ozs7Ozs7O0FBR0E7Ozt3QkFFQTs7ZUFFQTs7ZUFFQTtpQkFDQTtxQkFDQTtxQkFHQTtBQU5BO0FBRkE7QUFTQTs7OzsyQkFLQTtBQUhBO0FBREE7OzZDQU1BOzJEQUNBO0FBRUE7QUFKQTswQkFLQTtzQ0FDQTtvRkFDQTtBQUVBOzs7O0FBRUE7NENBQ0E7K0JBQ0E7ZUFDQTtBQUVBOzsyQ0FDQTttQ0FFQTs7d0JBRUE7OztlQUVBO3FCQUNBO3FCQUVBO0FBSkE7QUFPQTtBQW5CQTs7QUEzQkEiLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cInRhc2stdGV4dGZpZWxkXCI+XG4gICAgICA8aW5wdXQgY2xhc3M9XCJ0YXNrLXRleHRmaWVsZC0taW5wdXRcIiB0eXBlPVwidGV4dFwiIHYtbW9kZWw9XCJuZXdUYXNrLnRpdGxlXCIgQGtleXVwLmVudGVyPVwiY3JlYXRlVGFzayhsaXN0X2lkKVwiPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCAqIGFzIHRhc2tBY3Rpb25zIGZyb20gJy4uLy4uL3Z1ZXgvYWN0aW9ucy90YXNrcyc7XG4vLyBpbXBvcnQgKiBhcyBnZXR0ZXJzIGZyb20gJy4uLy4uL3Z1ZXgvZ2V0dGVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXN0X2lkOiAnJyxcbiAgICAgIG5ld1Rhc2s6IHtcbiAgICAgICAgdGl0bGU6ICcnLFxuICAgICAgICBsaXN0X2lkOiAnJyxcbiAgICAgICAgY3JlYXRlX3RpbWU6ICcnLFxuICAgICAgICBhdHRhY2htZW50czogW11cbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbiAgdnVleDoge1xuICAgIGFjdGlvbnM6IHtcbiAgICAgIGFkZFRhc2s6IHRhc2tBY3Rpb25zLmFkZFRhc2ssXG4gICAgfSxcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAnbmV3VGFzay50aXRsZSc6IGZ1bmN0aW9uKCkge1xuICAgICAgbG9jYWxTdG9yYWdlLm5ld1Rhc2sgPSBKU09OLnN0cmluZ2lmeSh0aGlzLm5ld1Rhc2spO1xuICAgIH0sXG4gIH0sXG4gIHJlYWR5KCkge1xuICAgIHRoaXMubGlzdF9pZCA9IHRoaXMuJHJvdXRlLnBhcmFtcy5pZDtcbiAgICB0aGlzLm5ld1Rhc2sgPSB3aW5kb3cubG9jYWxTdG9yYWdlLm5ld1Rhc2sgPyBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5uZXdUYXNrKSA6IHt9O1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICAvLyDliJvlu7rku7vliqFcbiAgICBjcmVhdGVUYXNrKGxpc3RpZCkge1xuICAgICAgaWYgKCF0aGlzLm5ld1Rhc2sudGl0bGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRzZXQoJ25ld1Rhc2suY3JlYXRlX3RpbWUnLCBuZXcgRGF0ZSgpKTtcbiAgICAgIHRoaXMuJHNldCgnbmV3VGFzay5saXN0X2lkJywgbGlzdGlkKTtcblxuICAgICAgdGhpcy5hZGRUYXNrKHRoaXMubmV3VGFzayk7XG5cbiAgICAgIHRoaXMuJHNldCgnbmV3VGFzaycsIHtcbiAgICAgICAgdGl0bGU6ICcnLFxuICAgICAgICBjcmVhdGVfdGltZTogJycsXG4gICAgICAgIGF0dGFjaG1lbnRzOiBbXVxuICAgICAgfSk7XG4gICAgfSxcbiAgfVxuXG59O1xuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cbkBpbXBvcnQgJy4uLy4uL3B1YmxpYy9zdHlsZXNoZWV0cy92YXJpYWJsZXMnO1xuXG4ubW9kYWwuYm90dG9tLXNoZWV0e1xuICBtYXgtaGVpZ2h0OiA2MCU7XG59XG5cbi50YXNrLXRleHRmaWVsZHtcbiAgd2lkdGg6IDEwMCU7XG4gIGJhY2tncm91bmQ6ICNmZmY7XG4gIG1hcmdpbi1ib3R0b206IDIwcHg7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICYtLWlucHV0e1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogNDBweDtcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgcGFkZGluZzogNnB4IDEwcHg7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgICAmOmZvY3Vze1xuICAgICAgYm94LXNoYWRvdzogMCAwIDVweCAjQUJBQkFCO1xuICAgIH1cbiAgfVxufVxuXG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogYWRkSXRlbS52dWU/NTRmNDk4ZjZcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = { \"default\": __webpack_require__(74), __esModule: true };//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qcz80NTc0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQiIsImZpbGUiOiI3My5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qc1xuICoqIG1vZHVsZSBpZCA9IDczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	eval("var core  = __webpack_require__(30)\n  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\nmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qcz82NzA4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRSx3Q0FBd0M7QUFDeEM7QUFDQSIsImZpbGUiOiI3NC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBjb3JlICA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKVxuICAsICRKU09OID0gY29yZS5KU09OIHx8IChjb3JlLkpTT04gPSB7c3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeX0pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiAkSlNPTi5zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3VtZW50cyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qc1xuICoqIG1vZHVsZSBpZCA9IDc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 75 */
/***/ function(module, exports) {

	eval("module.exports = \"\\n<div class=\\\"task-textfield\\\">\\n  <input class=\\\"task-textfield--input\\\" type=\\\"text\\\" v-model=\\\"newTask.title\\\" @keyup.enter=\\\"createTask(list_id)\\\">\\n</div>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay9hZGRJdGVtLnZ1ZT8yYTlkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Ijc1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInRhc2stdGV4dGZpZWxkXFxcIj5cXG4gIDxpbnB1dCBjbGFzcz1cXFwidGFzay10ZXh0ZmllbGQtLWlucHV0XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiB2LW1vZGVsPVxcXCJuZXdUYXNrLnRpdGxlXFxcIiBAa2V5dXAuZW50ZXI9XFxcImNyZWF0ZVRhc2sobGlzdF9pZClcXFwiPlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vYXBwL3NyYy9jb21wb25lbnRzL3Rhc2svYWRkSXRlbS52dWVcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 76 */
/***/ function(module, exports) {

	eval("module.exports = \"\\n<div class=\\\"main-container\\\" transition=\\\"animate_routerview\\\">\\n  <div class=\\\"main\\\">\\n    <additem :listid=\\\"listId\\\"></additem>\\n    <div class=\\\"tasklist\\\">\\n      <taskitem v-for=\\\"task in tasklist\\\" :task=\\\"task\\\" :index=\\\"$index\\\" track-by=\\\"id\\\"></taskitem>\\n    </div>\\n    <div class=\\\"label-trigger\\\" @click=\\\"toggleShowCompletedTask\\\">\\n      显示已完成的task\\n    </div>\\n    <div class=\\\"tasklist--finished\\\" transition=\\\"animation_showtask\\\" v-show=\\\"completedShow\\\">\\n      <taskitem v-for=\\\"task in completedTasklist\\\" :task=\\\"task\\\" :index=\\\"$index\\\" track-by=\\\"id\\\"></taskitem>\\n    </div>\\n  </div>\\n</div>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdGFzay90YXNrTGlzdC52dWU/MmM2ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI3Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJtYWluLWNvbnRhaW5lclxcXCIgdHJhbnNpdGlvbj1cXFwiYW5pbWF0ZV9yb3V0ZXJ2aWV3XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1haW5cXFwiPlxcbiAgICA8YWRkaXRlbSA6bGlzdGlkPVxcXCJsaXN0SWRcXFwiPjwvYWRkaXRlbT5cXG4gICAgPGRpdiBjbGFzcz1cXFwidGFza2xpc3RcXFwiPlxcbiAgICAgIDx0YXNraXRlbSB2LWZvcj1cXFwidGFzayBpbiB0YXNrbGlzdFxcXCIgOnRhc2s9XFxcInRhc2tcXFwiIDppbmRleD1cXFwiJGluZGV4XFxcIiB0cmFjay1ieT1cXFwiaWRcXFwiPjwvdGFza2l0ZW0+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsYWJlbC10cmlnZ2VyXFxcIiBAY2xpY2s9XFxcInRvZ2dsZVNob3dDb21wbGV0ZWRUYXNrXFxcIj5cXG4gICAgICDmmL7npLrlt7LlrozmiJDnmoR0YXNrXFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0YXNrbGlzdC0tZmluaXNoZWRcXFwiIHRyYW5zaXRpb249XFxcImFuaW1hdGlvbl9zaG93dGFza1xcXCIgdi1zaG93PVxcXCJjb21wbGV0ZWRTaG93XFxcIj5cXG4gICAgICA8dGFza2l0ZW0gdi1mb3I9XFxcInRhc2sgaW4gY29tcGxldGVkVGFza2xpc3RcXFwiIDp0YXNrPVxcXCJ0YXNrXFxcIiA6aW5kZXg9XFxcIiRpbmRleFxcXCIgdHJhY2stYnk9XFxcImlkXFxcIj48L3Rhc2tpdGVtPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Z1ZS1odG1sLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vYXBwL3NyYy9jb21wb25lbnRzL3Rhc2svdGFza0xpc3QudnVlXG4gKiogbW9kdWxlIGlkID0gNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_script__, __vue_template__\n__webpack_require__(78)\n__vue_script__ = __webpack_require__(79)\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] app/src/components/user/login.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = __webpack_require__(80)\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (false) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"_v-596342bf/login.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdXNlci9sb2dpbi52dWU/MTQxMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHNCQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQSxZQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI3Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIWxlc3MhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vbG9naW4udnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vbG9naW4udnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIGFwcC9zcmMvY29tcG9uZW50cy91c2VyL2xvZ2luLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2xvZ2luLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTU5NjM0MmJmL2xvZ2luLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zcmMvY29tcG9uZW50cy91c2VyL2xvZ2luLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 78 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdXNlci9sb2dpbi52dWU/YjRhZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI3OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+L2xlc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9hcHAvc3JjL2NvbXBvbmVudHMvdXNlci9sb2dpbi52dWVcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _user = __webpack_require__(45);\n\nvar userActions = _interopRequireWildcard(_user);\n\nvar _getter = __webpack_require__(18);\n\nvar getters = _interopRequireWildcard(_getter);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// <template>\n//   <div class=\"custom-container login-form\" transition=\"animate_routerview\">\n//     <div class=\"mdl-grid\">\n//       <div class=\"mdl-cell mdl-cell-6-col\">\n//         <h3>登录</h3>\n//       </div>\n//     </div>\n//     <div class=\"mdl-grid\">\n//       <div class=\"mdl-cell mdl-cell-6-col\">\n//         <div class=\"robin-textfield\">\n//           <label class=\"mdl-textfield__label\" for=\"email\">Email</label>\n//           <input class=\"robin-textfield--input robin-textfield--input_default\" type=\"text\" id=\"email\" v-model=\"account.username\">\n//         </div>\n//       </div>\n//     </div>\n//     <div class=\"mdl-cell mdl-cell-6-col\">\n//       <div class=\"mdl-textfield mdl-js-textfield\">\n//         <label class=\"mdl-textfield__label\" for=\"password\">Password</label>\n//         <input class=\"robin-textfield--input robin-textfield--input_default\" type=\"password\" id=\"password\" v-model=\"account.password\">\n//       </div>\n//     </div>\n//     <div class=\"mdl-cell mdl-cell-6-col\">\n//       <div class=\"robin-textfield\">\n//         <button class=\"robin-btn robin-btn__default\"  v-on:click=\"doLogin\">GO!</button>\n//         <a v-link=\"{path: '/signup', exact: true}\">还没有账号？立马注册</a>\n//       </div>\n//     </div>\n//   </div>\n// </div>\n// </template>\n// <script>\nexports.default = {\n  data: function data() {\n    return {\n      account: {\n        username: '',\n        password: ''\n      }\n    };\n  },\n\n  vuex: {\n    actions: {\n      login: userActions.login\n    },\n    getters: {\n      // user: getters.getUserInfo\n    }\n  },\n  ready: function ready() {},\n\n  watch: {\n    user: function user(newVal, old) {\n      if (!newVal) {\n        this.$router.go('login');\n      }\n      if (newVal && newVal.username) {\n        this.$router.go('lists');\n      }\n    }\n  },\n  methods: {\n    doLogin: function doLogin() {\n      this.login(this.account);\n    }\n  }\n};\n// </script>\n// <style lang=\"less\">\n//  .login-form {\n//   width:400px;\n//   padding:14px;\n//   box-sizing: border-box;\n//   margin: 120px auto;\n//   background: rgba(255,255,255,0.8);\n//  }\n// </style>\n\n/* generated by vue-loader *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbG9naW4udnVlPzYxOTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBK0JBOzs7O0FBQ0E7O0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFFQTs7O2tCQUdBO2tCQUdBO0FBSkE7QUFEQTtBQU1BOzs7O3lCQUlBO0FBRkE7O0FBTUE7QUFIQTtBQUpBOzBCQVFBLENBQ0E7OztxQ0FFQTttQkFDQTt3QkFDQTtBQUNBO3FDQUNBO3dCQUNBO0FBQ0E7QUFFQTtBQVRBOztnQ0FXQTtzQkFDQTtBQUVBO0FBSkE7QUE3QkEiLCJmaWxlIjoiNzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJjdXN0b20tY29udGFpbmVyIGxvZ2luLWZvcm1cIiB0cmFuc2l0aW9uPVwiYW5pbWF0ZV9yb3V0ZXJ2aWV3XCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kbC1ncmlkXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRsLWNlbGwgbWRsLWNlbGwtNi1jb2xcIj5cbiAgICAgICAgPGgzPueZu+W9lTwvaDM+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWRsLWdyaWRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGwtY2VsbCBtZGwtY2VsbC02LWNvbFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm9iaW4tdGV4dGZpZWxkXCI+XG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwibWRsLXRleHRmaWVsZF9fbGFiZWxcIiBmb3I9XCJlbWFpbFwiPkVtYWlsPC9sYWJlbD5cbiAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJyb2Jpbi10ZXh0ZmllbGQtLWlucHV0IHJvYmluLXRleHRmaWVsZC0taW5wdXRfZGVmYXVsdFwiIHR5cGU9XCJ0ZXh0XCIgaWQ9XCJlbWFpbFwiIHYtbW9kZWw9XCJhY2NvdW50LnVzZXJuYW1lXCI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kbC1jZWxsIG1kbC1jZWxsLTYtY29sXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRsLXRleHRmaWVsZCBtZGwtanMtdGV4dGZpZWxkXCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cIm1kbC10ZXh0ZmllbGRfX2xhYmVsXCIgZm9yPVwicGFzc3dvcmRcIj5QYXNzd29yZDwvbGFiZWw+XG4gICAgICAgIDxpbnB1dCBjbGFzcz1cInJvYmluLXRleHRmaWVsZC0taW5wdXQgcm9iaW4tdGV4dGZpZWxkLS1pbnB1dF9kZWZhdWx0XCIgdHlwZT1cInBhc3N3b3JkXCIgaWQ9XCJwYXNzd29yZFwiIHYtbW9kZWw9XCJhY2NvdW50LnBhc3N3b3JkXCI+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWRsLWNlbGwgbWRsLWNlbGwtNi1jb2xcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJyb2Jpbi10ZXh0ZmllbGRcIj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInJvYmluLWJ0biByb2Jpbi1idG5fX2RlZmF1bHRcIiAgdi1vbjpjbGljaz1cImRvTG9naW5cIj5HTyE8L2J1dHRvbj5cbiAgICAgICAgPGEgdi1saW5rPVwie3BhdGg6ICcvc2lnbnVwJywgZXhhY3Q6IHRydWV9XCI+6L+Y5rKh5pyJ6LSm5Y+377yf56uL6ams5rOo5YaMPC9hPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbiAgaW1wb3J0ICogYXMgdXNlckFjdGlvbnMgZnJvbSAnLi4vLi4vdnVleC9hY3Rpb25zL3VzZXInO1xuICBpbXBvcnQgKiBhcyBnZXR0ZXJzIGZyb20gJy4uLy4uL3Z1ZXgvZ2V0dGVyJztcbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY2NvdW50OiB7XG4gICAgICAgICAgdXNlcm5hbWU6ICcnLFxuICAgICAgICAgIHBhc3N3b3JkOiAnJyxcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZ1ZXg6IHtcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgbG9naW46IHVzZXJBY3Rpb25zLmxvZ2luLFxuICAgICAgfSxcbiAgICAgIGdldHRlcnM6IHtcbiAgICAgICAgLy8gdXNlcjogZ2V0dGVycy5nZXRVc2VySW5mb1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVhZHkoKSB7XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgdXNlcjogZnVuY3Rpb24obmV3VmFsLCBvbGQpIHtcbiAgICAgICAgaWYgKCFuZXdWYWwpIHtcbiAgICAgICAgICB0aGlzLiRyb3V0ZXIuZ28oJ2xvZ2luJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1ZhbCAmJiBuZXdWYWwudXNlcm5hbWUpIHtcbiAgICAgICAgICB0aGlzLiRyb3V0ZXIuZ28oJ2xpc3RzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGRvTG9naW4oKSB7XG4gICAgICAgIHRoaXMubG9naW4odGhpcy5hY2NvdW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG48L3NjcmlwdD5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuIC5sb2dpbi1mb3JtIHtcbiAgd2lkdGg6NDAwcHg7XG4gIHBhZGRpbmc6MTRweDtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgbWFyZ2luOiAxMjBweCBhdXRvO1xuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwyNTUsMjU1LDAuOCk7XG4gfVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIGxvZ2luLnZ1ZT8yZDFkZjgyOVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 80 */
/***/ function(module, exports) {

	eval("module.exports = \"\\n  <div class=\\\"custom-container login-form\\\" transition=\\\"animate_routerview\\\">\\n    <div class=\\\"mdl-grid\\\">\\n      <div class=\\\"mdl-cell mdl-cell-6-col\\\">\\n        <h3>登录</h3>\\n      </div>\\n    </div>\\n    <div class=\\\"mdl-grid\\\">\\n      <div class=\\\"mdl-cell mdl-cell-6-col\\\">\\n        <div class=\\\"robin-textfield\\\">\\n          <label class=\\\"mdl-textfield__label\\\" for=\\\"email\\\">Email</label>\\n          <input class=\\\"robin-textfield--input robin-textfield--input_default\\\" type=\\\"text\\\" id=\\\"email\\\" v-model=\\\"account.username\\\">\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\\\"mdl-cell mdl-cell-6-col\\\">\\n      <div class=\\\"mdl-textfield mdl-js-textfield\\\">\\n        <label class=\\\"mdl-textfield__label\\\" for=\\\"password\\\">Password</label>\\n        <input class=\\\"robin-textfield--input robin-textfield--input_default\\\" type=\\\"password\\\" id=\\\"password\\\" v-model=\\\"account.password\\\">\\n      </div>\\n    </div>\\n    <div class=\\\"mdl-cell mdl-cell-6-col\\\">\\n      <div class=\\\"robin-textfield\\\">\\n        <button class=\\\"robin-btn robin-btn__default\\\"  v-on:click=\\\"doLogin\\\">GO!</button>\\n        <a v-link=\\\"{path: '/signup', exact: true}\\\">还没有账号？立马注册</a>\\n      </div>\\n    </div>\\n  </div>\\n</div>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdXNlci9sb2dpbi52dWU/YTI4ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw2bkNBQTZuQyw2QkFBNkIiLCJmaWxlIjoiODAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuICA8ZGl2IGNsYXNzPVxcXCJjdXN0b20tY29udGFpbmVyIGxvZ2luLWZvcm1cXFwiIHRyYW5zaXRpb249XFxcImFuaW1hdGVfcm91dGVydmlld1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1kbC1ncmlkXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtZGwtY2VsbCBtZGwtY2VsbC02LWNvbFxcXCI+XFxuICAgICAgICA8aDM+55m75b2VPC9oMz5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1kbC1ncmlkXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtZGwtY2VsbCBtZGwtY2VsbC02LWNvbFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb2Jpbi10ZXh0ZmllbGRcXFwiPlxcbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcIm1kbC10ZXh0ZmllbGRfX2xhYmVsXFxcIiBmb3I9XFxcImVtYWlsXFxcIj5FbWFpbDwvbGFiZWw+XFxuICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwicm9iaW4tdGV4dGZpZWxkLS1pbnB1dCByb2Jpbi10ZXh0ZmllbGQtLWlucHV0X2RlZmF1bHRcXFwiIHR5cGU9XFxcInRleHRcXFwiIGlkPVxcXCJlbWFpbFxcXCIgdi1tb2RlbD1cXFwiYWNjb3VudC51c2VybmFtZVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1kbC1jZWxsIG1kbC1jZWxsLTYtY29sXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtZGwtdGV4dGZpZWxkIG1kbC1qcy10ZXh0ZmllbGRcXFwiPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJtZGwtdGV4dGZpZWxkX19sYWJlbFxcXCIgZm9yPVxcXCJwYXNzd29yZFxcXCI+UGFzc3dvcmQ8L2xhYmVsPlxcbiAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJyb2Jpbi10ZXh0ZmllbGQtLWlucHV0IHJvYmluLXRleHRmaWVsZC0taW5wdXRfZGVmYXVsdFxcXCIgdHlwZT1cXFwicGFzc3dvcmRcXFwiIGlkPVxcXCJwYXNzd29yZFxcXCIgdi1tb2RlbD1cXFwiYWNjb3VudC5wYXNzd29yZFxcXCI+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJtZGwtY2VsbCBtZGwtY2VsbC02LWNvbFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicm9iaW4tdGV4dGZpZWxkXFxcIj5cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcInJvYmluLWJ0biByb2Jpbi1idG5fX2RlZmF1bHRcXFwiICB2LW9uOmNsaWNrPVxcXCJkb0xvZ2luXFxcIj5HTyE8L2J1dHRvbj5cXG4gICAgICAgIDxhIHYtbGluaz1cXFwie3BhdGg6ICcvc2lnbnVwJywgZXhhY3Q6IHRydWV9XFxcIj7ov5jmsqHmnInotKblj7fvvJ/nq4vpqazms6jlhow8L2E+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9hcHAvc3JjL2NvbXBvbmVudHMvdXNlci9sb2dpbi52dWVcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_script__, __vue_template__\n__vue_script__ = __webpack_require__(82)\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] app/src/components/user/signup.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = __webpack_require__(83)\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (false) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"_v-1f5f0232/signup.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdXNlci9zaWdudXAudnVlPzJmNDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQSxZQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI4MS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3NpZ251cC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gYXBwL3NyYy9jb21wb25lbnRzL3VzZXIvc2lnbnVwLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NpZ251cC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0xZjVmMDIzMi9zaWdudXAudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3NyYy9jb21wb25lbnRzL3VzZXIvc2lnbnVwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 82 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// <template>\n//   <div class=\"custom-container\" transition=\"animate_routerview\">\n//     <div class=\"mdl-grid\">\n//       <div class=\"mdl-cell mdl-cell-6-col\">\n//         <h3>注册</h3>\n//       </div>\n//       <div class=\"mdl-cell mdl-cell-6-col\">\n//         <div class=\"mdl-textfield mdl-js-textfield\">\n//             <input class=\"mdl-textfield__input\" type=\"text\" id=\"email\" v-model=\"registerData.email\"/>\n//             <label class=\"mdl-textfield__label\" for=\"email\">邮箱</label>\n//           </div>\n//         <div class=\"mdl-textfield mdl-js-textfield\">\n//           <input class=\"mdl-textfield__input\" type=\"password\" id=\"password\" v-model=\"registerData.password\"/>\n//           <label class=\"mdl-textfield__label\" for=\"password\">密码</label>\n//         </div>\n//         <div class=\"input-field col s12\">\n//             <button class=\"mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--accent\" v-on:click=\"signUp()\">注册</button>\n//             <a v-link=\"'login'\">已有账号？直接登录</a>\n//         </div>\n//       </div>\n//     </div>\n//   </div>\n// </template>\n// <script>\nexports.default = {\n  data: function data() {\n    return {\n      registerData: {\n        email: '',\n        password: ''\n      }\n    };\n  },\n  ready: function ready() {\n    console.log('sign up --->');\n  },\n\n\n  methods: {\n    signUp: function signUp() {\n      var vm = this;\n      var data = this.$data.registerData;\n      vm.$http.post('user/signup', data).then(function (res) {\n        localStorage.token = res.token;\n        vm.$router.go('/task');\n      }, function (err) {\n        console.log(err);\n      });\n    }\n  }\n};\n// </script>\n\n/* generated by vue-loader *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc2lnbnVwLnZ1ZT80YmQ4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7O3dCQUVBOzs7ZUFHQTtrQkFHQTtBQUpBO0FBREE7QUFPQTswQkFDQTtnQkFDQTtBQUVBOzs7OzhCQUVBO2VBQ0E7NEJBQ0E7bUNBQ0EsMEJBQ0E7aUNBQ0E7c0JBQ0E7d0JBQ0E7b0JBQ0E7QUFDQTtBQUVBO0FBWkE7QUFkQSIsImZpbGUiOiI4Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImN1c3RvbS1jb250YWluZXJcIiB0cmFuc2l0aW9uPVwiYW5pbWF0ZV9yb3V0ZXJ2aWV3XCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kbC1ncmlkXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRsLWNlbGwgbWRsLWNlbGwtNi1jb2xcIj5cbiAgICAgICAgPGgzPuazqOWGjDwvaDM+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGwtY2VsbCBtZGwtY2VsbC02LWNvbFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWRsLXRleHRmaWVsZCBtZGwtanMtdGV4dGZpZWxkXCI+XG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJtZGwtdGV4dGZpZWxkX19pbnB1dFwiIHR5cGU9XCJ0ZXh0XCIgaWQ9XCJlbWFpbFwiIHYtbW9kZWw9XCJyZWdpc3RlckRhdGEuZW1haWxcIi8+XG4gICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJtZGwtdGV4dGZpZWxkX19sYWJlbFwiIGZvcj1cImVtYWlsXCI+6YKu566xPC9sYWJlbD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1kbC10ZXh0ZmllbGQgbWRsLWpzLXRleHRmaWVsZFwiPlxuICAgICAgICAgIDxpbnB1dCBjbGFzcz1cIm1kbC10ZXh0ZmllbGRfX2lucHV0XCIgdHlwZT1cInBhc3N3b3JkXCIgaWQ9XCJwYXNzd29yZFwiIHYtbW9kZWw9XCJyZWdpc3RlckRhdGEucGFzc3dvcmRcIi8+XG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwibWRsLXRleHRmaWVsZF9fbGFiZWxcIiBmb3I9XCJwYXNzd29yZFwiPuWvhueggTwvbGFiZWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZmllbGQgY29sIHMxMlwiPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIm1kbC1idXR0b24gbWRsLWpzLWJ1dHRvbiBtZGwtYnV0dG9uLS1yYWlzZWQgbWRsLWpzLXJpcHBsZS1lZmZlY3QgbWRsLWJ1dHRvbi0tYWNjZW50XCIgdi1vbjpjbGljaz1cInNpZ25VcCgpXCI+5rOo5YaMPC9idXR0b24+XG4gICAgICAgICAgICA8YSB2LWxpbms9XCInbG9naW4nXCI+5bey5pyJ6LSm5Y+377yf55u05o6l55m75b2VPC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZ2lzdGVyRGF0YToge1xuICAgICAgICAgIGVtYWlsOiAnJyxcbiAgICAgICAgICBwYXNzd29yZDogJycsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICByZWFkeSgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdzaWduIHVwIC0tLT4nKTtcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgc2lnblVwKCkge1xuICAgICAgICBsZXQgdm0gPSB0aGlzO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuJGRhdGEucmVnaXN0ZXJEYXRhO1xuICAgICAgICB2bS4kaHR0cC5wb3N0KCd1c2VyL3NpZ251cCcsIGRhdGEpXG4gICAgICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS50b2tlbiA9IHJlcy50b2tlbjtcbiAgICAgICAgICAgIHZtLiRyb3V0ZXIuZ28oJy90YXNrJyk7XG4gICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICB9LFxuICAgIH0sXG4gIH07XG48L3NjcmlwdD5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNpZ251cC52dWU/YWNmMmY5YzZcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 83 */
/***/ function(module, exports) {

	eval("module.exports = \"\\n<div class=\\\"custom-container\\\" transition=\\\"animate_routerview\\\">\\n  <div class=\\\"mdl-grid\\\">\\n    <div class=\\\"mdl-cell mdl-cell-6-col\\\">\\n      <h3>注册</h3>\\n    </div>\\n    <div class=\\\"mdl-cell mdl-cell-6-col\\\">\\n      <div class=\\\"mdl-textfield mdl-js-textfield\\\">\\n          <input class=\\\"mdl-textfield__input\\\" type=\\\"text\\\" id=\\\"email\\\" v-model=\\\"registerData.email\\\"/>\\n          <label class=\\\"mdl-textfield__label\\\" for=\\\"email\\\">邮箱</label>\\n        </div>\\n      <div class=\\\"mdl-textfield mdl-js-textfield\\\">\\n        <input class=\\\"mdl-textfield__input\\\" type=\\\"password\\\" id=\\\"password\\\" v-model=\\\"registerData.password\\\"/>\\n        <label class=\\\"mdl-textfield__label\\\" for=\\\"password\\\">密码</label>\\n      </div>\\n      <div class=\\\"input-field col s12\\\">\\n          <button class=\\\"mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--accent\\\" v-on:click=\\\"signUp()\\\">注册</button>\\n          <a v-link=\\\"'login'\\\">已有账号？直接登录</a>\\n      </div>\\n    </div>\\n  </div>\\n</div>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvdXNlci9zaWdudXAudnVlPzBhNGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiODMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiY3VzdG9tLWNvbnRhaW5lclxcXCIgdHJhbnNpdGlvbj1cXFwiYW5pbWF0ZV9yb3V0ZXJ2aWV3XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1kbC1ncmlkXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibWRsLWNlbGwgbWRsLWNlbGwtNi1jb2xcXFwiPlxcbiAgICAgIDxoMz7ms6jlhow8L2gzPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibWRsLWNlbGwgbWRsLWNlbGwtNi1jb2xcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1kbC10ZXh0ZmllbGQgbWRsLWpzLXRleHRmaWVsZFxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwibWRsLXRleHRmaWVsZF9faW5wdXRcXFwiIHR5cGU9XFxcInRleHRcXFwiIGlkPVxcXCJlbWFpbFxcXCIgdi1tb2RlbD1cXFwicmVnaXN0ZXJEYXRhLmVtYWlsXFxcIi8+XFxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwibWRsLXRleHRmaWVsZF9fbGFiZWxcXFwiIGZvcj1cXFwiZW1haWxcXFwiPumCrueusTwvbGFiZWw+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtZGwtdGV4dGZpZWxkIG1kbC1qcy10ZXh0ZmllbGRcXFwiPlxcbiAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJtZGwtdGV4dGZpZWxkX19pbnB1dFxcXCIgdHlwZT1cXFwicGFzc3dvcmRcXFwiIGlkPVxcXCJwYXNzd29yZFxcXCIgdi1tb2RlbD1cXFwicmVnaXN0ZXJEYXRhLnBhc3N3b3JkXFxcIi8+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcIm1kbC10ZXh0ZmllbGRfX2xhYmVsXFxcIiBmb3I9XFxcInBhc3N3b3JkXFxcIj7lr4bnoIE8L2xhYmVsPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0LWZpZWxkIGNvbCBzMTJcXFwiPlxcbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJtZGwtYnV0dG9uIG1kbC1qcy1idXR0b24gbWRsLWJ1dHRvbi0tcmFpc2VkIG1kbC1qcy1yaXBwbGUtZWZmZWN0IG1kbC1idXR0b24tLWFjY2VudFxcXCIgdi1vbjpjbGljaz1cXFwic2lnblVwKClcXFwiPuazqOWGjDwvYnV0dG9uPlxcbiAgICAgICAgICA8YSB2LWxpbms9XFxcIidsb2dpbidcXFwiPuW3suaciei0puWPt++8n+ebtOaOpeeZu+W9lTwvYT5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi92dWUtaHRtbC1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2FwcC9zcmMvY29tcG9uZW50cy91c2VyL3NpZ251cC52dWVcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 84 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3B1YmxpYy9zdHlsZXNoZWV0cy9zdHlsZS5sZXNzPzhiYTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiODQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hcHAvc3JjL3B1YmxpYy9zdHlsZXNoZWV0cy9zdHlsZS5sZXNzXG4gKiogbW9kdWxlIGlkID0gODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ]);